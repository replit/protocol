/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.api = (function() {
    
        /**
         * Namespace api.
         * @exports api
         * @namespace
         */
        var api = {};
    
        api.Command = (function() {
    
            /**
             * Properties of a Command.
             * @memberof api
             * @interface ICommand
             * @property {number|null} [channel] Command channel
             * @property {number|null} [session] Command session
             * @property {api.OpenChannel|api.IOpenChannel|null} [openChan] Command openChan
             * @property {api.OpenChannelRes|api.IOpenChannelRes|null} [openChanRes] Command openChanRes
             * @property {api.CloseChannel|api.ICloseChannel|null} [closeChan] Command closeChan
             * @property {api.CloseChannelRes|api.ICloseChannelRes|null} [closeChanRes] Command closeChanRes
             * @property {api.ContainerState|api.IContainerState|null} [containerState] Command containerState
             * @property {api.PortOpen|api.IPortOpen|null} [portOpen] Command portOpen
             * @property {api.Toast|api.IToast|null} [toast] Command toast
             * @property {api.Redirect|api.IRedirect|null} [redirect] Command redirect
             * @property {api.AlwaysOn|api.IAlwaysOn|null} [alwaysOn] Command alwaysOn
             * @property {api.RunMain|api.IRunMain|null} [runMain] Command runMain
             * @property {api.Clear|api.IClear|null} [clear] Command clear
             * @property {string|null} ["eval"] Command eval
             * @property {string|null} [result] Command result
             * @property {string|null} [input] Command input
             * @property {string|null} [output] Command output
             * @property {string|null} [error] Command error
             * @property {api.SaneTerm|api.ISaneTerm|null} [saneTerm] Command saneTerm
             * @property {api.ResizeTerm|api.IResizeTerm|null} [resizeTerm] Command resizeTerm
             * @property {api.State|null} [state] Command state
             * @property {api.OK|api.IOK|null} [ok] Command ok
             * @property {api.File|api.IFile|null} [persist] Command persist
             * @property {api.File|api.IFile|null} [persistMirror] Command persistMirror
             * @property {api.File|api.IFile|null} [write] Command write
             * @property {api.File|api.IFile|null} [remove] Command remove
             * @property {api.Move|api.IMove|null} [move] Command move
             * @property {api.File|api.IFile|null} [tryRemove] Command tryRemove
             * @property {api.File|api.IFile|null} [mkdir] Command mkdir
             * @property {api.File|api.IFile|null} [stat] Command stat
             * @property {api.StatResult|api.IStatResult|null} [statRes] Command statRes
             * @property {api.TransferStart|api.ITransferStart|null} [transferStart] Command transferStart
             * @property {api.TransferChunk|api.ITransferChunk|null} [transferChunk] Command transferChunk
             * @property {api.TransferComplete|api.ITransferComplete|null} [transferComplete] Command transferComplete
             * @property {api.Transfer|api.ITransfer|null} [transferCancel] Command transferCancel
             * @property {api.Transfer|api.ITransfer|null} [transfer] Command transfer
             * @property {api.File|api.IFile|null} [read] Command read
             * @property {api.File|api.IFile|null} [readdir] Command readdir
             * @property {api.Files|api.IFiles|null} [files] Command files
             * @property {api.File|api.IFile|null} [file] Command file
             * @property {api.CheckChanges|api.ICheckChanges|null} [checkChanges] Command checkChanges
             * @property {api.Files|api.IFiles|null} [changedFiles] Command changedFiles
             * @property {api.LintResults|api.ILintResults|null} [lintResults] Command lintResults
             * @property {api.ContainedTest|api.IContainedTest|null} [runContainedTest] Command runContainedTest
             * @property {api.TestResult|api.ITestResult|null} [testResult] Command testResult
             * @property {string|null} [debuggerStart] Command debuggerStart
             * @property {api.RunMain|api.IRunMain|null} [debuggerStep] Command debuggerStep
             * @property {api.DebugStatus|api.IDebugStatus|null} [debuggerStatus] Command debuggerStatus
             * @property {api.EnsurePackages|api.IEnsurePackages|null} [ensurePackages] Command ensurePackages
             * @property {api.Ping|api.IPing|null} [ping] Command ping
             * @property {api.Pong|api.IPong|null} [pong] Command pong
             * @property {api.Hello|api.IHello|null} [hello] Command hello
             * @property {api.Goodbye|api.IGoodbye|null} [goodbye] Command goodbye
             * @property {api.Hint|api.IHint|null} [hint] Command hint
             * @property {api.Connect|api.IConnect|null} [connect] Command connect
             * @property {api.Send|api.ISend|null} [send] Command send
             * @property {api.Recv|api.IRecv|null} [recv] Command recv
             * @property {api.Disconnect|api.IDisconnect|null} [disconnect] Command disconnect
             * @property {api.FileAuthReq|api.IFileAuthReq|null} [fileAuthReq] Command fileAuthReq
             * @property {api.FileAuthRes|api.IFileAuthRes|null} [fileAuthRes] Command fileAuthRes
             * @property {api.MultiFileAuthRes|api.IMultiFileAuthRes|null} [mutliFileAuthRes] Command mutliFileAuthRes
             * @property {api.ListObjects|api.IListObjects|null} [listObjects] Command listObjects
             * @property {api.ListObjectsResp|api.IListObjectsResp|null} [listObjectsResp] Command listObjectsResp
             * @property {api.OTPacket|api.IOTPacket|null} [ot] Command ot
             * @property {api.OTStatus|api.IOTStatus|null} [otstatus] Command otstatus
             * @property {api.OTLinkFile|api.IOTLinkFile|null} [otLinkFile] Command otLinkFile
             * @property {api.OTCursor|api.IOTCursor|null} [otNewCursor] Command otNewCursor
             * @property {api.OTCursor|api.IOTCursor|null} [otDeleteCursor] Command otDeleteCursor
             * @property {api.OTFetchRequest|api.IOTFetchRequest|null} [otFetchRequest] Command otFetchRequest
             * @property {api.OTFetchResponse|api.IOTFetchResponse|null} [otFetchResponse] Command otFetchResponse
             * @property {api.OTTransformSelectionRequest|api.IOTTransformSelectionRequest|null} [otTransformSelectionRequest] Command otTransformSelectionRequest
             * @property {api.OTTransformSelectionResponse|api.IOTTransformSelectionResponse|null} [otTransformSelectionResponse] Command otTransformSelectionResponse
             * @property {api.Flush|api.IFlush|null} [flush] Command flush
             * @property {api.Debug|api.IDebug|null} [debug] Command debug
             * @property {api.StartVCR|api.IStartVCR|null} [startVCR] Command startVCR
             * @property {api.ReadVCR|api.IReadVCR|null} [readVCR] Command readVCR
             * @property {api.VCRLog|api.IVCRLog|null} [VCRLog] Command VCRLog
             * @property {api.Auth|api.IAuth|null} [auth] Command auth
             * @property {api.ExecInfo|api.IExecInfo|null} [execInfo] Command execInfo
             * @property {api.SubscribeFile|api.ISubscribeFile|null} [subscribeFile] Command subscribeFile
             * @property {api.FileEvent|api.IFileEvent|null} [fileEvent] Command fileEvent
             * @property {api.Roster|api.IRoster|null} [roster] Command roster
             * @property {api.User|api.IUser|null} [join] Command join
             * @property {api.User|api.IUser|null} [part] Command part
             * @property {api.OpenFile|api.IOpenFile|null} [openFile] Command openFile
             * @property {api.FileOpened|api.IFileOpened|null} [fileOpened] Command fileOpened
             * @property {api.FollowUser|api.IFollowUser|null} [followUser] Command followUser
             * @property {api.UnfollowUser|api.IUnfollowUser|null} [unfollowUser] Command unfollowUser
             * @property {api.UpdateSessionTimestamp|api.IUpdateSessionTimestamp|null} [updateSessionTimestamp] Command updateSessionTimestamp
             * @property {api.SessionTimestampUpdated|api.ISessionTimestampUpdated|null} [sessionTimestampUpdated] Command sessionTimestampUpdated
             * @property {api.Exec|api.IExec|null} [exec] Command exec
             * @property {api.PackageSearch|api.IPackageSearch|null} [packageSearch] Command packageSearch
             * @property {api.PackageSearchResp|api.IPackageSearchResp|null} [packageSearchResp] Command packageSearchResp
             * @property {api.PackageInfo|api.IPackageInfo|null} [packageInfo] Command packageInfo
             * @property {api.PackageInfoResp|api.IPackageInfoResp|null} [packageInfoResp] Command packageInfoResp
             * @property {api.PackageAdd|api.IPackageAdd|null} [packageAdd] Command packageAdd
             * @property {api.PackageRemove|api.IPackageRemove|null} [packageRemove] Command packageRemove
             * @property {api.PackageInstall|api.IPackageInstall|null} [packageInstall] Command packageInstall
             * @property {api.PackageListSpecfile|api.IPackageListSpecfile|null} [packageListSpecfile] Command packageListSpecfile
             * @property {api.PackageListSpecfileResp|api.IPackageListSpecfileResp|null} [packageListSpecfileResp] Command packageListSpecfileResp
             * @property {api.PackageCacheSave|api.IPackageCacheSave|null} [packageCacheSave] Command packageCacheSave
             * @property {api.ChatMessage|api.IChatMessage|null} [chatMessage] Command chatMessage
             * @property {api.ChatTyping|api.IChatTyping|null} [chatTyping] Command chatTyping
             * @property {api.ChatScrollback|api.IChatScrollback|null} [chatScrollback] Command chatScrollback
             * @property {api.FSSnapshot|api.IFSSnapshot|null} [fsSnapshot] Command fsSnapshot
             * @property {api.FSLock|api.IFSLock|null} [fsTakeLock] Command fsTakeLock
             * @property {api.FSLock|api.IFSLock|null} [fsReleaseLock] Command fsReleaseLock
             * @property {boolean|null} [hasCap] Command hasCap
             * @property {api.Pid1Config|api.IPid1Config|null} [pid1Config] Command pid1Config
             * @property {api.Metrics|api.IMetrics|null} [metrics] Command metrics
             * @property {api.BootStatus|api.IBootStatus|null} [bootStatus] Command bootStatus
             * @property {api.ReadMeta|api.IReadMeta|null} [readMeta] Command readMeta
             * @property {api.WriteMeta|api.IWriteMeta|null} [writeMeta] Command writeMeta
             * @property {api.AppendMeta|api.IAppendMeta|null} [appendMeta] Command appendMeta
             * @property {api.Audio|api.IAudio|null} [audio] Command audio
             * @property {api.PprofRequest|api.IPprofRequest|null} [pprofRequest] Command pprofRequest
             * @property {api.PprofResponse|api.IPprofResponse|null} [pprofResponse] Command pprofResponse
             * @property {api.Audio2|api.IAudio2|null} [audio2] Command audio2
             * @property {api.PTYConfig|api.IPTYConfig|null} [PTYConfig] Command PTYConfig
             * @property {api.DebugMain|api.IDebugMain|null} [debugMain] Command debugMain
             * @property {api.DebugState|api.IDebugState|null} [debugState] Command debugState
             * @property {api.DebugMainReply|api.IDebugMainReply|null} [debugMainReply] Command debugMainReply
             * @property {api.DebugInput|api.IDebugInput|null} [debugInput] Command debugInput
             * @property {api.DebugOutput|api.IDebugOutput|null} [debugOutput] Command debugOutput
             * @property {api.DebugStop|api.IDebugStop|null} [debugStop] Command debugStop
             * @property {api.DebugLeave|api.IDebugLeave|null} [debugLeave] Command debugLeave
             * @property {api.DebugSessions|api.IDebugSessions|null} [debugSessions] Command debugSessions
             * @property {api.DebugAddBreakpointRequest|api.IDebugAddBreakpointRequest|null} [debugAddBreakpointRequest] Command debugAddBreakpointRequest
             * @property {api.DebugRemoveBreakpointRequest|api.IDebugRemoveBreakpointRequest|null} [debugRemoveBreakpointRequest] Command debugRemoveBreakpointRequest
             * @property {api.DebugBreakpointEvent|api.IDebugBreakpointEvent|null} [debugBreakpointEvent] Command debugBreakpointEvent
             * @property {api.DotReplitGetRequest|api.IDotReplitGetRequest|null} [dotReplitGetRequest] Command dotReplitGetRequest
             * @property {api.DotReplitGetResponse|api.IDotReplitGetResponse|null} [dotReplitGetResponse] Command dotReplitGetResponse
             * @property {string|null} [ref] Command ref
             */
    
            /**
             * Constructs a new Command.
             * @memberof api
             * @classdesc Represents a Command.
             * @constructor
             * @param {api.ICommand=} [properties] Properties to set
             */
            function Command(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Command channel.
             * @member {number} channel
             * @memberof api.Command
             * @instance
             */
            Command.prototype.channel = 0;
    
            /**
             * Command session.
             * @member {number} session
             * @memberof api.Command
             * @instance
             */
            Command.prototype.session = 0;
    
            /**
             * Command openChan.
             * @member {api.OpenChannel|null|undefined} openChan
             * @memberof api.Command
             * @instance
             */
            Command.prototype.openChan = null;
    
            /**
             * Command openChanRes.
             * @member {api.OpenChannelRes|null|undefined} openChanRes
             * @memberof api.Command
             * @instance
             */
            Command.prototype.openChanRes = null;
    
            /**
             * Command closeChan.
             * @member {api.CloseChannel|null|undefined} closeChan
             * @memberof api.Command
             * @instance
             */
            Command.prototype.closeChan = null;
    
            /**
             * Command closeChanRes.
             * @member {api.CloseChannelRes|null|undefined} closeChanRes
             * @memberof api.Command
             * @instance
             */
            Command.prototype.closeChanRes = null;
    
            /**
             * Command containerState.
             * @member {api.ContainerState|null|undefined} containerState
             * @memberof api.Command
             * @instance
             */
            Command.prototype.containerState = null;
    
            /**
             * Command portOpen.
             * @member {api.PortOpen|null|undefined} portOpen
             * @memberof api.Command
             * @instance
             */
            Command.prototype.portOpen = null;
    
            /**
             * Command toast.
             * @member {api.Toast|null|undefined} toast
             * @memberof api.Command
             * @instance
             */
            Command.prototype.toast = null;
    
            /**
             * Command redirect.
             * @member {api.Redirect|null|undefined} redirect
             * @memberof api.Command
             * @instance
             */
            Command.prototype.redirect = null;
    
            /**
             * Command alwaysOn.
             * @member {api.AlwaysOn|null|undefined} alwaysOn
             * @memberof api.Command
             * @instance
             */
            Command.prototype.alwaysOn = null;
    
            /**
             * Command runMain.
             * @member {api.RunMain|null|undefined} runMain
             * @memberof api.Command
             * @instance
             */
            Command.prototype.runMain = null;
    
            /**
             * Command clear.
             * @member {api.Clear|null|undefined} clear
             * @memberof api.Command
             * @instance
             */
            Command.prototype.clear = null;
    
            /**
             * Command eval.
             * @member {string} eval
             * @memberof api.Command
             * @instance
             */
            Command.prototype["eval"] = "";
    
            /**
             * Command result.
             * @member {string} result
             * @memberof api.Command
             * @instance
             */
            Command.prototype.result = "";
    
            /**
             * Command input.
             * @member {string} input
             * @memberof api.Command
             * @instance
             */
            Command.prototype.input = "";
    
            /**
             * Command output.
             * @member {string} output
             * @memberof api.Command
             * @instance
             */
            Command.prototype.output = "";
    
            /**
             * Command error.
             * @member {string} error
             * @memberof api.Command
             * @instance
             */
            Command.prototype.error = "";
    
            /**
             * Command saneTerm.
             * @member {api.SaneTerm|null|undefined} saneTerm
             * @memberof api.Command
             * @instance
             */
            Command.prototype.saneTerm = null;
    
            /**
             * Command resizeTerm.
             * @member {api.ResizeTerm|null|undefined} resizeTerm
             * @memberof api.Command
             * @instance
             */
            Command.prototype.resizeTerm = null;
    
            /**
             * Command state.
             * @member {api.State} state
             * @memberof api.Command
             * @instance
             */
            Command.prototype.state = 0;
    
            /**
             * Command ok.
             * @member {api.OK|null|undefined} ok
             * @memberof api.Command
             * @instance
             */
            Command.prototype.ok = null;
    
            /**
             * Command persist.
             * @member {api.File|null|undefined} persist
             * @memberof api.Command
             * @instance
             */
            Command.prototype.persist = null;
    
            /**
             * Command persistMirror.
             * @member {api.File|null|undefined} persistMirror
             * @memberof api.Command
             * @instance
             */
            Command.prototype.persistMirror = null;
    
            /**
             * Command write.
             * @member {api.File|null|undefined} write
             * @memberof api.Command
             * @instance
             */
            Command.prototype.write = null;
    
            /**
             * Command remove.
             * @member {api.File|null|undefined} remove
             * @memberof api.Command
             * @instance
             */
            Command.prototype.remove = null;
    
            /**
             * Command move.
             * @member {api.Move|null|undefined} move
             * @memberof api.Command
             * @instance
             */
            Command.prototype.move = null;
    
            /**
             * Command tryRemove.
             * @member {api.File|null|undefined} tryRemove
             * @memberof api.Command
             * @instance
             */
            Command.prototype.tryRemove = null;
    
            /**
             * Command mkdir.
             * @member {api.File|null|undefined} mkdir
             * @memberof api.Command
             * @instance
             */
            Command.prototype.mkdir = null;
    
            /**
             * Command stat.
             * @member {api.File|null|undefined} stat
             * @memberof api.Command
             * @instance
             */
            Command.prototype.stat = null;
    
            /**
             * Command statRes.
             * @member {api.StatResult|null|undefined} statRes
             * @memberof api.Command
             * @instance
             */
            Command.prototype.statRes = null;
    
            /**
             * Command transferStart.
             * @member {api.TransferStart|null|undefined} transferStart
             * @memberof api.Command
             * @instance
             */
            Command.prototype.transferStart = null;
    
            /**
             * Command transferChunk.
             * @member {api.TransferChunk|null|undefined} transferChunk
             * @memberof api.Command
             * @instance
             */
            Command.prototype.transferChunk = null;
    
            /**
             * Command transferComplete.
             * @member {api.TransferComplete|null|undefined} transferComplete
             * @memberof api.Command
             * @instance
             */
            Command.prototype.transferComplete = null;
    
            /**
             * Command transferCancel.
             * @member {api.Transfer|null|undefined} transferCancel
             * @memberof api.Command
             * @instance
             */
            Command.prototype.transferCancel = null;
    
            /**
             * Command transfer.
             * @member {api.Transfer|null|undefined} transfer
             * @memberof api.Command
             * @instance
             */
            Command.prototype.transfer = null;
    
            /**
             * Command read.
             * @member {api.File|null|undefined} read
             * @memberof api.Command
             * @instance
             */
            Command.prototype.read = null;
    
            /**
             * Command readdir.
             * @member {api.File|null|undefined} readdir
             * @memberof api.Command
             * @instance
             */
            Command.prototype.readdir = null;
    
            /**
             * Command files.
             * @member {api.Files|null|undefined} files
             * @memberof api.Command
             * @instance
             */
            Command.prototype.files = null;
    
            /**
             * Command file.
             * @member {api.File|null|undefined} file
             * @memberof api.Command
             * @instance
             */
            Command.prototype.file = null;
    
            /**
             * Command checkChanges.
             * @member {api.CheckChanges|null|undefined} checkChanges
             * @memberof api.Command
             * @instance
             */
            Command.prototype.checkChanges = null;
    
            /**
             * Command changedFiles.
             * @member {api.Files|null|undefined} changedFiles
             * @memberof api.Command
             * @instance
             */
            Command.prototype.changedFiles = null;
    
            /**
             * Command lintResults.
             * @member {api.LintResults|null|undefined} lintResults
             * @memberof api.Command
             * @instance
             */
            Command.prototype.lintResults = null;
    
            /**
             * Command runContainedTest.
             * @member {api.ContainedTest|null|undefined} runContainedTest
             * @memberof api.Command
             * @instance
             */
            Command.prototype.runContainedTest = null;
    
            /**
             * Command testResult.
             * @member {api.TestResult|null|undefined} testResult
             * @memberof api.Command
             * @instance
             */
            Command.prototype.testResult = null;
    
            /**
             * Command debuggerStart.
             * @member {string} debuggerStart
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debuggerStart = "";
    
            /**
             * Command debuggerStep.
             * @member {api.RunMain|null|undefined} debuggerStep
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debuggerStep = null;
    
            /**
             * Command debuggerStatus.
             * @member {api.DebugStatus|null|undefined} debuggerStatus
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debuggerStatus = null;
    
            /**
             * Command ensurePackages.
             * @member {api.EnsurePackages|null|undefined} ensurePackages
             * @memberof api.Command
             * @instance
             */
            Command.prototype.ensurePackages = null;
    
            /**
             * Command ping.
             * @member {api.Ping|null|undefined} ping
             * @memberof api.Command
             * @instance
             */
            Command.prototype.ping = null;
    
            /**
             * Command pong.
             * @member {api.Pong|null|undefined} pong
             * @memberof api.Command
             * @instance
             */
            Command.prototype.pong = null;
    
            /**
             * Command hello.
             * @member {api.Hello|null|undefined} hello
             * @memberof api.Command
             * @instance
             */
            Command.prototype.hello = null;
    
            /**
             * Command goodbye.
             * @member {api.Goodbye|null|undefined} goodbye
             * @memberof api.Command
             * @instance
             */
            Command.prototype.goodbye = null;
    
            /**
             * Command hint.
             * @member {api.Hint|null|undefined} hint
             * @memberof api.Command
             * @instance
             */
            Command.prototype.hint = null;
    
            /**
             * Command connect.
             * @member {api.Connect|null|undefined} connect
             * @memberof api.Command
             * @instance
             */
            Command.prototype.connect = null;
    
            /**
             * Command send.
             * @member {api.Send|null|undefined} send
             * @memberof api.Command
             * @instance
             */
            Command.prototype.send = null;
    
            /**
             * Command recv.
             * @member {api.Recv|null|undefined} recv
             * @memberof api.Command
             * @instance
             */
            Command.prototype.recv = null;
    
            /**
             * Command disconnect.
             * @member {api.Disconnect|null|undefined} disconnect
             * @memberof api.Command
             * @instance
             */
            Command.prototype.disconnect = null;
    
            /**
             * Command fileAuthReq.
             * @member {api.FileAuthReq|null|undefined} fileAuthReq
             * @memberof api.Command
             * @instance
             */
            Command.prototype.fileAuthReq = null;
    
            /**
             * Command fileAuthRes.
             * @member {api.FileAuthRes|null|undefined} fileAuthRes
             * @memberof api.Command
             * @instance
             */
            Command.prototype.fileAuthRes = null;
    
            /**
             * Command mutliFileAuthRes.
             * @member {api.MultiFileAuthRes|null|undefined} mutliFileAuthRes
             * @memberof api.Command
             * @instance
             */
            Command.prototype.mutliFileAuthRes = null;
    
            /**
             * Command listObjects.
             * @member {api.ListObjects|null|undefined} listObjects
             * @memberof api.Command
             * @instance
             */
            Command.prototype.listObjects = null;
    
            /**
             * Command listObjectsResp.
             * @member {api.ListObjectsResp|null|undefined} listObjectsResp
             * @memberof api.Command
             * @instance
             */
            Command.prototype.listObjectsResp = null;
    
            /**
             * Command ot.
             * @member {api.OTPacket|null|undefined} ot
             * @memberof api.Command
             * @instance
             */
            Command.prototype.ot = null;
    
            /**
             * Command otstatus.
             * @member {api.OTStatus|null|undefined} otstatus
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otstatus = null;
    
            /**
             * Command otLinkFile.
             * @member {api.OTLinkFile|null|undefined} otLinkFile
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otLinkFile = null;
    
            /**
             * Command otNewCursor.
             * @member {api.OTCursor|null|undefined} otNewCursor
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otNewCursor = null;
    
            /**
             * Command otDeleteCursor.
             * @member {api.OTCursor|null|undefined} otDeleteCursor
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otDeleteCursor = null;
    
            /**
             * Command otFetchRequest.
             * @member {api.OTFetchRequest|null|undefined} otFetchRequest
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otFetchRequest = null;
    
            /**
             * Command otFetchResponse.
             * @member {api.OTFetchResponse|null|undefined} otFetchResponse
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otFetchResponse = null;
    
            /**
             * Command otTransformSelectionRequest.
             * @member {api.OTTransformSelectionRequest|null|undefined} otTransformSelectionRequest
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otTransformSelectionRequest = null;
    
            /**
             * Command otTransformSelectionResponse.
             * @member {api.OTTransformSelectionResponse|null|undefined} otTransformSelectionResponse
             * @memberof api.Command
             * @instance
             */
            Command.prototype.otTransformSelectionResponse = null;
    
            /**
             * Command flush.
             * @member {api.Flush|null|undefined} flush
             * @memberof api.Command
             * @instance
             */
            Command.prototype.flush = null;
    
            /**
             * Command debug.
             * @member {api.Debug|null|undefined} debug
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debug = null;
    
            /**
             * Command startVCR.
             * @member {api.StartVCR|null|undefined} startVCR
             * @memberof api.Command
             * @instance
             */
            Command.prototype.startVCR = null;
    
            /**
             * Command readVCR.
             * @member {api.ReadVCR|null|undefined} readVCR
             * @memberof api.Command
             * @instance
             */
            Command.prototype.readVCR = null;
    
            /**
             * Command VCRLog.
             * @member {api.VCRLog|null|undefined} VCRLog
             * @memberof api.Command
             * @instance
             */
            Command.prototype.VCRLog = null;
    
            /**
             * Command auth.
             * @member {api.Auth|null|undefined} auth
             * @memberof api.Command
             * @instance
             */
            Command.prototype.auth = null;
    
            /**
             * Command execInfo.
             * @member {api.ExecInfo|null|undefined} execInfo
             * @memberof api.Command
             * @instance
             */
            Command.prototype.execInfo = null;
    
            /**
             * Command subscribeFile.
             * @member {api.SubscribeFile|null|undefined} subscribeFile
             * @memberof api.Command
             * @instance
             */
            Command.prototype.subscribeFile = null;
    
            /**
             * Command fileEvent.
             * @member {api.FileEvent|null|undefined} fileEvent
             * @memberof api.Command
             * @instance
             */
            Command.prototype.fileEvent = null;
    
            /**
             * Command roster.
             * @member {api.Roster|null|undefined} roster
             * @memberof api.Command
             * @instance
             */
            Command.prototype.roster = null;
    
            /**
             * Command join.
             * @member {api.User|null|undefined} join
             * @memberof api.Command
             * @instance
             */
            Command.prototype.join = null;
    
            /**
             * Command part.
             * @member {api.User|null|undefined} part
             * @memberof api.Command
             * @instance
             */
            Command.prototype.part = null;
    
            /**
             * Command openFile.
             * @member {api.OpenFile|null|undefined} openFile
             * @memberof api.Command
             * @instance
             */
            Command.prototype.openFile = null;
    
            /**
             * Command fileOpened.
             * @member {api.FileOpened|null|undefined} fileOpened
             * @memberof api.Command
             * @instance
             */
            Command.prototype.fileOpened = null;
    
            /**
             * Command followUser.
             * @member {api.FollowUser|null|undefined} followUser
             * @memberof api.Command
             * @instance
             */
            Command.prototype.followUser = null;
    
            /**
             * Command unfollowUser.
             * @member {api.UnfollowUser|null|undefined} unfollowUser
             * @memberof api.Command
             * @instance
             */
            Command.prototype.unfollowUser = null;
    
            /**
             * Command updateSessionTimestamp.
             * @member {api.UpdateSessionTimestamp|null|undefined} updateSessionTimestamp
             * @memberof api.Command
             * @instance
             */
            Command.prototype.updateSessionTimestamp = null;
    
            /**
             * Command sessionTimestampUpdated.
             * @member {api.SessionTimestampUpdated|null|undefined} sessionTimestampUpdated
             * @memberof api.Command
             * @instance
             */
            Command.prototype.sessionTimestampUpdated = null;
    
            /**
             * Command exec.
             * @member {api.Exec|null|undefined} exec
             * @memberof api.Command
             * @instance
             */
            Command.prototype.exec = null;
    
            /**
             * Command packageSearch.
             * @member {api.PackageSearch|null|undefined} packageSearch
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageSearch = null;
    
            /**
             * Command packageSearchResp.
             * @member {api.PackageSearchResp|null|undefined} packageSearchResp
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageSearchResp = null;
    
            /**
             * Command packageInfo.
             * @member {api.PackageInfo|null|undefined} packageInfo
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageInfo = null;
    
            /**
             * Command packageInfoResp.
             * @member {api.PackageInfoResp|null|undefined} packageInfoResp
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageInfoResp = null;
    
            /**
             * Command packageAdd.
             * @member {api.PackageAdd|null|undefined} packageAdd
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageAdd = null;
    
            /**
             * Command packageRemove.
             * @member {api.PackageRemove|null|undefined} packageRemove
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageRemove = null;
    
            /**
             * Command packageInstall.
             * @member {api.PackageInstall|null|undefined} packageInstall
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageInstall = null;
    
            /**
             * Command packageListSpecfile.
             * @member {api.PackageListSpecfile|null|undefined} packageListSpecfile
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageListSpecfile = null;
    
            /**
             * Command packageListSpecfileResp.
             * @member {api.PackageListSpecfileResp|null|undefined} packageListSpecfileResp
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageListSpecfileResp = null;
    
            /**
             * Command packageCacheSave.
             * @member {api.PackageCacheSave|null|undefined} packageCacheSave
             * @memberof api.Command
             * @instance
             */
            Command.prototype.packageCacheSave = null;
    
            /**
             * Command chatMessage.
             * @member {api.ChatMessage|null|undefined} chatMessage
             * @memberof api.Command
             * @instance
             */
            Command.prototype.chatMessage = null;
    
            /**
             * Command chatTyping.
             * @member {api.ChatTyping|null|undefined} chatTyping
             * @memberof api.Command
             * @instance
             */
            Command.prototype.chatTyping = null;
    
            /**
             * Command chatScrollback.
             * @member {api.ChatScrollback|null|undefined} chatScrollback
             * @memberof api.Command
             * @instance
             */
            Command.prototype.chatScrollback = null;
    
            /**
             * Command fsSnapshot.
             * @member {api.FSSnapshot|null|undefined} fsSnapshot
             * @memberof api.Command
             * @instance
             */
            Command.prototype.fsSnapshot = null;
    
            /**
             * Command fsTakeLock.
             * @member {api.FSLock|null|undefined} fsTakeLock
             * @memberof api.Command
             * @instance
             */
            Command.prototype.fsTakeLock = null;
    
            /**
             * Command fsReleaseLock.
             * @member {api.FSLock|null|undefined} fsReleaseLock
             * @memberof api.Command
             * @instance
             */
            Command.prototype.fsReleaseLock = null;
    
            /**
             * Command hasCap.
             * @member {boolean} hasCap
             * @memberof api.Command
             * @instance
             */
            Command.prototype.hasCap = false;
    
            /**
             * Command pid1Config.
             * @member {api.Pid1Config|null|undefined} pid1Config
             * @memberof api.Command
             * @instance
             */
            Command.prototype.pid1Config = null;
    
            /**
             * Command metrics.
             * @member {api.Metrics|null|undefined} metrics
             * @memberof api.Command
             * @instance
             */
            Command.prototype.metrics = null;
    
            /**
             * Command bootStatus.
             * @member {api.BootStatus|null|undefined} bootStatus
             * @memberof api.Command
             * @instance
             */
            Command.prototype.bootStatus = null;
    
            /**
             * Command readMeta.
             * @member {api.ReadMeta|null|undefined} readMeta
             * @memberof api.Command
             * @instance
             */
            Command.prototype.readMeta = null;
    
            /**
             * Command writeMeta.
             * @member {api.WriteMeta|null|undefined} writeMeta
             * @memberof api.Command
             * @instance
             */
            Command.prototype.writeMeta = null;
    
            /**
             * Command appendMeta.
             * @member {api.AppendMeta|null|undefined} appendMeta
             * @memberof api.Command
             * @instance
             */
            Command.prototype.appendMeta = null;
    
            /**
             * Command audio.
             * @member {api.Audio|null|undefined} audio
             * @memberof api.Command
             * @instance
             */
            Command.prototype.audio = null;
    
            /**
             * Command pprofRequest.
             * @member {api.PprofRequest|null|undefined} pprofRequest
             * @memberof api.Command
             * @instance
             */
            Command.prototype.pprofRequest = null;
    
            /**
             * Command pprofResponse.
             * @member {api.PprofResponse|null|undefined} pprofResponse
             * @memberof api.Command
             * @instance
             */
            Command.prototype.pprofResponse = null;
    
            /**
             * Command audio2.
             * @member {api.Audio2|null|undefined} audio2
             * @memberof api.Command
             * @instance
             */
            Command.prototype.audio2 = null;
    
            /**
             * Command PTYConfig.
             * @member {api.PTYConfig|null|undefined} PTYConfig
             * @memberof api.Command
             * @instance
             */
            Command.prototype.PTYConfig = null;
    
            /**
             * Command debugMain.
             * @member {api.DebugMain|null|undefined} debugMain
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugMain = null;
    
            /**
             * Command debugState.
             * @member {api.DebugState|null|undefined} debugState
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugState = null;
    
            /**
             * Command debugMainReply.
             * @member {api.DebugMainReply|null|undefined} debugMainReply
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugMainReply = null;
    
            /**
             * Command debugInput.
             * @member {api.DebugInput|null|undefined} debugInput
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugInput = null;
    
            /**
             * Command debugOutput.
             * @member {api.DebugOutput|null|undefined} debugOutput
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugOutput = null;
    
            /**
             * Command debugStop.
             * @member {api.DebugStop|null|undefined} debugStop
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugStop = null;
    
            /**
             * Command debugLeave.
             * @member {api.DebugLeave|null|undefined} debugLeave
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugLeave = null;
    
            /**
             * Command debugSessions.
             * @member {api.DebugSessions|null|undefined} debugSessions
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugSessions = null;
    
            /**
             * Command debugAddBreakpointRequest.
             * @member {api.DebugAddBreakpointRequest|null|undefined} debugAddBreakpointRequest
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugAddBreakpointRequest = null;
    
            /**
             * Command debugRemoveBreakpointRequest.
             * @member {api.DebugRemoveBreakpointRequest|null|undefined} debugRemoveBreakpointRequest
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugRemoveBreakpointRequest = null;
    
            /**
             * Command debugBreakpointEvent.
             * @member {api.DebugBreakpointEvent|null|undefined} debugBreakpointEvent
             * @memberof api.Command
             * @instance
             */
            Command.prototype.debugBreakpointEvent = null;
    
            /**
             * Command dotReplitGetRequest.
             * @member {api.DotReplitGetRequest|null|undefined} dotReplitGetRequest
             * @memberof api.Command
             * @instance
             */
            Command.prototype.dotReplitGetRequest = null;
    
            /**
             * Command dotReplitGetResponse.
             * @member {api.DotReplitGetResponse|null|undefined} dotReplitGetResponse
             * @memberof api.Command
             * @instance
             */
            Command.prototype.dotReplitGetResponse = null;
    
            /**
             * Command ref.
             * @member {string} ref
             * @memberof api.Command
             * @instance
             */
            Command.prototype.ref = "";
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Command body.
             * @member {"openChan"|"openChanRes"|"closeChan"|"closeChanRes"|"containerState"|"portOpen"|"toast"|"redirect"|"alwaysOn"|"runMain"|"clear"|"eval"|"result"|"input"|"output"|"error"|"saneTerm"|"resizeTerm"|"state"|"ok"|"persist"|"persistMirror"|"write"|"remove"|"move"|"tryRemove"|"mkdir"|"stat"|"statRes"|"transferStart"|"transferChunk"|"transferComplete"|"transferCancel"|"transfer"|"read"|"readdir"|"files"|"file"|"checkChanges"|"changedFiles"|"lintResults"|"runContainedTest"|"testResult"|"debuggerStart"|"debuggerStep"|"debuggerStatus"|"ensurePackages"|"ping"|"pong"|"hello"|"goodbye"|"hint"|"connect"|"send"|"recv"|"disconnect"|"fileAuthReq"|"fileAuthRes"|"mutliFileAuthRes"|"listObjects"|"listObjectsResp"|"ot"|"otstatus"|"otLinkFile"|"otNewCursor"|"otDeleteCursor"|"otFetchRequest"|"otFetchResponse"|"otTransformSelectionRequest"|"otTransformSelectionResponse"|"flush"|"debug"|"startVCR"|"readVCR"|"VCRLog"|"auth"|"execInfo"|"subscribeFile"|"fileEvent"|"roster"|"join"|"part"|"openFile"|"fileOpened"|"followUser"|"unfollowUser"|"updateSessionTimestamp"|"sessionTimestampUpdated"|"exec"|"packageSearch"|"packageSearchResp"|"packageInfo"|"packageInfoResp"|"packageAdd"|"packageRemove"|"packageInstall"|"packageListSpecfile"|"packageListSpecfileResp"|"packageCacheSave"|"chatMessage"|"chatTyping"|"chatScrollback"|"fsSnapshot"|"fsTakeLock"|"fsReleaseLock"|"hasCap"|"pid1Config"|"metrics"|"bootStatus"|"readMeta"|"writeMeta"|"appendMeta"|"audio"|"pprofRequest"|"pprofResponse"|"audio2"|"PTYConfig"|"debugMain"|"debugState"|"debugMainReply"|"debugInput"|"debugOutput"|"debugStop"|"debugLeave"|"debugSessions"|"debugAddBreakpointRequest"|"debugRemoveBreakpointRequest"|"debugBreakpointEvent"|"dotReplitGetRequest"|"dotReplitGetResponse"|undefined} body
             * @memberof api.Command
             * @instance
             */
            Object.defineProperty(Command.prototype, "body", {
                get: $util.oneOfGetter($oneOfFields = ["openChan", "openChanRes", "closeChan", "closeChanRes", "containerState", "portOpen", "toast", "redirect", "alwaysOn", "runMain", "clear", "eval", "result", "input", "output", "error", "saneTerm", "resizeTerm", "state", "ok", "persist", "persistMirror", "write", "remove", "move", "tryRemove", "mkdir", "stat", "statRes", "transferStart", "transferChunk", "transferComplete", "transferCancel", "transfer", "read", "readdir", "files", "file", "checkChanges", "changedFiles", "lintResults", "runContainedTest", "testResult", "debuggerStart", "debuggerStep", "debuggerStatus", "ensurePackages", "ping", "pong", "hello", "goodbye", "hint", "connect", "send", "recv", "disconnect", "fileAuthReq", "fileAuthRes", "mutliFileAuthRes", "listObjects", "listObjectsResp", "ot", "otstatus", "otLinkFile", "otNewCursor", "otDeleteCursor", "otFetchRequest", "otFetchResponse", "otTransformSelectionRequest", "otTransformSelectionResponse", "flush", "debug", "startVCR", "readVCR", "VCRLog", "auth", "execInfo", "subscribeFile", "fileEvent", "roster", "join", "part", "openFile", "fileOpened", "followUser", "unfollowUser", "updateSessionTimestamp", "sessionTimestampUpdated", "exec", "packageSearch", "packageSearchResp", "packageInfo", "packageInfoResp", "packageAdd", "packageRemove", "packageInstall", "packageListSpecfile", "packageListSpecfileResp", "packageCacheSave", "chatMessage", "chatTyping", "chatScrollback", "fsSnapshot", "fsTakeLock", "fsReleaseLock", "hasCap", "pid1Config", "metrics", "bootStatus", "readMeta", "writeMeta", "appendMeta", "audio", "pprofRequest", "pprofResponse", "audio2", "PTYConfig", "debugMain", "debugState", "debugMainReply", "debugInput", "debugOutput", "debugStop", "debugLeave", "debugSessions", "debugAddBreakpointRequest", "debugRemoveBreakpointRequest", "debugBreakpointEvent", "dotReplitGetRequest", "dotReplitGetResponse"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Command instance using the specified properties.
             * @function create
             * @memberof api.Command
             * @static
             * @param {api.ICommand=} [properties] Properties to set
             * @returns {api.Command} Command instance
             */
            Command.create = function create(properties) {
                return Command.fromObject(properties);
            };
    
            /**
             * Encodes the specified Command message. Does not implicitly {@link api.Command.verify|verify} messages.
             * @function encode
             * @memberof api.Command
             * @static
             * @param {api.Command} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.channel);
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.session);
                if (message.openChan != null && Object.hasOwnProperty.call(message, "openChan"))
                    $root.api.OpenChannel.encode(message.openChan, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.openChanRes != null && Object.hasOwnProperty.call(message, "openChanRes"))
                    $root.api.OpenChannelRes.encode(message.openChanRes, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.closeChan != null && Object.hasOwnProperty.call(message, "closeChan"))
                    $root.api.CloseChannel.encode(message.closeChan, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.closeChanRes != null && Object.hasOwnProperty.call(message, "closeChanRes"))
                    $root.api.CloseChannelRes.encode(message.closeChanRes, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.containerState != null && Object.hasOwnProperty.call(message, "containerState"))
                    $root.api.ContainerState.encode(message.containerState, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.portOpen != null && Object.hasOwnProperty.call(message, "portOpen"))
                    $root.api.PortOpen.encode(message.portOpen, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.toast != null && Object.hasOwnProperty.call(message, "toast"))
                    $root.api.Toast.encode(message.toast, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.redirect != null && Object.hasOwnProperty.call(message, "redirect"))
                    $root.api.Redirect.encode(message.redirect, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.alwaysOn != null && Object.hasOwnProperty.call(message, "alwaysOn"))
                    $root.api.AlwaysOn.encode(message.alwaysOn, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.runMain != null && Object.hasOwnProperty.call(message, "runMain"))
                    $root.api.RunMain.encode(message.runMain, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.clear != null && Object.hasOwnProperty.call(message, "clear"))
                    $root.api.Clear.encode(message.clear, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message["eval"] != null && Object.hasOwnProperty.call(message, "eval"))
                    writer.uint32(/* id 20, wireType 2 =*/162).string(message["eval"]);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 21, wireType 2 =*/170).string(message.result);
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 22, wireType 2 =*/178).string(message.input);
                if (message.output != null && Object.hasOwnProperty.call(message, "output"))
                    writer.uint32(/* id 23, wireType 2 =*/186).string(message.output);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 24, wireType 2 =*/194).string(message.error);
                if (message.saneTerm != null && Object.hasOwnProperty.call(message, "saneTerm"))
                    $root.api.SaneTerm.encode(message.saneTerm, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.resizeTerm != null && Object.hasOwnProperty.call(message, "resizeTerm"))
                    $root.api.ResizeTerm.encode(message.resizeTerm, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 28, wireType 0 =*/224).int32(message.state);
                if (message.ok != null && Object.hasOwnProperty.call(message, "ok"))
                    $root.api.OK.encode(message.ok, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.persist != null && Object.hasOwnProperty.call(message, "persist"))
                    $root.api.File.encode(message.persist, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                if (message.write != null && Object.hasOwnProperty.call(message, "write"))
                    $root.api.File.encode(message.write, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                if (message.remove != null && Object.hasOwnProperty.call(message, "remove"))
                    $root.api.File.encode(message.remove, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
                if (message.move != null && Object.hasOwnProperty.call(message, "move"))
                    $root.api.Move.encode(message.move, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                    $root.api.File.encode(message.read, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
                if (message.tryRemove != null && Object.hasOwnProperty.call(message, "tryRemove"))
                    $root.api.File.encode(message.tryRemove, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
                if (message.readdir != null && Object.hasOwnProperty.call(message, "readdir"))
                    $root.api.File.encode(message.readdir, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
                if (message.files != null && Object.hasOwnProperty.call(message, "files"))
                    $root.api.Files.encode(message.files, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
                if (message.mkdir != null && Object.hasOwnProperty.call(message, "mkdir"))
                    $root.api.File.encode(message.mkdir, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.api.File.encode(message.file, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                if (message.persistMirror != null && Object.hasOwnProperty.call(message, "persistMirror"))
                    $root.api.File.encode(message.persistMirror, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                if (message.checkChanges != null && Object.hasOwnProperty.call(message, "checkChanges"))
                    $root.api.CheckChanges.encode(message.checkChanges, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
                if (message.changedFiles != null && Object.hasOwnProperty.call(message, "changedFiles"))
                    $root.api.Files.encode(message.changedFiles, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
                if (message.lintResults != null && Object.hasOwnProperty.call(message, "lintResults"))
                    $root.api.LintResults.encode(message.lintResults, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
                if (message.runContainedTest != null && Object.hasOwnProperty.call(message, "runContainedTest"))
                    $root.api.ContainedTest.encode(message.runContainedTest, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
                if (message.testResult != null && Object.hasOwnProperty.call(message, "testResult"))
                    $root.api.TestResult.encode(message.testResult, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
                if (message.debuggerStart != null && Object.hasOwnProperty.call(message, "debuggerStart"))
                    writer.uint32(/* id 90, wireType 2 =*/722).string(message.debuggerStart);
                if (message.debuggerStep != null && Object.hasOwnProperty.call(message, "debuggerStep"))
                    $root.api.RunMain.encode(message.debuggerStep, writer.uint32(/* id 91, wireType 2 =*/730).fork()).ldelim();
                if (message.debuggerStatus != null && Object.hasOwnProperty.call(message, "debuggerStatus"))
                    $root.api.DebugStatus.encode(message.debuggerStatus, writer.uint32(/* id 92, wireType 2 =*/738).fork()).ldelim();
                if (message.ensurePackages != null && Object.hasOwnProperty.call(message, "ensurePackages"))
                    $root.api.EnsurePackages.encode(message.ensurePackages, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                    $root.api.Ping.encode(message.ping, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
                if (message.pong != null && Object.hasOwnProperty.call(message, "pong"))
                    $root.api.Pong.encode(message.pong, writer.uint32(/* id 121, wireType 2 =*/970).fork()).ldelim();
                if (message.hello != null && Object.hasOwnProperty.call(message, "hello"))
                    $root.api.Hello.encode(message.hello, writer.uint32(/* id 122, wireType 2 =*/978).fork()).ldelim();
                if (message.goodbye != null && Object.hasOwnProperty.call(message, "goodbye"))
                    $root.api.Goodbye.encode(message.goodbye, writer.uint32(/* id 123, wireType 2 =*/986).fork()).ldelim();
                if (message.hint != null && Object.hasOwnProperty.call(message, "hint"))
                    $root.api.Hint.encode(message.hint, writer.uint32(/* id 130, wireType 2 =*/1042).fork()).ldelim();
                if (message.connect != null && Object.hasOwnProperty.call(message, "connect"))
                    $root.api.Connect.encode(message.connect, writer.uint32(/* id 150, wireType 2 =*/1202).fork()).ldelim();
                if (message.send != null && Object.hasOwnProperty.call(message, "send"))
                    $root.api.Send.encode(message.send, writer.uint32(/* id 151, wireType 2 =*/1210).fork()).ldelim();
                if (message.recv != null && Object.hasOwnProperty.call(message, "recv"))
                    $root.api.Recv.encode(message.recv, writer.uint32(/* id 152, wireType 2 =*/1218).fork()).ldelim();
                if (message.disconnect != null && Object.hasOwnProperty.call(message, "disconnect"))
                    $root.api.Disconnect.encode(message.disconnect, writer.uint32(/* id 153, wireType 2 =*/1226).fork()).ldelim();
                if (message.fileAuthReq != null && Object.hasOwnProperty.call(message, "fileAuthReq"))
                    $root.api.FileAuthReq.encode(message.fileAuthReq, writer.uint32(/* id 200, wireType 2 =*/1602).fork()).ldelim();
                if (message.fileAuthRes != null && Object.hasOwnProperty.call(message, "fileAuthRes"))
                    $root.api.FileAuthRes.encode(message.fileAuthRes, writer.uint32(/* id 201, wireType 2 =*/1610).fork()).ldelim();
                if (message.mutliFileAuthRes != null && Object.hasOwnProperty.call(message, "mutliFileAuthRes"))
                    $root.api.MultiFileAuthRes.encode(message.mutliFileAuthRes, writer.uint32(/* id 202, wireType 2 =*/1618).fork()).ldelim();
                if (message.listObjects != null && Object.hasOwnProperty.call(message, "listObjects"))
                    $root.api.ListObjects.encode(message.listObjects, writer.uint32(/* id 205, wireType 2 =*/1642).fork()).ldelim();
                if (message.listObjectsResp != null && Object.hasOwnProperty.call(message, "listObjectsResp"))
                    $root.api.ListObjectsResp.encode(message.listObjectsResp, writer.uint32(/* id 206, wireType 2 =*/1650).fork()).ldelim();
                if (message.ot != null && Object.hasOwnProperty.call(message, "ot"))
                    $root.api.OTPacket.encode(message.ot, writer.uint32(/* id 220, wireType 2 =*/1762).fork()).ldelim();
                if (message.otstatus != null && Object.hasOwnProperty.call(message, "otstatus"))
                    $root.api.OTStatus.encode(message.otstatus, writer.uint32(/* id 221, wireType 2 =*/1770).fork()).ldelim();
                if (message.otLinkFile != null && Object.hasOwnProperty.call(message, "otLinkFile"))
                    $root.api.OTLinkFile.encode(message.otLinkFile, writer.uint32(/* id 222, wireType 2 =*/1778).fork()).ldelim();
                if (message.otNewCursor != null && Object.hasOwnProperty.call(message, "otNewCursor"))
                    $root.api.OTCursor.encode(message.otNewCursor, writer.uint32(/* id 223, wireType 2 =*/1786).fork()).ldelim();
                if (message.otDeleteCursor != null && Object.hasOwnProperty.call(message, "otDeleteCursor"))
                    $root.api.OTCursor.encode(message.otDeleteCursor, writer.uint32(/* id 224, wireType 2 =*/1794).fork()).ldelim();
                if (message.otFetchRequest != null && Object.hasOwnProperty.call(message, "otFetchRequest"))
                    $root.api.OTFetchRequest.encode(message.otFetchRequest, writer.uint32(/* id 225, wireType 2 =*/1802).fork()).ldelim();
                if (message.otFetchResponse != null && Object.hasOwnProperty.call(message, "otFetchResponse"))
                    $root.api.OTFetchResponse.encode(message.otFetchResponse, writer.uint32(/* id 226, wireType 2 =*/1810).fork()).ldelim();
                if (message.otTransformSelectionRequest != null && Object.hasOwnProperty.call(message, "otTransformSelectionRequest"))
                    $root.api.OTTransformSelectionRequest.encode(message.otTransformSelectionRequest, writer.uint32(/* id 227, wireType 2 =*/1818).fork()).ldelim();
                if (message.otTransformSelectionResponse != null && Object.hasOwnProperty.call(message, "otTransformSelectionResponse"))
                    $root.api.OTTransformSelectionResponse.encode(message.otTransformSelectionResponse, writer.uint32(/* id 228, wireType 2 =*/1826).fork()).ldelim();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    $root.api.Debug.encode(message.debug, writer.uint32(/* id 230, wireType 2 =*/1842).fork()).ldelim();
                if (message.startVCR != null && Object.hasOwnProperty.call(message, "startVCR"))
                    $root.api.StartVCR.encode(message.startVCR, writer.uint32(/* id 231, wireType 2 =*/1850).fork()).ldelim();
                if (message.readVCR != null && Object.hasOwnProperty.call(message, "readVCR"))
                    $root.api.ReadVCR.encode(message.readVCR, writer.uint32(/* id 232, wireType 2 =*/1858).fork()).ldelim();
                if (message.VCRLog != null && Object.hasOwnProperty.call(message, "VCRLog"))
                    $root.api.VCRLog.encode(message.VCRLog, writer.uint32(/* id 233, wireType 2 =*/1866).fork()).ldelim();
                if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                    $root.api.Auth.encode(message.auth, writer.uint32(/* id 235, wireType 2 =*/1882).fork()).ldelim();
                if (message.execInfo != null && Object.hasOwnProperty.call(message, "execInfo"))
                    $root.api.ExecInfo.encode(message.execInfo, writer.uint32(/* id 240, wireType 2 =*/1922).fork()).ldelim();
                if (message.flush != null && Object.hasOwnProperty.call(message, "flush"))
                    $root.api.Flush.encode(message.flush, writer.uint32(/* id 251, wireType 2 =*/2010).fork()).ldelim();
                if (message.subscribeFile != null && Object.hasOwnProperty.call(message, "subscribeFile"))
                    $root.api.SubscribeFile.encode(message.subscribeFile, writer.uint32(/* id 256, wireType 2 =*/2050).fork()).ldelim();
                if (message.fileEvent != null && Object.hasOwnProperty.call(message, "fileEvent"))
                    $root.api.FileEvent.encode(message.fileEvent, writer.uint32(/* id 257, wireType 2 =*/2058).fork()).ldelim();
                if (message.roster != null && Object.hasOwnProperty.call(message, "roster"))
                    $root.api.Roster.encode(message.roster, writer.uint32(/* id 260, wireType 2 =*/2082).fork()).ldelim();
                if (message.join != null && Object.hasOwnProperty.call(message, "join"))
                    $root.api.User.encode(message.join, writer.uint32(/* id 261, wireType 2 =*/2090).fork()).ldelim();
                if (message.part != null && Object.hasOwnProperty.call(message, "part"))
                    $root.api.User.encode(message.part, writer.uint32(/* id 262, wireType 2 =*/2098).fork()).ldelim();
                if (message.openFile != null && Object.hasOwnProperty.call(message, "openFile"))
                    $root.api.OpenFile.encode(message.openFile, writer.uint32(/* id 263, wireType 2 =*/2106).fork()).ldelim();
                if (message.fileOpened != null && Object.hasOwnProperty.call(message, "fileOpened"))
                    $root.api.FileOpened.encode(message.fileOpened, writer.uint32(/* id 264, wireType 2 =*/2114).fork()).ldelim();
                if (message.followUser != null && Object.hasOwnProperty.call(message, "followUser"))
                    $root.api.FollowUser.encode(message.followUser, writer.uint32(/* id 265, wireType 2 =*/2122).fork()).ldelim();
                if (message.updateSessionTimestamp != null && Object.hasOwnProperty.call(message, "updateSessionTimestamp"))
                    $root.api.UpdateSessionTimestamp.encode(message.updateSessionTimestamp, writer.uint32(/* id 266, wireType 2 =*/2130).fork()).ldelim();
                if (message.sessionTimestampUpdated != null && Object.hasOwnProperty.call(message, "sessionTimestampUpdated"))
                    $root.api.SessionTimestampUpdated.encode(message.sessionTimestampUpdated, writer.uint32(/* id 267, wireType 2 =*/2138).fork()).ldelim();
                if (message.unfollowUser != null && Object.hasOwnProperty.call(message, "unfollowUser"))
                    $root.api.UnfollowUser.encode(message.unfollowUser, writer.uint32(/* id 268, wireType 2 =*/2146).fork()).ldelim();
                if (message.exec != null && Object.hasOwnProperty.call(message, "exec"))
                    $root.api.Exec.encode(message.exec, writer.uint32(/* id 270, wireType 2 =*/2162).fork()).ldelim();
                if (message.packageSearch != null && Object.hasOwnProperty.call(message, "packageSearch"))
                    $root.api.PackageSearch.encode(message.packageSearch, writer.uint32(/* id 280, wireType 2 =*/2242).fork()).ldelim();
                if (message.packageSearchResp != null && Object.hasOwnProperty.call(message, "packageSearchResp"))
                    $root.api.PackageSearchResp.encode(message.packageSearchResp, writer.uint32(/* id 281, wireType 2 =*/2250).fork()).ldelim();
                if (message.packageInfo != null && Object.hasOwnProperty.call(message, "packageInfo"))
                    $root.api.PackageInfo.encode(message.packageInfo, writer.uint32(/* id 282, wireType 2 =*/2258).fork()).ldelim();
                if (message.packageInfoResp != null && Object.hasOwnProperty.call(message, "packageInfoResp"))
                    $root.api.PackageInfoResp.encode(message.packageInfoResp, writer.uint32(/* id 283, wireType 2 =*/2266).fork()).ldelim();
                if (message.packageAdd != null && Object.hasOwnProperty.call(message, "packageAdd"))
                    $root.api.PackageAdd.encode(message.packageAdd, writer.uint32(/* id 284, wireType 2 =*/2274).fork()).ldelim();
                if (message.packageRemove != null && Object.hasOwnProperty.call(message, "packageRemove"))
                    $root.api.PackageRemove.encode(message.packageRemove, writer.uint32(/* id 285, wireType 2 =*/2282).fork()).ldelim();
                if (message.packageInstall != null && Object.hasOwnProperty.call(message, "packageInstall"))
                    $root.api.PackageInstall.encode(message.packageInstall, writer.uint32(/* id 286, wireType 2 =*/2290).fork()).ldelim();
                if (message.packageListSpecfile != null && Object.hasOwnProperty.call(message, "packageListSpecfile"))
                    $root.api.PackageListSpecfile.encode(message.packageListSpecfile, writer.uint32(/* id 287, wireType 2 =*/2298).fork()).ldelim();
                if (message.packageListSpecfileResp != null && Object.hasOwnProperty.call(message, "packageListSpecfileResp"))
                    $root.api.PackageListSpecfileResp.encode(message.packageListSpecfileResp, writer.uint32(/* id 288, wireType 2 =*/2306).fork()).ldelim();
                if (message.packageCacheSave != null && Object.hasOwnProperty.call(message, "packageCacheSave"))
                    $root.api.PackageCacheSave.encode(message.packageCacheSave, writer.uint32(/* id 289, wireType 2 =*/2314).fork()).ldelim();
                if (message.chatMessage != null && Object.hasOwnProperty.call(message, "chatMessage"))
                    $root.api.ChatMessage.encode(message.chatMessage, writer.uint32(/* id 310, wireType 2 =*/2482).fork()).ldelim();
                if (message.chatTyping != null && Object.hasOwnProperty.call(message, "chatTyping"))
                    $root.api.ChatTyping.encode(message.chatTyping, writer.uint32(/* id 311, wireType 2 =*/2490).fork()).ldelim();
                if (message.chatScrollback != null && Object.hasOwnProperty.call(message, "chatScrollback"))
                    $root.api.ChatScrollback.encode(message.chatScrollback, writer.uint32(/* id 312, wireType 2 =*/2498).fork()).ldelim();
                if (message.transferStart != null && Object.hasOwnProperty.call(message, "transferStart"))
                    $root.api.TransferStart.encode(message.transferStart, writer.uint32(/* id 320, wireType 2 =*/2562).fork()).ldelim();
                if (message.transferChunk != null && Object.hasOwnProperty.call(message, "transferChunk"))
                    $root.api.TransferChunk.encode(message.transferChunk, writer.uint32(/* id 321, wireType 2 =*/2570).fork()).ldelim();
                if (message.transferComplete != null && Object.hasOwnProperty.call(message, "transferComplete"))
                    $root.api.TransferComplete.encode(message.transferComplete, writer.uint32(/* id 322, wireType 2 =*/2578).fork()).ldelim();
                if (message.transferCancel != null && Object.hasOwnProperty.call(message, "transferCancel"))
                    $root.api.Transfer.encode(message.transferCancel, writer.uint32(/* id 323, wireType 2 =*/2586).fork()).ldelim();
                if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                    $root.api.Transfer.encode(message.transfer, writer.uint32(/* id 324, wireType 2 =*/2594).fork()).ldelim();
                if (message.fsSnapshot != null && Object.hasOwnProperty.call(message, "fsSnapshot"))
                    $root.api.FSSnapshot.encode(message.fsSnapshot, writer.uint32(/* id 330, wireType 2 =*/2642).fork()).ldelim();
                if (message.fsTakeLock != null && Object.hasOwnProperty.call(message, "fsTakeLock"))
                    $root.api.FSLock.encode(message.fsTakeLock, writer.uint32(/* id 331, wireType 2 =*/2650).fork()).ldelim();
                if (message.fsReleaseLock != null && Object.hasOwnProperty.call(message, "fsReleaseLock"))
                    $root.api.FSLock.encode(message.fsReleaseLock, writer.uint32(/* id 332, wireType 2 =*/2658).fork()).ldelim();
                if (message.hasCap != null && Object.hasOwnProperty.call(message, "hasCap"))
                    writer.uint32(/* id 335, wireType 0 =*/2680).bool(message.hasCap);
                if (message.pid1Config != null && Object.hasOwnProperty.call(message, "pid1Config"))
                    $root.api.Pid1Config.encode(message.pid1Config, writer.uint32(/* id 340, wireType 2 =*/2722).fork()).ldelim();
                if (message.metrics != null && Object.hasOwnProperty.call(message, "metrics"))
                    $root.api.Metrics.encode(message.metrics, writer.uint32(/* id 350, wireType 2 =*/2802).fork()).ldelim();
                if (message.bootStatus != null && Object.hasOwnProperty.call(message, "bootStatus"))
                    $root.api.BootStatus.encode(message.bootStatus, writer.uint32(/* id 351, wireType 2 =*/2810).fork()).ldelim();
                if (message.readMeta != null && Object.hasOwnProperty.call(message, "readMeta"))
                    $root.api.ReadMeta.encode(message.readMeta, writer.uint32(/* id 360, wireType 2 =*/2882).fork()).ldelim();
                if (message.writeMeta != null && Object.hasOwnProperty.call(message, "writeMeta"))
                    $root.api.WriteMeta.encode(message.writeMeta, writer.uint32(/* id 361, wireType 2 =*/2890).fork()).ldelim();
                if (message.appendMeta != null && Object.hasOwnProperty.call(message, "appendMeta"))
                    $root.api.AppendMeta.encode(message.appendMeta, writer.uint32(/* id 362, wireType 2 =*/2898).fork()).ldelim();
                if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                    $root.api.Audio.encode(message.audio, writer.uint32(/* id 363, wireType 2 =*/2906).fork()).ldelim();
                if (message.pprofRequest != null && Object.hasOwnProperty.call(message, "pprofRequest"))
                    $root.api.PprofRequest.encode(message.pprofRequest, writer.uint32(/* id 364, wireType 2 =*/2914).fork()).ldelim();
                if (message.pprofResponse != null && Object.hasOwnProperty.call(message, "pprofResponse"))
                    $root.api.PprofResponse.encode(message.pprofResponse, writer.uint32(/* id 365, wireType 2 =*/2922).fork()).ldelim();
                if (message.audio2 != null && Object.hasOwnProperty.call(message, "audio2"))
                    $root.api.Audio2.encode(message.audio2, writer.uint32(/* id 366, wireType 2 =*/2930).fork()).ldelim();
                if (message.PTYConfig != null && Object.hasOwnProperty.call(message, "PTYConfig"))
                    $root.api.PTYConfig.encode(message.PTYConfig, writer.uint32(/* id 367, wireType 2 =*/2938).fork()).ldelim();
                if (message.stat != null && Object.hasOwnProperty.call(message, "stat"))
                    $root.api.File.encode(message.stat, writer.uint32(/* id 368, wireType 2 =*/2946).fork()).ldelim();
                if (message.statRes != null && Object.hasOwnProperty.call(message, "statRes"))
                    $root.api.StatResult.encode(message.statRes, writer.uint32(/* id 369, wireType 2 =*/2954).fork()).ldelim();
                if (message.debugMain != null && Object.hasOwnProperty.call(message, "debugMain"))
                    $root.api.DebugMain.encode(message.debugMain, writer.uint32(/* id 370, wireType 2 =*/2962).fork()).ldelim();
                if (message.debugState != null && Object.hasOwnProperty.call(message, "debugState"))
                    $root.api.DebugState.encode(message.debugState, writer.uint32(/* id 371, wireType 2 =*/2970).fork()).ldelim();
                if (message.debugMainReply != null && Object.hasOwnProperty.call(message, "debugMainReply"))
                    $root.api.DebugMainReply.encode(message.debugMainReply, writer.uint32(/* id 372, wireType 2 =*/2978).fork()).ldelim();
                if (message.debugInput != null && Object.hasOwnProperty.call(message, "debugInput"))
                    $root.api.DebugInput.encode(message.debugInput, writer.uint32(/* id 373, wireType 2 =*/2986).fork()).ldelim();
                if (message.debugOutput != null && Object.hasOwnProperty.call(message, "debugOutput"))
                    $root.api.DebugOutput.encode(message.debugOutput, writer.uint32(/* id 374, wireType 2 =*/2994).fork()).ldelim();
                if (message.debugStop != null && Object.hasOwnProperty.call(message, "debugStop"))
                    $root.api.DebugStop.encode(message.debugStop, writer.uint32(/* id 375, wireType 2 =*/3002).fork()).ldelim();
                if (message.debugLeave != null && Object.hasOwnProperty.call(message, "debugLeave"))
                    $root.api.DebugLeave.encode(message.debugLeave, writer.uint32(/* id 376, wireType 2 =*/3010).fork()).ldelim();
                if (message.debugSessions != null && Object.hasOwnProperty.call(message, "debugSessions"))
                    $root.api.DebugSessions.encode(message.debugSessions, writer.uint32(/* id 377, wireType 2 =*/3018).fork()).ldelim();
                if (message.dotReplitGetRequest != null && Object.hasOwnProperty.call(message, "dotReplitGetRequest"))
                    $root.api.DotReplitGetRequest.encode(message.dotReplitGetRequest, writer.uint32(/* id 378, wireType 2 =*/3026).fork()).ldelim();
                if (message.dotReplitGetResponse != null && Object.hasOwnProperty.call(message, "dotReplitGetResponse"))
                    $root.api.DotReplitGetResponse.encode(message.dotReplitGetResponse, writer.uint32(/* id 379, wireType 2 =*/3034).fork()).ldelim();
                if (message.debugAddBreakpointRequest != null && Object.hasOwnProperty.call(message, "debugAddBreakpointRequest"))
                    $root.api.DebugAddBreakpointRequest.encode(message.debugAddBreakpointRequest, writer.uint32(/* id 380, wireType 2 =*/3042).fork()).ldelim();
                if (message.debugRemoveBreakpointRequest != null && Object.hasOwnProperty.call(message, "debugRemoveBreakpointRequest"))
                    $root.api.DebugRemoveBreakpointRequest.encode(message.debugRemoveBreakpointRequest, writer.uint32(/* id 381, wireType 2 =*/3050).fork()).ldelim();
                if (message.debugBreakpointEvent != null && Object.hasOwnProperty.call(message, "debugBreakpointEvent"))
                    $root.api.DebugBreakpointEvent.encode(message.debugBreakpointEvent, writer.uint32(/* id 383, wireType 2 =*/3066).fork()).ldelim();
                if (message.ref != null && Object.hasOwnProperty.call(message, "ref"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message.ref);
                return writer;
            };
    
            /**
             * Encodes the specified Command message, length delimited. Does not implicitly {@link api.Command.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Command
             * @static
             * @param {api.Command} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Command message from the specified reader or buffer.
             * @function decode
             * @memberof api.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Command();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.int32();
                        break;
                    case 2:
                        message.session = reader.int32();
                        break;
                    case 3:
                        message.openChan = $root.api.OpenChannel.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.openChanRes = $root.api.OpenChannelRes.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.closeChan = $root.api.CloseChannel.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.closeChanRes = $root.api.CloseChannelRes.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.containerState = $root.api.ContainerState.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.portOpen = $root.api.PortOpen.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.toast = $root.api.Toast.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.redirect = $root.api.Redirect.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.alwaysOn = $root.api.AlwaysOn.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.runMain = $root.api.RunMain.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.clear = $root.api.Clear.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message["eval"] = reader.string();
                        break;
                    case 21:
                        message.result = reader.string();
                        break;
                    case 22:
                        message.input = reader.string();
                        break;
                    case 23:
                        message.output = reader.string();
                        break;
                    case 24:
                        message.error = reader.string();
                        break;
                    case 26:
                        message.saneTerm = $root.api.SaneTerm.decode(reader, reader.uint32());
                        break;
                    case 27:
                        message.resizeTerm = $root.api.ResizeTerm.decode(reader, reader.uint32());
                        break;
                    case 28:
                        message.state = reader.int32();
                        break;
                    case 30:
                        message.ok = $root.api.OK.decode(reader, reader.uint32());
                        break;
                    case 31:
                        message.persist = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 41:
                        message.persistMirror = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 32:
                        message.write = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 33:
                        message.remove = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 34:
                        message.move = $root.api.Move.decode(reader, reader.uint32());
                        break;
                    case 36:
                        message.tryRemove = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 39:
                        message.mkdir = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 368:
                        message.stat = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 369:
                        message.statRes = $root.api.StatResult.decode(reader, reader.uint32());
                        break;
                    case 320:
                        message.transferStart = $root.api.TransferStart.decode(reader, reader.uint32());
                        break;
                    case 321:
                        message.transferChunk = $root.api.TransferChunk.decode(reader, reader.uint32());
                        break;
                    case 322:
                        message.transferComplete = $root.api.TransferComplete.decode(reader, reader.uint32());
                        break;
                    case 323:
                        message.transferCancel = $root.api.Transfer.decode(reader, reader.uint32());
                        break;
                    case 324:
                        message.transfer = $root.api.Transfer.decode(reader, reader.uint32());
                        break;
                    case 35:
                        message.read = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 37:
                        message.readdir = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 38:
                        message.files = $root.api.Files.decode(reader, reader.uint32());
                        break;
                    case 40:
                        message.file = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 42:
                        message.checkChanges = $root.api.CheckChanges.decode(reader, reader.uint32());
                        break;
                    case 43:
                        message.changedFiles = $root.api.Files.decode(reader, reader.uint32());
                        break;
                    case 44:
                        message.lintResults = $root.api.LintResults.decode(reader, reader.uint32());
                        break;
                    case 70:
                        message.runContainedTest = $root.api.ContainedTest.decode(reader, reader.uint32());
                        break;
                    case 71:
                        message.testResult = $root.api.TestResult.decode(reader, reader.uint32());
                        break;
                    case 90:
                        message.debuggerStart = reader.string();
                        break;
                    case 91:
                        message.debuggerStep = $root.api.RunMain.decode(reader, reader.uint32());
                        break;
                    case 92:
                        message.debuggerStatus = $root.api.DebugStatus.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.ensurePackages = $root.api.EnsurePackages.decode(reader, reader.uint32());
                        break;
                    case 120:
                        message.ping = $root.api.Ping.decode(reader, reader.uint32());
                        break;
                    case 121:
                        message.pong = $root.api.Pong.decode(reader, reader.uint32());
                        break;
                    case 122:
                        message.hello = $root.api.Hello.decode(reader, reader.uint32());
                        break;
                    case 123:
                        message.goodbye = $root.api.Goodbye.decode(reader, reader.uint32());
                        break;
                    case 130:
                        message.hint = $root.api.Hint.decode(reader, reader.uint32());
                        break;
                    case 150:
                        message.connect = $root.api.Connect.decode(reader, reader.uint32());
                        break;
                    case 151:
                        message.send = $root.api.Send.decode(reader, reader.uint32());
                        break;
                    case 152:
                        message.recv = $root.api.Recv.decode(reader, reader.uint32());
                        break;
                    case 153:
                        message.disconnect = $root.api.Disconnect.decode(reader, reader.uint32());
                        break;
                    case 200:
                        message.fileAuthReq = $root.api.FileAuthReq.decode(reader, reader.uint32());
                        break;
                    case 201:
                        message.fileAuthRes = $root.api.FileAuthRes.decode(reader, reader.uint32());
                        break;
                    case 202:
                        message.mutliFileAuthRes = $root.api.MultiFileAuthRes.decode(reader, reader.uint32());
                        break;
                    case 205:
                        message.listObjects = $root.api.ListObjects.decode(reader, reader.uint32());
                        break;
                    case 206:
                        message.listObjectsResp = $root.api.ListObjectsResp.decode(reader, reader.uint32());
                        break;
                    case 220:
                        message.ot = $root.api.OTPacket.decode(reader, reader.uint32());
                        break;
                    case 221:
                        message.otstatus = $root.api.OTStatus.decode(reader, reader.uint32());
                        break;
                    case 222:
                        message.otLinkFile = $root.api.OTLinkFile.decode(reader, reader.uint32());
                        break;
                    case 223:
                        message.otNewCursor = $root.api.OTCursor.decode(reader, reader.uint32());
                        break;
                    case 224:
                        message.otDeleteCursor = $root.api.OTCursor.decode(reader, reader.uint32());
                        break;
                    case 225:
                        message.otFetchRequest = $root.api.OTFetchRequest.decode(reader, reader.uint32());
                        break;
                    case 226:
                        message.otFetchResponse = $root.api.OTFetchResponse.decode(reader, reader.uint32());
                        break;
                    case 227:
                        message.otTransformSelectionRequest = $root.api.OTTransformSelectionRequest.decode(reader, reader.uint32());
                        break;
                    case 228:
                        message.otTransformSelectionResponse = $root.api.OTTransformSelectionResponse.decode(reader, reader.uint32());
                        break;
                    case 251:
                        message.flush = $root.api.Flush.decode(reader, reader.uint32());
                        break;
                    case 230:
                        message.debug = $root.api.Debug.decode(reader, reader.uint32());
                        break;
                    case 231:
                        message.startVCR = $root.api.StartVCR.decode(reader, reader.uint32());
                        break;
                    case 232:
                        message.readVCR = $root.api.ReadVCR.decode(reader, reader.uint32());
                        break;
                    case 233:
                        message.VCRLog = $root.api.VCRLog.decode(reader, reader.uint32());
                        break;
                    case 235:
                        message.auth = $root.api.Auth.decode(reader, reader.uint32());
                        break;
                    case 240:
                        message.execInfo = $root.api.ExecInfo.decode(reader, reader.uint32());
                        break;
                    case 256:
                        message.subscribeFile = $root.api.SubscribeFile.decode(reader, reader.uint32());
                        break;
                    case 257:
                        message.fileEvent = $root.api.FileEvent.decode(reader, reader.uint32());
                        break;
                    case 260:
                        message.roster = $root.api.Roster.decode(reader, reader.uint32());
                        break;
                    case 261:
                        message.join = $root.api.User.decode(reader, reader.uint32());
                        break;
                    case 262:
                        message.part = $root.api.User.decode(reader, reader.uint32());
                        break;
                    case 263:
                        message.openFile = $root.api.OpenFile.decode(reader, reader.uint32());
                        break;
                    case 264:
                        message.fileOpened = $root.api.FileOpened.decode(reader, reader.uint32());
                        break;
                    case 265:
                        message.followUser = $root.api.FollowUser.decode(reader, reader.uint32());
                        break;
                    case 268:
                        message.unfollowUser = $root.api.UnfollowUser.decode(reader, reader.uint32());
                        break;
                    case 266:
                        message.updateSessionTimestamp = $root.api.UpdateSessionTimestamp.decode(reader, reader.uint32());
                        break;
                    case 267:
                        message.sessionTimestampUpdated = $root.api.SessionTimestampUpdated.decode(reader, reader.uint32());
                        break;
                    case 270:
                        message.exec = $root.api.Exec.decode(reader, reader.uint32());
                        break;
                    case 280:
                        message.packageSearch = $root.api.PackageSearch.decode(reader, reader.uint32());
                        break;
                    case 281:
                        message.packageSearchResp = $root.api.PackageSearchResp.decode(reader, reader.uint32());
                        break;
                    case 282:
                        message.packageInfo = $root.api.PackageInfo.decode(reader, reader.uint32());
                        break;
                    case 283:
                        message.packageInfoResp = $root.api.PackageInfoResp.decode(reader, reader.uint32());
                        break;
                    case 284:
                        message.packageAdd = $root.api.PackageAdd.decode(reader, reader.uint32());
                        break;
                    case 285:
                        message.packageRemove = $root.api.PackageRemove.decode(reader, reader.uint32());
                        break;
                    case 286:
                        message.packageInstall = $root.api.PackageInstall.decode(reader, reader.uint32());
                        break;
                    case 287:
                        message.packageListSpecfile = $root.api.PackageListSpecfile.decode(reader, reader.uint32());
                        break;
                    case 288:
                        message.packageListSpecfileResp = $root.api.PackageListSpecfileResp.decode(reader, reader.uint32());
                        break;
                    case 289:
                        message.packageCacheSave = $root.api.PackageCacheSave.decode(reader, reader.uint32());
                        break;
                    case 310:
                        message.chatMessage = $root.api.ChatMessage.decode(reader, reader.uint32());
                        break;
                    case 311:
                        message.chatTyping = $root.api.ChatTyping.decode(reader, reader.uint32());
                        break;
                    case 312:
                        message.chatScrollback = $root.api.ChatScrollback.decode(reader, reader.uint32());
                        break;
                    case 330:
                        message.fsSnapshot = $root.api.FSSnapshot.decode(reader, reader.uint32());
                        break;
                    case 331:
                        message.fsTakeLock = $root.api.FSLock.decode(reader, reader.uint32());
                        break;
                    case 332:
                        message.fsReleaseLock = $root.api.FSLock.decode(reader, reader.uint32());
                        break;
                    case 335:
                        message.hasCap = reader.bool();
                        break;
                    case 340:
                        message.pid1Config = $root.api.Pid1Config.decode(reader, reader.uint32());
                        break;
                    case 350:
                        message.metrics = $root.api.Metrics.decode(reader, reader.uint32());
                        break;
                    case 351:
                        message.bootStatus = $root.api.BootStatus.decode(reader, reader.uint32());
                        break;
                    case 360:
                        message.readMeta = $root.api.ReadMeta.decode(reader, reader.uint32());
                        break;
                    case 361:
                        message.writeMeta = $root.api.WriteMeta.decode(reader, reader.uint32());
                        break;
                    case 362:
                        message.appendMeta = $root.api.AppendMeta.decode(reader, reader.uint32());
                        break;
                    case 363:
                        message.audio = $root.api.Audio.decode(reader, reader.uint32());
                        break;
                    case 364:
                        message.pprofRequest = $root.api.PprofRequest.decode(reader, reader.uint32());
                        break;
                    case 365:
                        message.pprofResponse = $root.api.PprofResponse.decode(reader, reader.uint32());
                        break;
                    case 366:
                        message.audio2 = $root.api.Audio2.decode(reader, reader.uint32());
                        break;
                    case 367:
                        message.PTYConfig = $root.api.PTYConfig.decode(reader, reader.uint32());
                        break;
                    case 370:
                        message.debugMain = $root.api.DebugMain.decode(reader, reader.uint32());
                        break;
                    case 371:
                        message.debugState = $root.api.DebugState.decode(reader, reader.uint32());
                        break;
                    case 372:
                        message.debugMainReply = $root.api.DebugMainReply.decode(reader, reader.uint32());
                        break;
                    case 373:
                        message.debugInput = $root.api.DebugInput.decode(reader, reader.uint32());
                        break;
                    case 374:
                        message.debugOutput = $root.api.DebugOutput.decode(reader, reader.uint32());
                        break;
                    case 375:
                        message.debugStop = $root.api.DebugStop.decode(reader, reader.uint32());
                        break;
                    case 376:
                        message.debugLeave = $root.api.DebugLeave.decode(reader, reader.uint32());
                        break;
                    case 377:
                        message.debugSessions = $root.api.DebugSessions.decode(reader, reader.uint32());
                        break;
                    case 380:
                        message.debugAddBreakpointRequest = $root.api.DebugAddBreakpointRequest.decode(reader, reader.uint32());
                        break;
                    case 381:
                        message.debugRemoveBreakpointRequest = $root.api.DebugRemoveBreakpointRequest.decode(reader, reader.uint32());
                        break;
                    case 383:
                        message.debugBreakpointEvent = $root.api.DebugBreakpointEvent.decode(reader, reader.uint32());
                        break;
                    case 378:
                        message.dotReplitGetRequest = $root.api.DotReplitGetRequest.decode(reader, reader.uint32());
                        break;
                    case 379:
                        message.dotReplitGetResponse = $root.api.DotReplitGetResponse.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message.ref = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Command message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Command message.
             * @function verify
             * @memberof api.Command
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Command.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isInteger(message.channel))
                        return "channel: integer expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isInteger(message.session))
                        return "session: integer expected";
                if (message.openChan != null && message.hasOwnProperty("openChan")) {
                    properties.body = 1;
                    {
                        var error = $root.api.OpenChannel.verify(message.openChan);
                        if (error)
                            return "openChan." + error;
                    }
                }
                if (message.openChanRes != null && message.hasOwnProperty("openChanRes")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OpenChannelRes.verify(message.openChanRes);
                        if (error)
                            return "openChanRes." + error;
                    }
                }
                if (message.closeChan != null && message.hasOwnProperty("closeChan")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.CloseChannel.verify(message.closeChan);
                        if (error)
                            return "closeChan." + error;
                    }
                }
                if (message.closeChanRes != null && message.hasOwnProperty("closeChanRes")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.CloseChannelRes.verify(message.closeChanRes);
                        if (error)
                            return "closeChanRes." + error;
                    }
                }
                if (message.containerState != null && message.hasOwnProperty("containerState")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ContainerState.verify(message.containerState);
                        if (error)
                            return "containerState." + error;
                    }
                }
                if (message.portOpen != null && message.hasOwnProperty("portOpen")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PortOpen.verify(message.portOpen);
                        if (error)
                            return "portOpen." + error;
                    }
                }
                if (message.toast != null && message.hasOwnProperty("toast")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Toast.verify(message.toast);
                        if (error)
                            return "toast." + error;
                    }
                }
                if (message.redirect != null && message.hasOwnProperty("redirect")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Redirect.verify(message.redirect);
                        if (error)
                            return "redirect." + error;
                    }
                }
                if (message.alwaysOn != null && message.hasOwnProperty("alwaysOn")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.AlwaysOn.verify(message.alwaysOn);
                        if (error)
                            return "alwaysOn." + error;
                    }
                }
                if (message.runMain != null && message.hasOwnProperty("runMain")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.RunMain.verify(message.runMain);
                        if (error)
                            return "runMain." + error;
                    }
                }
                if (message.clear != null && message.hasOwnProperty("clear")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Clear.verify(message.clear);
                        if (error)
                            return "clear." + error;
                    }
                }
                if (message["eval"] != null && message.hasOwnProperty("eval")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    if (!$util.isString(message["eval"]))
                        return "eval: string expected";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    if (!$util.isString(message.result))
                        return "result: string expected";
                }
                if (message.input != null && message.hasOwnProperty("input")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    if (!$util.isString(message.input))
                        return "input: string expected";
                }
                if (message.output != null && message.hasOwnProperty("output")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    if (!$util.isString(message.output))
                        return "output: string expected";
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    if (!$util.isString(message.error))
                        return "error: string expected";
                }
                if (message.saneTerm != null && message.hasOwnProperty("saneTerm")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.SaneTerm.verify(message.saneTerm);
                        if (error)
                            return "saneTerm." + error;
                    }
                }
                if (message.resizeTerm != null && message.hasOwnProperty("resizeTerm")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ResizeTerm.verify(message.resizeTerm);
                        if (error)
                            return "resizeTerm." + error;
                    }
                }
                if (message.state != null && message.hasOwnProperty("state")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                }
                if (message.ok != null && message.hasOwnProperty("ok")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OK.verify(message.ok);
                        if (error)
                            return "ok." + error;
                    }
                }
                if (message.persist != null && message.hasOwnProperty("persist")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.persist);
                        if (error)
                            return "persist." + error;
                    }
                }
                if (message.persistMirror != null && message.hasOwnProperty("persistMirror")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.persistMirror);
                        if (error)
                            return "persistMirror." + error;
                    }
                }
                if (message.write != null && message.hasOwnProperty("write")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.write);
                        if (error)
                            return "write." + error;
                    }
                }
                if (message.remove != null && message.hasOwnProperty("remove")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.remove);
                        if (error)
                            return "remove." + error;
                    }
                }
                if (message.move != null && message.hasOwnProperty("move")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Move.verify(message.move);
                        if (error)
                            return "move." + error;
                    }
                }
                if (message.tryRemove != null && message.hasOwnProperty("tryRemove")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.tryRemove);
                        if (error)
                            return "tryRemove." + error;
                    }
                }
                if (message.mkdir != null && message.hasOwnProperty("mkdir")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.mkdir);
                        if (error)
                            return "mkdir." + error;
                    }
                }
                if (message.stat != null && message.hasOwnProperty("stat")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.stat);
                        if (error)
                            return "stat." + error;
                    }
                }
                if (message.statRes != null && message.hasOwnProperty("statRes")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.StatResult.verify(message.statRes);
                        if (error)
                            return "statRes." + error;
                    }
                }
                if (message.transferStart != null && message.hasOwnProperty("transferStart")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.TransferStart.verify(message.transferStart);
                        if (error)
                            return "transferStart." + error;
                    }
                }
                if (message.transferChunk != null && message.hasOwnProperty("transferChunk")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.TransferChunk.verify(message.transferChunk);
                        if (error)
                            return "transferChunk." + error;
                    }
                }
                if (message.transferComplete != null && message.hasOwnProperty("transferComplete")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.TransferComplete.verify(message.transferComplete);
                        if (error)
                            return "transferComplete." + error;
                    }
                }
                if (message.transferCancel != null && message.hasOwnProperty("transferCancel")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Transfer.verify(message.transferCancel);
                        if (error)
                            return "transferCancel." + error;
                    }
                }
                if (message.transfer != null && message.hasOwnProperty("transfer")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Transfer.verify(message.transfer);
                        if (error)
                            return "transfer." + error;
                    }
                }
                if (message.read != null && message.hasOwnProperty("read")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.read);
                        if (error)
                            return "read." + error;
                    }
                }
                if (message.readdir != null && message.hasOwnProperty("readdir")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.readdir);
                        if (error)
                            return "readdir." + error;
                    }
                }
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Files.verify(message.files);
                        if (error)
                            return "files." + error;
                    }
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.File.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                }
                if (message.checkChanges != null && message.hasOwnProperty("checkChanges")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.CheckChanges.verify(message.checkChanges);
                        if (error)
                            return "checkChanges." + error;
                    }
                }
                if (message.changedFiles != null && message.hasOwnProperty("changedFiles")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Files.verify(message.changedFiles);
                        if (error)
                            return "changedFiles." + error;
                    }
                }
                if (message.lintResults != null && message.hasOwnProperty("lintResults")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.LintResults.verify(message.lintResults);
                        if (error)
                            return "lintResults." + error;
                    }
                }
                if (message.runContainedTest != null && message.hasOwnProperty("runContainedTest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ContainedTest.verify(message.runContainedTest);
                        if (error)
                            return "runContainedTest." + error;
                    }
                }
                if (message.testResult != null && message.hasOwnProperty("testResult")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.TestResult.verify(message.testResult);
                        if (error)
                            return "testResult." + error;
                    }
                }
                if (message.debuggerStart != null && message.hasOwnProperty("debuggerStart")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    if (!$util.isString(message.debuggerStart))
                        return "debuggerStart: string expected";
                }
                if (message.debuggerStep != null && message.hasOwnProperty("debuggerStep")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.RunMain.verify(message.debuggerStep);
                        if (error)
                            return "debuggerStep." + error;
                    }
                }
                if (message.debuggerStatus != null && message.hasOwnProperty("debuggerStatus")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugStatus.verify(message.debuggerStatus);
                        if (error)
                            return "debuggerStatus." + error;
                    }
                }
                if (message.ensurePackages != null && message.hasOwnProperty("ensurePackages")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.EnsurePackages.verify(message.ensurePackages);
                        if (error)
                            return "ensurePackages." + error;
                    }
                }
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Ping.verify(message.ping);
                        if (error)
                            return "ping." + error;
                    }
                }
                if (message.pong != null && message.hasOwnProperty("pong")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Pong.verify(message.pong);
                        if (error)
                            return "pong." + error;
                    }
                }
                if (message.hello != null && message.hasOwnProperty("hello")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Hello.verify(message.hello);
                        if (error)
                            return "hello." + error;
                    }
                }
                if (message.goodbye != null && message.hasOwnProperty("goodbye")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Goodbye.verify(message.goodbye);
                        if (error)
                            return "goodbye." + error;
                    }
                }
                if (message.hint != null && message.hasOwnProperty("hint")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Hint.verify(message.hint);
                        if (error)
                            return "hint." + error;
                    }
                }
                if (message.connect != null && message.hasOwnProperty("connect")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Connect.verify(message.connect);
                        if (error)
                            return "connect." + error;
                    }
                }
                if (message.send != null && message.hasOwnProperty("send")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Send.verify(message.send);
                        if (error)
                            return "send." + error;
                    }
                }
                if (message.recv != null && message.hasOwnProperty("recv")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Recv.verify(message.recv);
                        if (error)
                            return "recv." + error;
                    }
                }
                if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Disconnect.verify(message.disconnect);
                        if (error)
                            return "disconnect." + error;
                    }
                }
                if (message.fileAuthReq != null && message.hasOwnProperty("fileAuthReq")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FileAuthReq.verify(message.fileAuthReq);
                        if (error)
                            return "fileAuthReq." + error;
                    }
                }
                if (message.fileAuthRes != null && message.hasOwnProperty("fileAuthRes")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FileAuthRes.verify(message.fileAuthRes);
                        if (error)
                            return "fileAuthRes." + error;
                    }
                }
                if (message.mutliFileAuthRes != null && message.hasOwnProperty("mutliFileAuthRes")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.MultiFileAuthRes.verify(message.mutliFileAuthRes);
                        if (error)
                            return "mutliFileAuthRes." + error;
                    }
                }
                if (message.listObjects != null && message.hasOwnProperty("listObjects")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ListObjects.verify(message.listObjects);
                        if (error)
                            return "listObjects." + error;
                    }
                }
                if (message.listObjectsResp != null && message.hasOwnProperty("listObjectsResp")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ListObjectsResp.verify(message.listObjectsResp);
                        if (error)
                            return "listObjectsResp." + error;
                    }
                }
                if (message.ot != null && message.hasOwnProperty("ot")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTPacket.verify(message.ot);
                        if (error)
                            return "ot." + error;
                    }
                }
                if (message.otstatus != null && message.hasOwnProperty("otstatus")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTStatus.verify(message.otstatus);
                        if (error)
                            return "otstatus." + error;
                    }
                }
                if (message.otLinkFile != null && message.hasOwnProperty("otLinkFile")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTLinkFile.verify(message.otLinkFile);
                        if (error)
                            return "otLinkFile." + error;
                    }
                }
                if (message.otNewCursor != null && message.hasOwnProperty("otNewCursor")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTCursor.verify(message.otNewCursor);
                        if (error)
                            return "otNewCursor." + error;
                    }
                }
                if (message.otDeleteCursor != null && message.hasOwnProperty("otDeleteCursor")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTCursor.verify(message.otDeleteCursor);
                        if (error)
                            return "otDeleteCursor." + error;
                    }
                }
                if (message.otFetchRequest != null && message.hasOwnProperty("otFetchRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTFetchRequest.verify(message.otFetchRequest);
                        if (error)
                            return "otFetchRequest." + error;
                    }
                }
                if (message.otFetchResponse != null && message.hasOwnProperty("otFetchResponse")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTFetchResponse.verify(message.otFetchResponse);
                        if (error)
                            return "otFetchResponse." + error;
                    }
                }
                if (message.otTransformSelectionRequest != null && message.hasOwnProperty("otTransformSelectionRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTTransformSelectionRequest.verify(message.otTransformSelectionRequest);
                        if (error)
                            return "otTransformSelectionRequest." + error;
                    }
                }
                if (message.otTransformSelectionResponse != null && message.hasOwnProperty("otTransformSelectionResponse")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OTTransformSelectionResponse.verify(message.otTransformSelectionResponse);
                        if (error)
                            return "otTransformSelectionResponse." + error;
                    }
                }
                if (message.flush != null && message.hasOwnProperty("flush")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Flush.verify(message.flush);
                        if (error)
                            return "flush." + error;
                    }
                }
                if (message.debug != null && message.hasOwnProperty("debug")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Debug.verify(message.debug);
                        if (error)
                            return "debug." + error;
                    }
                }
                if (message.startVCR != null && message.hasOwnProperty("startVCR")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.StartVCR.verify(message.startVCR);
                        if (error)
                            return "startVCR." + error;
                    }
                }
                if (message.readVCR != null && message.hasOwnProperty("readVCR")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ReadVCR.verify(message.readVCR);
                        if (error)
                            return "readVCR." + error;
                    }
                }
                if (message.VCRLog != null && message.hasOwnProperty("VCRLog")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.VCRLog.verify(message.VCRLog);
                        if (error)
                            return "VCRLog." + error;
                    }
                }
                if (message.auth != null && message.hasOwnProperty("auth")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Auth.verify(message.auth);
                        if (error)
                            return "auth." + error;
                    }
                }
                if (message.execInfo != null && message.hasOwnProperty("execInfo")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ExecInfo.verify(message.execInfo);
                        if (error)
                            return "execInfo." + error;
                    }
                }
                if (message.subscribeFile != null && message.hasOwnProperty("subscribeFile")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.SubscribeFile.verify(message.subscribeFile);
                        if (error)
                            return "subscribeFile." + error;
                    }
                }
                if (message.fileEvent != null && message.hasOwnProperty("fileEvent")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FileEvent.verify(message.fileEvent);
                        if (error)
                            return "fileEvent." + error;
                    }
                }
                if (message.roster != null && message.hasOwnProperty("roster")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Roster.verify(message.roster);
                        if (error)
                            return "roster." + error;
                    }
                }
                if (message.join != null && message.hasOwnProperty("join")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.User.verify(message.join);
                        if (error)
                            return "join." + error;
                    }
                }
                if (message.part != null && message.hasOwnProperty("part")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.User.verify(message.part);
                        if (error)
                            return "part." + error;
                    }
                }
                if (message.openFile != null && message.hasOwnProperty("openFile")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.OpenFile.verify(message.openFile);
                        if (error)
                            return "openFile." + error;
                    }
                }
                if (message.fileOpened != null && message.hasOwnProperty("fileOpened")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FileOpened.verify(message.fileOpened);
                        if (error)
                            return "fileOpened." + error;
                    }
                }
                if (message.followUser != null && message.hasOwnProperty("followUser")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FollowUser.verify(message.followUser);
                        if (error)
                            return "followUser." + error;
                    }
                }
                if (message.unfollowUser != null && message.hasOwnProperty("unfollowUser")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.UnfollowUser.verify(message.unfollowUser);
                        if (error)
                            return "unfollowUser." + error;
                    }
                }
                if (message.updateSessionTimestamp != null && message.hasOwnProperty("updateSessionTimestamp")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.UpdateSessionTimestamp.verify(message.updateSessionTimestamp);
                        if (error)
                            return "updateSessionTimestamp." + error;
                    }
                }
                if (message.sessionTimestampUpdated != null && message.hasOwnProperty("sessionTimestampUpdated")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.SessionTimestampUpdated.verify(message.sessionTimestampUpdated);
                        if (error)
                            return "sessionTimestampUpdated." + error;
                    }
                }
                if (message.exec != null && message.hasOwnProperty("exec")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Exec.verify(message.exec);
                        if (error)
                            return "exec." + error;
                    }
                }
                if (message.packageSearch != null && message.hasOwnProperty("packageSearch")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageSearch.verify(message.packageSearch);
                        if (error)
                            return "packageSearch." + error;
                    }
                }
                if (message.packageSearchResp != null && message.hasOwnProperty("packageSearchResp")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageSearchResp.verify(message.packageSearchResp);
                        if (error)
                            return "packageSearchResp." + error;
                    }
                }
                if (message.packageInfo != null && message.hasOwnProperty("packageInfo")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageInfo.verify(message.packageInfo);
                        if (error)
                            return "packageInfo." + error;
                    }
                }
                if (message.packageInfoResp != null && message.hasOwnProperty("packageInfoResp")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageInfoResp.verify(message.packageInfoResp);
                        if (error)
                            return "packageInfoResp." + error;
                    }
                }
                if (message.packageAdd != null && message.hasOwnProperty("packageAdd")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageAdd.verify(message.packageAdd);
                        if (error)
                            return "packageAdd." + error;
                    }
                }
                if (message.packageRemove != null && message.hasOwnProperty("packageRemove")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageRemove.verify(message.packageRemove);
                        if (error)
                            return "packageRemove." + error;
                    }
                }
                if (message.packageInstall != null && message.hasOwnProperty("packageInstall")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageInstall.verify(message.packageInstall);
                        if (error)
                            return "packageInstall." + error;
                    }
                }
                if (message.packageListSpecfile != null && message.hasOwnProperty("packageListSpecfile")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageListSpecfile.verify(message.packageListSpecfile);
                        if (error)
                            return "packageListSpecfile." + error;
                    }
                }
                if (message.packageListSpecfileResp != null && message.hasOwnProperty("packageListSpecfileResp")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageListSpecfileResp.verify(message.packageListSpecfileResp);
                        if (error)
                            return "packageListSpecfileResp." + error;
                    }
                }
                if (message.packageCacheSave != null && message.hasOwnProperty("packageCacheSave")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PackageCacheSave.verify(message.packageCacheSave);
                        if (error)
                            return "packageCacheSave." + error;
                    }
                }
                if (message.chatMessage != null && message.hasOwnProperty("chatMessage")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ChatMessage.verify(message.chatMessage);
                        if (error)
                            return "chatMessage." + error;
                    }
                }
                if (message.chatTyping != null && message.hasOwnProperty("chatTyping")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ChatTyping.verify(message.chatTyping);
                        if (error)
                            return "chatTyping." + error;
                    }
                }
                if (message.chatScrollback != null && message.hasOwnProperty("chatScrollback")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ChatScrollback.verify(message.chatScrollback);
                        if (error)
                            return "chatScrollback." + error;
                    }
                }
                if (message.fsSnapshot != null && message.hasOwnProperty("fsSnapshot")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FSSnapshot.verify(message.fsSnapshot);
                        if (error)
                            return "fsSnapshot." + error;
                    }
                }
                if (message.fsTakeLock != null && message.hasOwnProperty("fsTakeLock")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FSLock.verify(message.fsTakeLock);
                        if (error)
                            return "fsTakeLock." + error;
                    }
                }
                if (message.fsReleaseLock != null && message.hasOwnProperty("fsReleaseLock")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.FSLock.verify(message.fsReleaseLock);
                        if (error)
                            return "fsReleaseLock." + error;
                    }
                }
                if (message.hasCap != null && message.hasOwnProperty("hasCap")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    if (typeof message.hasCap !== "boolean")
                        return "hasCap: boolean expected";
                }
                if (message.pid1Config != null && message.hasOwnProperty("pid1Config")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Pid1Config.verify(message.pid1Config);
                        if (error)
                            return "pid1Config." + error;
                    }
                }
                if (message.metrics != null && message.hasOwnProperty("metrics")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Metrics.verify(message.metrics);
                        if (error)
                            return "metrics." + error;
                    }
                }
                if (message.bootStatus != null && message.hasOwnProperty("bootStatus")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.BootStatus.verify(message.bootStatus);
                        if (error)
                            return "bootStatus." + error;
                    }
                }
                if (message.readMeta != null && message.hasOwnProperty("readMeta")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.ReadMeta.verify(message.readMeta);
                        if (error)
                            return "readMeta." + error;
                    }
                }
                if (message.writeMeta != null && message.hasOwnProperty("writeMeta")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.WriteMeta.verify(message.writeMeta);
                        if (error)
                            return "writeMeta." + error;
                    }
                }
                if (message.appendMeta != null && message.hasOwnProperty("appendMeta")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.AppendMeta.verify(message.appendMeta);
                        if (error)
                            return "appendMeta." + error;
                    }
                }
                if (message.audio != null && message.hasOwnProperty("audio")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Audio.verify(message.audio);
                        if (error)
                            return "audio." + error;
                    }
                }
                if (message.pprofRequest != null && message.hasOwnProperty("pprofRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PprofRequest.verify(message.pprofRequest);
                        if (error)
                            return "pprofRequest." + error;
                    }
                }
                if (message.pprofResponse != null && message.hasOwnProperty("pprofResponse")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PprofResponse.verify(message.pprofResponse);
                        if (error)
                            return "pprofResponse." + error;
                    }
                }
                if (message.audio2 != null && message.hasOwnProperty("audio2")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.Audio2.verify(message.audio2);
                        if (error)
                            return "audio2." + error;
                    }
                }
                if (message.PTYConfig != null && message.hasOwnProperty("PTYConfig")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PTYConfig.verify(message.PTYConfig);
                        if (error)
                            return "PTYConfig." + error;
                    }
                }
                if (message.debugMain != null && message.hasOwnProperty("debugMain")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugMain.verify(message.debugMain);
                        if (error)
                            return "debugMain." + error;
                    }
                }
                if (message.debugState != null && message.hasOwnProperty("debugState")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugState.verify(message.debugState);
                        if (error)
                            return "debugState." + error;
                    }
                }
                if (message.debugMainReply != null && message.hasOwnProperty("debugMainReply")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugMainReply.verify(message.debugMainReply);
                        if (error)
                            return "debugMainReply." + error;
                    }
                }
                if (message.debugInput != null && message.hasOwnProperty("debugInput")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugInput.verify(message.debugInput);
                        if (error)
                            return "debugInput." + error;
                    }
                }
                if (message.debugOutput != null && message.hasOwnProperty("debugOutput")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugOutput.verify(message.debugOutput);
                        if (error)
                            return "debugOutput." + error;
                    }
                }
                if (message.debugStop != null && message.hasOwnProperty("debugStop")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugStop.verify(message.debugStop);
                        if (error)
                            return "debugStop." + error;
                    }
                }
                if (message.debugLeave != null && message.hasOwnProperty("debugLeave")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugLeave.verify(message.debugLeave);
                        if (error)
                            return "debugLeave." + error;
                    }
                }
                if (message.debugSessions != null && message.hasOwnProperty("debugSessions")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugSessions.verify(message.debugSessions);
                        if (error)
                            return "debugSessions." + error;
                    }
                }
                if (message.debugAddBreakpointRequest != null && message.hasOwnProperty("debugAddBreakpointRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugAddBreakpointRequest.verify(message.debugAddBreakpointRequest);
                        if (error)
                            return "debugAddBreakpointRequest." + error;
                    }
                }
                if (message.debugRemoveBreakpointRequest != null && message.hasOwnProperty("debugRemoveBreakpointRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugRemoveBreakpointRequest.verify(message.debugRemoveBreakpointRequest);
                        if (error)
                            return "debugRemoveBreakpointRequest." + error;
                    }
                }
                if (message.debugBreakpointEvent != null && message.hasOwnProperty("debugBreakpointEvent")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DebugBreakpointEvent.verify(message.debugBreakpointEvent);
                        if (error)
                            return "debugBreakpointEvent." + error;
                    }
                }
                if (message.dotReplitGetRequest != null && message.hasOwnProperty("dotReplitGetRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DotReplitGetRequest.verify(message.dotReplitGetRequest);
                        if (error)
                            return "dotReplitGetRequest." + error;
                    }
                }
                if (message.dotReplitGetResponse != null && message.hasOwnProperty("dotReplitGetResponse")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.DotReplitGetResponse.verify(message.dotReplitGetResponse);
                        if (error)
                            return "dotReplitGetResponse." + error;
                    }
                }
                if (message.ref != null && message.hasOwnProperty("ref"))
                    if (!$util.isString(message.ref))
                        return "ref: string expected";
                return null;
            };
    
            /**
             * Creates a Command message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Command
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Command} Command
             */
            Command.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Command)
                    return object;
                var message = new $root.api.Command();
                if (object.channel != null)
                    message.channel = object.channel | 0;
                if (object.session != null)
                    message.session = object.session | 0;
                if (object.openChan != null) {
                    if (typeof object.openChan !== "object")
                        throw TypeError(".api.Command.openChan: object expected");
                    message.openChan = $root.api.OpenChannel.fromObject(object.openChan);
                }
                if (object.openChanRes != null) {
                    if (typeof object.openChanRes !== "object")
                        throw TypeError(".api.Command.openChanRes: object expected");
                    message.openChanRes = $root.api.OpenChannelRes.fromObject(object.openChanRes);
                }
                if (object.closeChan != null) {
                    if (typeof object.closeChan !== "object")
                        throw TypeError(".api.Command.closeChan: object expected");
                    message.closeChan = $root.api.CloseChannel.fromObject(object.closeChan);
                }
                if (object.closeChanRes != null) {
                    if (typeof object.closeChanRes !== "object")
                        throw TypeError(".api.Command.closeChanRes: object expected");
                    message.closeChanRes = $root.api.CloseChannelRes.fromObject(object.closeChanRes);
                }
                if (object.containerState != null) {
                    if (typeof object.containerState !== "object")
                        throw TypeError(".api.Command.containerState: object expected");
                    message.containerState = $root.api.ContainerState.fromObject(object.containerState);
                }
                if (object.portOpen != null) {
                    if (typeof object.portOpen !== "object")
                        throw TypeError(".api.Command.portOpen: object expected");
                    message.portOpen = $root.api.PortOpen.fromObject(object.portOpen);
                }
                if (object.toast != null) {
                    if (typeof object.toast !== "object")
                        throw TypeError(".api.Command.toast: object expected");
                    message.toast = $root.api.Toast.fromObject(object.toast);
                }
                if (object.redirect != null) {
                    if (typeof object.redirect !== "object")
                        throw TypeError(".api.Command.redirect: object expected");
                    message.redirect = $root.api.Redirect.fromObject(object.redirect);
                }
                if (object.alwaysOn != null) {
                    if (typeof object.alwaysOn !== "object")
                        throw TypeError(".api.Command.alwaysOn: object expected");
                    message.alwaysOn = $root.api.AlwaysOn.fromObject(object.alwaysOn);
                }
                if (object.runMain != null) {
                    if (typeof object.runMain !== "object")
                        throw TypeError(".api.Command.runMain: object expected");
                    message.runMain = $root.api.RunMain.fromObject(object.runMain);
                }
                if (object.clear != null) {
                    if (typeof object.clear !== "object")
                        throw TypeError(".api.Command.clear: object expected");
                    message.clear = $root.api.Clear.fromObject(object.clear);
                }
                if (object["eval"] != null)
                    message["eval"] = String(object["eval"]);
                if (object.result != null)
                    message.result = String(object.result);
                if (object.input != null)
                    message.input = String(object.input);
                if (object.output != null)
                    message.output = String(object.output);
                if (object.error != null)
                    message.error = String(object.error);
                if (object.saneTerm != null) {
                    if (typeof object.saneTerm !== "object")
                        throw TypeError(".api.Command.saneTerm: object expected");
                    message.saneTerm = $root.api.SaneTerm.fromObject(object.saneTerm);
                }
                if (object.resizeTerm != null) {
                    if (typeof object.resizeTerm !== "object")
                        throw TypeError(".api.Command.resizeTerm: object expected");
                    message.resizeTerm = $root.api.ResizeTerm.fromObject(object.resizeTerm);
                }
                switch (object.state) {
                case "Stopped":
                case 0:
                    message.state = 0;
                    break;
                case "Running":
                case 1:
                    message.state = 1;
                    break;
                }
                if (object.ok != null) {
                    if (typeof object.ok !== "object")
                        throw TypeError(".api.Command.ok: object expected");
                    message.ok = $root.api.OK.fromObject(object.ok);
                }
                if (object.persist != null) {
                    if (typeof object.persist !== "object")
                        throw TypeError(".api.Command.persist: object expected");
                    message.persist = $root.api.File.fromObject(object.persist);
                }
                if (object.persistMirror != null) {
                    if (typeof object.persistMirror !== "object")
                        throw TypeError(".api.Command.persistMirror: object expected");
                    message.persistMirror = $root.api.File.fromObject(object.persistMirror);
                }
                if (object.write != null) {
                    if (typeof object.write !== "object")
                        throw TypeError(".api.Command.write: object expected");
                    message.write = $root.api.File.fromObject(object.write);
                }
                if (object.remove != null) {
                    if (typeof object.remove !== "object")
                        throw TypeError(".api.Command.remove: object expected");
                    message.remove = $root.api.File.fromObject(object.remove);
                }
                if (object.move != null) {
                    if (typeof object.move !== "object")
                        throw TypeError(".api.Command.move: object expected");
                    message.move = $root.api.Move.fromObject(object.move);
                }
                if (object.tryRemove != null) {
                    if (typeof object.tryRemove !== "object")
                        throw TypeError(".api.Command.tryRemove: object expected");
                    message.tryRemove = $root.api.File.fromObject(object.tryRemove);
                }
                if (object.mkdir != null) {
                    if (typeof object.mkdir !== "object")
                        throw TypeError(".api.Command.mkdir: object expected");
                    message.mkdir = $root.api.File.fromObject(object.mkdir);
                }
                if (object.stat != null) {
                    if (typeof object.stat !== "object")
                        throw TypeError(".api.Command.stat: object expected");
                    message.stat = $root.api.File.fromObject(object.stat);
                }
                if (object.statRes != null) {
                    if (typeof object.statRes !== "object")
                        throw TypeError(".api.Command.statRes: object expected");
                    message.statRes = $root.api.StatResult.fromObject(object.statRes);
                }
                if (object.transferStart != null) {
                    if (typeof object.transferStart !== "object")
                        throw TypeError(".api.Command.transferStart: object expected");
                    message.transferStart = $root.api.TransferStart.fromObject(object.transferStart);
                }
                if (object.transferChunk != null) {
                    if (typeof object.transferChunk !== "object")
                        throw TypeError(".api.Command.transferChunk: object expected");
                    message.transferChunk = $root.api.TransferChunk.fromObject(object.transferChunk);
                }
                if (object.transferComplete != null) {
                    if (typeof object.transferComplete !== "object")
                        throw TypeError(".api.Command.transferComplete: object expected");
                    message.transferComplete = $root.api.TransferComplete.fromObject(object.transferComplete);
                }
                if (object.transferCancel != null) {
                    if (typeof object.transferCancel !== "object")
                        throw TypeError(".api.Command.transferCancel: object expected");
                    message.transferCancel = $root.api.Transfer.fromObject(object.transferCancel);
                }
                if (object.transfer != null) {
                    if (typeof object.transfer !== "object")
                        throw TypeError(".api.Command.transfer: object expected");
                    message.transfer = $root.api.Transfer.fromObject(object.transfer);
                }
                if (object.read != null) {
                    if (typeof object.read !== "object")
                        throw TypeError(".api.Command.read: object expected");
                    message.read = $root.api.File.fromObject(object.read);
                }
                if (object.readdir != null) {
                    if (typeof object.readdir !== "object")
                        throw TypeError(".api.Command.readdir: object expected");
                    message.readdir = $root.api.File.fromObject(object.readdir);
                }
                if (object.files != null) {
                    if (typeof object.files !== "object")
                        throw TypeError(".api.Command.files: object expected");
                    message.files = $root.api.Files.fromObject(object.files);
                }
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".api.Command.file: object expected");
                    message.file = $root.api.File.fromObject(object.file);
                }
                if (object.checkChanges != null) {
                    if (typeof object.checkChanges !== "object")
                        throw TypeError(".api.Command.checkChanges: object expected");
                    message.checkChanges = $root.api.CheckChanges.fromObject(object.checkChanges);
                }
                if (object.changedFiles != null) {
                    if (typeof object.changedFiles !== "object")
                        throw TypeError(".api.Command.changedFiles: object expected");
                    message.changedFiles = $root.api.Files.fromObject(object.changedFiles);
                }
                if (object.lintResults != null) {
                    if (typeof object.lintResults !== "object")
                        throw TypeError(".api.Command.lintResults: object expected");
                    message.lintResults = $root.api.LintResults.fromObject(object.lintResults);
                }
                if (object.runContainedTest != null) {
                    if (typeof object.runContainedTest !== "object")
                        throw TypeError(".api.Command.runContainedTest: object expected");
                    message.runContainedTest = $root.api.ContainedTest.fromObject(object.runContainedTest);
                }
                if (object.testResult != null) {
                    if (typeof object.testResult !== "object")
                        throw TypeError(".api.Command.testResult: object expected");
                    message.testResult = $root.api.TestResult.fromObject(object.testResult);
                }
                if (object.debuggerStart != null)
                    message.debuggerStart = String(object.debuggerStart);
                if (object.debuggerStep != null) {
                    if (typeof object.debuggerStep !== "object")
                        throw TypeError(".api.Command.debuggerStep: object expected");
                    message.debuggerStep = $root.api.RunMain.fromObject(object.debuggerStep);
                }
                if (object.debuggerStatus != null) {
                    if (typeof object.debuggerStatus !== "object")
                        throw TypeError(".api.Command.debuggerStatus: object expected");
                    message.debuggerStatus = $root.api.DebugStatus.fromObject(object.debuggerStatus);
                }
                if (object.ensurePackages != null) {
                    if (typeof object.ensurePackages !== "object")
                        throw TypeError(".api.Command.ensurePackages: object expected");
                    message.ensurePackages = $root.api.EnsurePackages.fromObject(object.ensurePackages);
                }
                if (object.ping != null) {
                    if (typeof object.ping !== "object")
                        throw TypeError(".api.Command.ping: object expected");
                    message.ping = $root.api.Ping.fromObject(object.ping);
                }
                if (object.pong != null) {
                    if (typeof object.pong !== "object")
                        throw TypeError(".api.Command.pong: object expected");
                    message.pong = $root.api.Pong.fromObject(object.pong);
                }
                if (object.hello != null) {
                    if (typeof object.hello !== "object")
                        throw TypeError(".api.Command.hello: object expected");
                    message.hello = $root.api.Hello.fromObject(object.hello);
                }
                if (object.goodbye != null) {
                    if (typeof object.goodbye !== "object")
                        throw TypeError(".api.Command.goodbye: object expected");
                    message.goodbye = $root.api.Goodbye.fromObject(object.goodbye);
                }
                if (object.hint != null) {
                    if (typeof object.hint !== "object")
                        throw TypeError(".api.Command.hint: object expected");
                    message.hint = $root.api.Hint.fromObject(object.hint);
                }
                if (object.connect != null) {
                    if (typeof object.connect !== "object")
                        throw TypeError(".api.Command.connect: object expected");
                    message.connect = $root.api.Connect.fromObject(object.connect);
                }
                if (object.send != null) {
                    if (typeof object.send !== "object")
                        throw TypeError(".api.Command.send: object expected");
                    message.send = $root.api.Send.fromObject(object.send);
                }
                if (object.recv != null) {
                    if (typeof object.recv !== "object")
                        throw TypeError(".api.Command.recv: object expected");
                    message.recv = $root.api.Recv.fromObject(object.recv);
                }
                if (object.disconnect != null) {
                    if (typeof object.disconnect !== "object")
                        throw TypeError(".api.Command.disconnect: object expected");
                    message.disconnect = $root.api.Disconnect.fromObject(object.disconnect);
                }
                if (object.fileAuthReq != null) {
                    if (typeof object.fileAuthReq !== "object")
                        throw TypeError(".api.Command.fileAuthReq: object expected");
                    message.fileAuthReq = $root.api.FileAuthReq.fromObject(object.fileAuthReq);
                }
                if (object.fileAuthRes != null) {
                    if (typeof object.fileAuthRes !== "object")
                        throw TypeError(".api.Command.fileAuthRes: object expected");
                    message.fileAuthRes = $root.api.FileAuthRes.fromObject(object.fileAuthRes);
                }
                if (object.mutliFileAuthRes != null) {
                    if (typeof object.mutliFileAuthRes !== "object")
                        throw TypeError(".api.Command.mutliFileAuthRes: object expected");
                    message.mutliFileAuthRes = $root.api.MultiFileAuthRes.fromObject(object.mutliFileAuthRes);
                }
                if (object.listObjects != null) {
                    if (typeof object.listObjects !== "object")
                        throw TypeError(".api.Command.listObjects: object expected");
                    message.listObjects = $root.api.ListObjects.fromObject(object.listObjects);
                }
                if (object.listObjectsResp != null) {
                    if (typeof object.listObjectsResp !== "object")
                        throw TypeError(".api.Command.listObjectsResp: object expected");
                    message.listObjectsResp = $root.api.ListObjectsResp.fromObject(object.listObjectsResp);
                }
                if (object.ot != null) {
                    if (typeof object.ot !== "object")
                        throw TypeError(".api.Command.ot: object expected");
                    message.ot = $root.api.OTPacket.fromObject(object.ot);
                }
                if (object.otstatus != null) {
                    if (typeof object.otstatus !== "object")
                        throw TypeError(".api.Command.otstatus: object expected");
                    message.otstatus = $root.api.OTStatus.fromObject(object.otstatus);
                }
                if (object.otLinkFile != null) {
                    if (typeof object.otLinkFile !== "object")
                        throw TypeError(".api.Command.otLinkFile: object expected");
                    message.otLinkFile = $root.api.OTLinkFile.fromObject(object.otLinkFile);
                }
                if (object.otNewCursor != null) {
                    if (typeof object.otNewCursor !== "object")
                        throw TypeError(".api.Command.otNewCursor: object expected");
                    message.otNewCursor = $root.api.OTCursor.fromObject(object.otNewCursor);
                }
                if (object.otDeleteCursor != null) {
                    if (typeof object.otDeleteCursor !== "object")
                        throw TypeError(".api.Command.otDeleteCursor: object expected");
                    message.otDeleteCursor = $root.api.OTCursor.fromObject(object.otDeleteCursor);
                }
                if (object.otFetchRequest != null) {
                    if (typeof object.otFetchRequest !== "object")
                        throw TypeError(".api.Command.otFetchRequest: object expected");
                    message.otFetchRequest = $root.api.OTFetchRequest.fromObject(object.otFetchRequest);
                }
                if (object.otFetchResponse != null) {
                    if (typeof object.otFetchResponse !== "object")
                        throw TypeError(".api.Command.otFetchResponse: object expected");
                    message.otFetchResponse = $root.api.OTFetchResponse.fromObject(object.otFetchResponse);
                }
                if (object.otTransformSelectionRequest != null) {
                    if (typeof object.otTransformSelectionRequest !== "object")
                        throw TypeError(".api.Command.otTransformSelectionRequest: object expected");
                    message.otTransformSelectionRequest = $root.api.OTTransformSelectionRequest.fromObject(object.otTransformSelectionRequest);
                }
                if (object.otTransformSelectionResponse != null) {
                    if (typeof object.otTransformSelectionResponse !== "object")
                        throw TypeError(".api.Command.otTransformSelectionResponse: object expected");
                    message.otTransformSelectionResponse = $root.api.OTTransformSelectionResponse.fromObject(object.otTransformSelectionResponse);
                }
                if (object.flush != null) {
                    if (typeof object.flush !== "object")
                        throw TypeError(".api.Command.flush: object expected");
                    message.flush = $root.api.Flush.fromObject(object.flush);
                }
                if (object.debug != null) {
                    if (typeof object.debug !== "object")
                        throw TypeError(".api.Command.debug: object expected");
                    message.debug = $root.api.Debug.fromObject(object.debug);
                }
                if (object.startVCR != null) {
                    if (typeof object.startVCR !== "object")
                        throw TypeError(".api.Command.startVCR: object expected");
                    message.startVCR = $root.api.StartVCR.fromObject(object.startVCR);
                }
                if (object.readVCR != null) {
                    if (typeof object.readVCR !== "object")
                        throw TypeError(".api.Command.readVCR: object expected");
                    message.readVCR = $root.api.ReadVCR.fromObject(object.readVCR);
                }
                if (object.VCRLog != null) {
                    if (typeof object.VCRLog !== "object")
                        throw TypeError(".api.Command.VCRLog: object expected");
                    message.VCRLog = $root.api.VCRLog.fromObject(object.VCRLog);
                }
                if (object.auth != null) {
                    if (typeof object.auth !== "object")
                        throw TypeError(".api.Command.auth: object expected");
                    message.auth = $root.api.Auth.fromObject(object.auth);
                }
                if (object.execInfo != null) {
                    if (typeof object.execInfo !== "object")
                        throw TypeError(".api.Command.execInfo: object expected");
                    message.execInfo = $root.api.ExecInfo.fromObject(object.execInfo);
                }
                if (object.subscribeFile != null) {
                    if (typeof object.subscribeFile !== "object")
                        throw TypeError(".api.Command.subscribeFile: object expected");
                    message.subscribeFile = $root.api.SubscribeFile.fromObject(object.subscribeFile);
                }
                if (object.fileEvent != null) {
                    if (typeof object.fileEvent !== "object")
                        throw TypeError(".api.Command.fileEvent: object expected");
                    message.fileEvent = $root.api.FileEvent.fromObject(object.fileEvent);
                }
                if (object.roster != null) {
                    if (typeof object.roster !== "object")
                        throw TypeError(".api.Command.roster: object expected");
                    message.roster = $root.api.Roster.fromObject(object.roster);
                }
                if (object.join != null) {
                    if (typeof object.join !== "object")
                        throw TypeError(".api.Command.join: object expected");
                    message.join = $root.api.User.fromObject(object.join);
                }
                if (object.part != null) {
                    if (typeof object.part !== "object")
                        throw TypeError(".api.Command.part: object expected");
                    message.part = $root.api.User.fromObject(object.part);
                }
                if (object.openFile != null) {
                    if (typeof object.openFile !== "object")
                        throw TypeError(".api.Command.openFile: object expected");
                    message.openFile = $root.api.OpenFile.fromObject(object.openFile);
                }
                if (object.fileOpened != null) {
                    if (typeof object.fileOpened !== "object")
                        throw TypeError(".api.Command.fileOpened: object expected");
                    message.fileOpened = $root.api.FileOpened.fromObject(object.fileOpened);
                }
                if (object.followUser != null) {
                    if (typeof object.followUser !== "object")
                        throw TypeError(".api.Command.followUser: object expected");
                    message.followUser = $root.api.FollowUser.fromObject(object.followUser);
                }
                if (object.unfollowUser != null) {
                    if (typeof object.unfollowUser !== "object")
                        throw TypeError(".api.Command.unfollowUser: object expected");
                    message.unfollowUser = $root.api.UnfollowUser.fromObject(object.unfollowUser);
                }
                if (object.updateSessionTimestamp != null) {
                    if (typeof object.updateSessionTimestamp !== "object")
                        throw TypeError(".api.Command.updateSessionTimestamp: object expected");
                    message.updateSessionTimestamp = $root.api.UpdateSessionTimestamp.fromObject(object.updateSessionTimestamp);
                }
                if (object.sessionTimestampUpdated != null) {
                    if (typeof object.sessionTimestampUpdated !== "object")
                        throw TypeError(".api.Command.sessionTimestampUpdated: object expected");
                    message.sessionTimestampUpdated = $root.api.SessionTimestampUpdated.fromObject(object.sessionTimestampUpdated);
                }
                if (object.exec != null) {
                    if (typeof object.exec !== "object")
                        throw TypeError(".api.Command.exec: object expected");
                    message.exec = $root.api.Exec.fromObject(object.exec);
                }
                if (object.packageSearch != null) {
                    if (typeof object.packageSearch !== "object")
                        throw TypeError(".api.Command.packageSearch: object expected");
                    message.packageSearch = $root.api.PackageSearch.fromObject(object.packageSearch);
                }
                if (object.packageSearchResp != null) {
                    if (typeof object.packageSearchResp !== "object")
                        throw TypeError(".api.Command.packageSearchResp: object expected");
                    message.packageSearchResp = $root.api.PackageSearchResp.fromObject(object.packageSearchResp);
                }
                if (object.packageInfo != null) {
                    if (typeof object.packageInfo !== "object")
                        throw TypeError(".api.Command.packageInfo: object expected");
                    message.packageInfo = $root.api.PackageInfo.fromObject(object.packageInfo);
                }
                if (object.packageInfoResp != null) {
                    if (typeof object.packageInfoResp !== "object")
                        throw TypeError(".api.Command.packageInfoResp: object expected");
                    message.packageInfoResp = $root.api.PackageInfoResp.fromObject(object.packageInfoResp);
                }
                if (object.packageAdd != null) {
                    if (typeof object.packageAdd !== "object")
                        throw TypeError(".api.Command.packageAdd: object expected");
                    message.packageAdd = $root.api.PackageAdd.fromObject(object.packageAdd);
                }
                if (object.packageRemove != null) {
                    if (typeof object.packageRemove !== "object")
                        throw TypeError(".api.Command.packageRemove: object expected");
                    message.packageRemove = $root.api.PackageRemove.fromObject(object.packageRemove);
                }
                if (object.packageInstall != null) {
                    if (typeof object.packageInstall !== "object")
                        throw TypeError(".api.Command.packageInstall: object expected");
                    message.packageInstall = $root.api.PackageInstall.fromObject(object.packageInstall);
                }
                if (object.packageListSpecfile != null) {
                    if (typeof object.packageListSpecfile !== "object")
                        throw TypeError(".api.Command.packageListSpecfile: object expected");
                    message.packageListSpecfile = $root.api.PackageListSpecfile.fromObject(object.packageListSpecfile);
                }
                if (object.packageListSpecfileResp != null) {
                    if (typeof object.packageListSpecfileResp !== "object")
                        throw TypeError(".api.Command.packageListSpecfileResp: object expected");
                    message.packageListSpecfileResp = $root.api.PackageListSpecfileResp.fromObject(object.packageListSpecfileResp);
                }
                if (object.packageCacheSave != null) {
                    if (typeof object.packageCacheSave !== "object")
                        throw TypeError(".api.Command.packageCacheSave: object expected");
                    message.packageCacheSave = $root.api.PackageCacheSave.fromObject(object.packageCacheSave);
                }
                if (object.chatMessage != null) {
                    if (typeof object.chatMessage !== "object")
                        throw TypeError(".api.Command.chatMessage: object expected");
                    message.chatMessage = $root.api.ChatMessage.fromObject(object.chatMessage);
                }
                if (object.chatTyping != null) {
                    if (typeof object.chatTyping !== "object")
                        throw TypeError(".api.Command.chatTyping: object expected");
                    message.chatTyping = $root.api.ChatTyping.fromObject(object.chatTyping);
                }
                if (object.chatScrollback != null) {
                    if (typeof object.chatScrollback !== "object")
                        throw TypeError(".api.Command.chatScrollback: object expected");
                    message.chatScrollback = $root.api.ChatScrollback.fromObject(object.chatScrollback);
                }
                if (object.fsSnapshot != null) {
                    if (typeof object.fsSnapshot !== "object")
                        throw TypeError(".api.Command.fsSnapshot: object expected");
                    message.fsSnapshot = $root.api.FSSnapshot.fromObject(object.fsSnapshot);
                }
                if (object.fsTakeLock != null) {
                    if (typeof object.fsTakeLock !== "object")
                        throw TypeError(".api.Command.fsTakeLock: object expected");
                    message.fsTakeLock = $root.api.FSLock.fromObject(object.fsTakeLock);
                }
                if (object.fsReleaseLock != null) {
                    if (typeof object.fsReleaseLock !== "object")
                        throw TypeError(".api.Command.fsReleaseLock: object expected");
                    message.fsReleaseLock = $root.api.FSLock.fromObject(object.fsReleaseLock);
                }
                if (object.hasCap != null)
                    message.hasCap = Boolean(object.hasCap);
                if (object.pid1Config != null) {
                    if (typeof object.pid1Config !== "object")
                        throw TypeError(".api.Command.pid1Config: object expected");
                    message.pid1Config = $root.api.Pid1Config.fromObject(object.pid1Config);
                }
                if (object.metrics != null) {
                    if (typeof object.metrics !== "object")
                        throw TypeError(".api.Command.metrics: object expected");
                    message.metrics = $root.api.Metrics.fromObject(object.metrics);
                }
                if (object.bootStatus != null) {
                    if (typeof object.bootStatus !== "object")
                        throw TypeError(".api.Command.bootStatus: object expected");
                    message.bootStatus = $root.api.BootStatus.fromObject(object.bootStatus);
                }
                if (object.readMeta != null) {
                    if (typeof object.readMeta !== "object")
                        throw TypeError(".api.Command.readMeta: object expected");
                    message.readMeta = $root.api.ReadMeta.fromObject(object.readMeta);
                }
                if (object.writeMeta != null) {
                    if (typeof object.writeMeta !== "object")
                        throw TypeError(".api.Command.writeMeta: object expected");
                    message.writeMeta = $root.api.WriteMeta.fromObject(object.writeMeta);
                }
                if (object.appendMeta != null) {
                    if (typeof object.appendMeta !== "object")
                        throw TypeError(".api.Command.appendMeta: object expected");
                    message.appendMeta = $root.api.AppendMeta.fromObject(object.appendMeta);
                }
                if (object.audio != null) {
                    if (typeof object.audio !== "object")
                        throw TypeError(".api.Command.audio: object expected");
                    message.audio = $root.api.Audio.fromObject(object.audio);
                }
                if (object.pprofRequest != null) {
                    if (typeof object.pprofRequest !== "object")
                        throw TypeError(".api.Command.pprofRequest: object expected");
                    message.pprofRequest = $root.api.PprofRequest.fromObject(object.pprofRequest);
                }
                if (object.pprofResponse != null) {
                    if (typeof object.pprofResponse !== "object")
                        throw TypeError(".api.Command.pprofResponse: object expected");
                    message.pprofResponse = $root.api.PprofResponse.fromObject(object.pprofResponse);
                }
                if (object.audio2 != null) {
                    if (typeof object.audio2 !== "object")
                        throw TypeError(".api.Command.audio2: object expected");
                    message.audio2 = $root.api.Audio2.fromObject(object.audio2);
                }
                if (object.PTYConfig != null) {
                    if (typeof object.PTYConfig !== "object")
                        throw TypeError(".api.Command.PTYConfig: object expected");
                    message.PTYConfig = $root.api.PTYConfig.fromObject(object.PTYConfig);
                }
                if (object.debugMain != null) {
                    if (typeof object.debugMain !== "object")
                        throw TypeError(".api.Command.debugMain: object expected");
                    message.debugMain = $root.api.DebugMain.fromObject(object.debugMain);
                }
                if (object.debugState != null) {
                    if (typeof object.debugState !== "object")
                        throw TypeError(".api.Command.debugState: object expected");
                    message.debugState = $root.api.DebugState.fromObject(object.debugState);
                }
                if (object.debugMainReply != null) {
                    if (typeof object.debugMainReply !== "object")
                        throw TypeError(".api.Command.debugMainReply: object expected");
                    message.debugMainReply = $root.api.DebugMainReply.fromObject(object.debugMainReply);
                }
                if (object.debugInput != null) {
                    if (typeof object.debugInput !== "object")
                        throw TypeError(".api.Command.debugInput: object expected");
                    message.debugInput = $root.api.DebugInput.fromObject(object.debugInput);
                }
                if (object.debugOutput != null) {
                    if (typeof object.debugOutput !== "object")
                        throw TypeError(".api.Command.debugOutput: object expected");
                    message.debugOutput = $root.api.DebugOutput.fromObject(object.debugOutput);
                }
                if (object.debugStop != null) {
                    if (typeof object.debugStop !== "object")
                        throw TypeError(".api.Command.debugStop: object expected");
                    message.debugStop = $root.api.DebugStop.fromObject(object.debugStop);
                }
                if (object.debugLeave != null) {
                    if (typeof object.debugLeave !== "object")
                        throw TypeError(".api.Command.debugLeave: object expected");
                    message.debugLeave = $root.api.DebugLeave.fromObject(object.debugLeave);
                }
                if (object.debugSessions != null) {
                    if (typeof object.debugSessions !== "object")
                        throw TypeError(".api.Command.debugSessions: object expected");
                    message.debugSessions = $root.api.DebugSessions.fromObject(object.debugSessions);
                }
                if (object.debugAddBreakpointRequest != null) {
                    if (typeof object.debugAddBreakpointRequest !== "object")
                        throw TypeError(".api.Command.debugAddBreakpointRequest: object expected");
                    message.debugAddBreakpointRequest = $root.api.DebugAddBreakpointRequest.fromObject(object.debugAddBreakpointRequest);
                }
                if (object.debugRemoveBreakpointRequest != null) {
                    if (typeof object.debugRemoveBreakpointRequest !== "object")
                        throw TypeError(".api.Command.debugRemoveBreakpointRequest: object expected");
                    message.debugRemoveBreakpointRequest = $root.api.DebugRemoveBreakpointRequest.fromObject(object.debugRemoveBreakpointRequest);
                }
                if (object.debugBreakpointEvent != null) {
                    if (typeof object.debugBreakpointEvent !== "object")
                        throw TypeError(".api.Command.debugBreakpointEvent: object expected");
                    message.debugBreakpointEvent = $root.api.DebugBreakpointEvent.fromObject(object.debugBreakpointEvent);
                }
                if (object.dotReplitGetRequest != null) {
                    if (typeof object.dotReplitGetRequest !== "object")
                        throw TypeError(".api.Command.dotReplitGetRequest: object expected");
                    message.dotReplitGetRequest = $root.api.DotReplitGetRequest.fromObject(object.dotReplitGetRequest);
                }
                if (object.dotReplitGetResponse != null) {
                    if (typeof object.dotReplitGetResponse !== "object")
                        throw TypeError(".api.Command.dotReplitGetResponse: object expected");
                    message.dotReplitGetResponse = $root.api.DotReplitGetResponse.fromObject(object.dotReplitGetResponse);
                }
                if (object.ref != null)
                    message.ref = String(object.ref);
                return message;
            };
    
            /**
             * Creates a plain object from a Command message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Command
             * @static
             * @param {api.Command} message Command
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Command.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = 0;
                    object.session = 0;
                    object.ref = "";
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                if (message.openChan != null && message.hasOwnProperty("openChan")) {
                    object.openChan = $root.api.OpenChannel.toObject(message.openChan, options);
                    if (options.oneofs)
                        object.body = "openChan";
                }
                if (message.openChanRes != null && message.hasOwnProperty("openChanRes")) {
                    object.openChanRes = $root.api.OpenChannelRes.toObject(message.openChanRes, options);
                    if (options.oneofs)
                        object.body = "openChanRes";
                }
                if (message.closeChan != null && message.hasOwnProperty("closeChan")) {
                    object.closeChan = $root.api.CloseChannel.toObject(message.closeChan, options);
                    if (options.oneofs)
                        object.body = "closeChan";
                }
                if (message.closeChanRes != null && message.hasOwnProperty("closeChanRes")) {
                    object.closeChanRes = $root.api.CloseChannelRes.toObject(message.closeChanRes, options);
                    if (options.oneofs)
                        object.body = "closeChanRes";
                }
                if (message.containerState != null && message.hasOwnProperty("containerState")) {
                    object.containerState = $root.api.ContainerState.toObject(message.containerState, options);
                    if (options.oneofs)
                        object.body = "containerState";
                }
                if (message.portOpen != null && message.hasOwnProperty("portOpen")) {
                    object.portOpen = $root.api.PortOpen.toObject(message.portOpen, options);
                    if (options.oneofs)
                        object.body = "portOpen";
                }
                if (message.toast != null && message.hasOwnProperty("toast")) {
                    object.toast = $root.api.Toast.toObject(message.toast, options);
                    if (options.oneofs)
                        object.body = "toast";
                }
                if (message.redirect != null && message.hasOwnProperty("redirect")) {
                    object.redirect = $root.api.Redirect.toObject(message.redirect, options);
                    if (options.oneofs)
                        object.body = "redirect";
                }
                if (message.alwaysOn != null && message.hasOwnProperty("alwaysOn")) {
                    object.alwaysOn = $root.api.AlwaysOn.toObject(message.alwaysOn, options);
                    if (options.oneofs)
                        object.body = "alwaysOn";
                }
                if (message.runMain != null && message.hasOwnProperty("runMain")) {
                    object.runMain = $root.api.RunMain.toObject(message.runMain, options);
                    if (options.oneofs)
                        object.body = "runMain";
                }
                if (message.clear != null && message.hasOwnProperty("clear")) {
                    object.clear = $root.api.Clear.toObject(message.clear, options);
                    if (options.oneofs)
                        object.body = "clear";
                }
                if (message["eval"] != null && message.hasOwnProperty("eval")) {
                    object["eval"] = message["eval"];
                    if (options.oneofs)
                        object.body = "eval";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    object.result = message.result;
                    if (options.oneofs)
                        object.body = "result";
                }
                if (message.input != null && message.hasOwnProperty("input")) {
                    object.input = message.input;
                    if (options.oneofs)
                        object.body = "input";
                }
                if (message.output != null && message.hasOwnProperty("output")) {
                    object.output = message.output;
                    if (options.oneofs)
                        object.body = "output";
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = message.error;
                    if (options.oneofs)
                        object.body = "error";
                }
                if (message.saneTerm != null && message.hasOwnProperty("saneTerm")) {
                    object.saneTerm = $root.api.SaneTerm.toObject(message.saneTerm, options);
                    if (options.oneofs)
                        object.body = "saneTerm";
                }
                if (message.resizeTerm != null && message.hasOwnProperty("resizeTerm")) {
                    object.resizeTerm = $root.api.ResizeTerm.toObject(message.resizeTerm, options);
                    if (options.oneofs)
                        object.body = "resizeTerm";
                }
                if (message.state != null && message.hasOwnProperty("state")) {
                    object.state = options.enums === String ? $root.api.State[message.state] : message.state;
                    if (options.oneofs)
                        object.body = "state";
                }
                if (message.ok != null && message.hasOwnProperty("ok")) {
                    object.ok = $root.api.OK.toObject(message.ok, options);
                    if (options.oneofs)
                        object.body = "ok";
                }
                if (message.persist != null && message.hasOwnProperty("persist")) {
                    object.persist = $root.api.File.toObject(message.persist, options);
                    if (options.oneofs)
                        object.body = "persist";
                }
                if (message.write != null && message.hasOwnProperty("write")) {
                    object.write = $root.api.File.toObject(message.write, options);
                    if (options.oneofs)
                        object.body = "write";
                }
                if (message.remove != null && message.hasOwnProperty("remove")) {
                    object.remove = $root.api.File.toObject(message.remove, options);
                    if (options.oneofs)
                        object.body = "remove";
                }
                if (message.move != null && message.hasOwnProperty("move")) {
                    object.move = $root.api.Move.toObject(message.move, options);
                    if (options.oneofs)
                        object.body = "move";
                }
                if (message.read != null && message.hasOwnProperty("read")) {
                    object.read = $root.api.File.toObject(message.read, options);
                    if (options.oneofs)
                        object.body = "read";
                }
                if (message.tryRemove != null && message.hasOwnProperty("tryRemove")) {
                    object.tryRemove = $root.api.File.toObject(message.tryRemove, options);
                    if (options.oneofs)
                        object.body = "tryRemove";
                }
                if (message.readdir != null && message.hasOwnProperty("readdir")) {
                    object.readdir = $root.api.File.toObject(message.readdir, options);
                    if (options.oneofs)
                        object.body = "readdir";
                }
                if (message.files != null && message.hasOwnProperty("files")) {
                    object.files = $root.api.Files.toObject(message.files, options);
                    if (options.oneofs)
                        object.body = "files";
                }
                if (message.mkdir != null && message.hasOwnProperty("mkdir")) {
                    object.mkdir = $root.api.File.toObject(message.mkdir, options);
                    if (options.oneofs)
                        object.body = "mkdir";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = $root.api.File.toObject(message.file, options);
                    if (options.oneofs)
                        object.body = "file";
                }
                if (message.persistMirror != null && message.hasOwnProperty("persistMirror")) {
                    object.persistMirror = $root.api.File.toObject(message.persistMirror, options);
                    if (options.oneofs)
                        object.body = "persistMirror";
                }
                if (message.checkChanges != null && message.hasOwnProperty("checkChanges")) {
                    object.checkChanges = $root.api.CheckChanges.toObject(message.checkChanges, options);
                    if (options.oneofs)
                        object.body = "checkChanges";
                }
                if (message.changedFiles != null && message.hasOwnProperty("changedFiles")) {
                    object.changedFiles = $root.api.Files.toObject(message.changedFiles, options);
                    if (options.oneofs)
                        object.body = "changedFiles";
                }
                if (message.lintResults != null && message.hasOwnProperty("lintResults")) {
                    object.lintResults = $root.api.LintResults.toObject(message.lintResults, options);
                    if (options.oneofs)
                        object.body = "lintResults";
                }
                if (message.runContainedTest != null && message.hasOwnProperty("runContainedTest")) {
                    object.runContainedTest = $root.api.ContainedTest.toObject(message.runContainedTest, options);
                    if (options.oneofs)
                        object.body = "runContainedTest";
                }
                if (message.testResult != null && message.hasOwnProperty("testResult")) {
                    object.testResult = $root.api.TestResult.toObject(message.testResult, options);
                    if (options.oneofs)
                        object.body = "testResult";
                }
                if (message.debuggerStart != null && message.hasOwnProperty("debuggerStart")) {
                    object.debuggerStart = message.debuggerStart;
                    if (options.oneofs)
                        object.body = "debuggerStart";
                }
                if (message.debuggerStep != null && message.hasOwnProperty("debuggerStep")) {
                    object.debuggerStep = $root.api.RunMain.toObject(message.debuggerStep, options);
                    if (options.oneofs)
                        object.body = "debuggerStep";
                }
                if (message.debuggerStatus != null && message.hasOwnProperty("debuggerStatus")) {
                    object.debuggerStatus = $root.api.DebugStatus.toObject(message.debuggerStatus, options);
                    if (options.oneofs)
                        object.body = "debuggerStatus";
                }
                if (message.ensurePackages != null && message.hasOwnProperty("ensurePackages")) {
                    object.ensurePackages = $root.api.EnsurePackages.toObject(message.ensurePackages, options);
                    if (options.oneofs)
                        object.body = "ensurePackages";
                }
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    object.ping = $root.api.Ping.toObject(message.ping, options);
                    if (options.oneofs)
                        object.body = "ping";
                }
                if (message.pong != null && message.hasOwnProperty("pong")) {
                    object.pong = $root.api.Pong.toObject(message.pong, options);
                    if (options.oneofs)
                        object.body = "pong";
                }
                if (message.hello != null && message.hasOwnProperty("hello")) {
                    object.hello = $root.api.Hello.toObject(message.hello, options);
                    if (options.oneofs)
                        object.body = "hello";
                }
                if (message.goodbye != null && message.hasOwnProperty("goodbye")) {
                    object.goodbye = $root.api.Goodbye.toObject(message.goodbye, options);
                    if (options.oneofs)
                        object.body = "goodbye";
                }
                if (message.hint != null && message.hasOwnProperty("hint")) {
                    object.hint = $root.api.Hint.toObject(message.hint, options);
                    if (options.oneofs)
                        object.body = "hint";
                }
                if (message.connect != null && message.hasOwnProperty("connect")) {
                    object.connect = $root.api.Connect.toObject(message.connect, options);
                    if (options.oneofs)
                        object.body = "connect";
                }
                if (message.send != null && message.hasOwnProperty("send")) {
                    object.send = $root.api.Send.toObject(message.send, options);
                    if (options.oneofs)
                        object.body = "send";
                }
                if (message.recv != null && message.hasOwnProperty("recv")) {
                    object.recv = $root.api.Recv.toObject(message.recv, options);
                    if (options.oneofs)
                        object.body = "recv";
                }
                if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                    object.disconnect = $root.api.Disconnect.toObject(message.disconnect, options);
                    if (options.oneofs)
                        object.body = "disconnect";
                }
                if (message.fileAuthReq != null && message.hasOwnProperty("fileAuthReq")) {
                    object.fileAuthReq = $root.api.FileAuthReq.toObject(message.fileAuthReq, options);
                    if (options.oneofs)
                        object.body = "fileAuthReq";
                }
                if (message.fileAuthRes != null && message.hasOwnProperty("fileAuthRes")) {
                    object.fileAuthRes = $root.api.FileAuthRes.toObject(message.fileAuthRes, options);
                    if (options.oneofs)
                        object.body = "fileAuthRes";
                }
                if (message.mutliFileAuthRes != null && message.hasOwnProperty("mutliFileAuthRes")) {
                    object.mutliFileAuthRes = $root.api.MultiFileAuthRes.toObject(message.mutliFileAuthRes, options);
                    if (options.oneofs)
                        object.body = "mutliFileAuthRes";
                }
                if (message.listObjects != null && message.hasOwnProperty("listObjects")) {
                    object.listObjects = $root.api.ListObjects.toObject(message.listObjects, options);
                    if (options.oneofs)
                        object.body = "listObjects";
                }
                if (message.listObjectsResp != null && message.hasOwnProperty("listObjectsResp")) {
                    object.listObjectsResp = $root.api.ListObjectsResp.toObject(message.listObjectsResp, options);
                    if (options.oneofs)
                        object.body = "listObjectsResp";
                }
                if (message.ot != null && message.hasOwnProperty("ot")) {
                    object.ot = $root.api.OTPacket.toObject(message.ot, options);
                    if (options.oneofs)
                        object.body = "ot";
                }
                if (message.otstatus != null && message.hasOwnProperty("otstatus")) {
                    object.otstatus = $root.api.OTStatus.toObject(message.otstatus, options);
                    if (options.oneofs)
                        object.body = "otstatus";
                }
                if (message.otLinkFile != null && message.hasOwnProperty("otLinkFile")) {
                    object.otLinkFile = $root.api.OTLinkFile.toObject(message.otLinkFile, options);
                    if (options.oneofs)
                        object.body = "otLinkFile";
                }
                if (message.otNewCursor != null && message.hasOwnProperty("otNewCursor")) {
                    object.otNewCursor = $root.api.OTCursor.toObject(message.otNewCursor, options);
                    if (options.oneofs)
                        object.body = "otNewCursor";
                }
                if (message.otDeleteCursor != null && message.hasOwnProperty("otDeleteCursor")) {
                    object.otDeleteCursor = $root.api.OTCursor.toObject(message.otDeleteCursor, options);
                    if (options.oneofs)
                        object.body = "otDeleteCursor";
                }
                if (message.otFetchRequest != null && message.hasOwnProperty("otFetchRequest")) {
                    object.otFetchRequest = $root.api.OTFetchRequest.toObject(message.otFetchRequest, options);
                    if (options.oneofs)
                        object.body = "otFetchRequest";
                }
                if (message.otFetchResponse != null && message.hasOwnProperty("otFetchResponse")) {
                    object.otFetchResponse = $root.api.OTFetchResponse.toObject(message.otFetchResponse, options);
                    if (options.oneofs)
                        object.body = "otFetchResponse";
                }
                if (message.otTransformSelectionRequest != null && message.hasOwnProperty("otTransformSelectionRequest")) {
                    object.otTransformSelectionRequest = $root.api.OTTransformSelectionRequest.toObject(message.otTransformSelectionRequest, options);
                    if (options.oneofs)
                        object.body = "otTransformSelectionRequest";
                }
                if (message.otTransformSelectionResponse != null && message.hasOwnProperty("otTransformSelectionResponse")) {
                    object.otTransformSelectionResponse = $root.api.OTTransformSelectionResponse.toObject(message.otTransformSelectionResponse, options);
                    if (options.oneofs)
                        object.body = "otTransformSelectionResponse";
                }
                if (message.debug != null && message.hasOwnProperty("debug")) {
                    object.debug = $root.api.Debug.toObject(message.debug, options);
                    if (options.oneofs)
                        object.body = "debug";
                }
                if (message.startVCR != null && message.hasOwnProperty("startVCR")) {
                    object.startVCR = $root.api.StartVCR.toObject(message.startVCR, options);
                    if (options.oneofs)
                        object.body = "startVCR";
                }
                if (message.readVCR != null && message.hasOwnProperty("readVCR")) {
                    object.readVCR = $root.api.ReadVCR.toObject(message.readVCR, options);
                    if (options.oneofs)
                        object.body = "readVCR";
                }
                if (message.VCRLog != null && message.hasOwnProperty("VCRLog")) {
                    object.VCRLog = $root.api.VCRLog.toObject(message.VCRLog, options);
                    if (options.oneofs)
                        object.body = "VCRLog";
                }
                if (message.auth != null && message.hasOwnProperty("auth")) {
                    object.auth = $root.api.Auth.toObject(message.auth, options);
                    if (options.oneofs)
                        object.body = "auth";
                }
                if (message.execInfo != null && message.hasOwnProperty("execInfo")) {
                    object.execInfo = $root.api.ExecInfo.toObject(message.execInfo, options);
                    if (options.oneofs)
                        object.body = "execInfo";
                }
                if (message.flush != null && message.hasOwnProperty("flush")) {
                    object.flush = $root.api.Flush.toObject(message.flush, options);
                    if (options.oneofs)
                        object.body = "flush";
                }
                if (message.subscribeFile != null && message.hasOwnProperty("subscribeFile")) {
                    object.subscribeFile = $root.api.SubscribeFile.toObject(message.subscribeFile, options);
                    if (options.oneofs)
                        object.body = "subscribeFile";
                }
                if (message.fileEvent != null && message.hasOwnProperty("fileEvent")) {
                    object.fileEvent = $root.api.FileEvent.toObject(message.fileEvent, options);
                    if (options.oneofs)
                        object.body = "fileEvent";
                }
                if (message.roster != null && message.hasOwnProperty("roster")) {
                    object.roster = $root.api.Roster.toObject(message.roster, options);
                    if (options.oneofs)
                        object.body = "roster";
                }
                if (message.join != null && message.hasOwnProperty("join")) {
                    object.join = $root.api.User.toObject(message.join, options);
                    if (options.oneofs)
                        object.body = "join";
                }
                if (message.part != null && message.hasOwnProperty("part")) {
                    object.part = $root.api.User.toObject(message.part, options);
                    if (options.oneofs)
                        object.body = "part";
                }
                if (message.openFile != null && message.hasOwnProperty("openFile")) {
                    object.openFile = $root.api.OpenFile.toObject(message.openFile, options);
                    if (options.oneofs)
                        object.body = "openFile";
                }
                if (message.fileOpened != null && message.hasOwnProperty("fileOpened")) {
                    object.fileOpened = $root.api.FileOpened.toObject(message.fileOpened, options);
                    if (options.oneofs)
                        object.body = "fileOpened";
                }
                if (message.followUser != null && message.hasOwnProperty("followUser")) {
                    object.followUser = $root.api.FollowUser.toObject(message.followUser, options);
                    if (options.oneofs)
                        object.body = "followUser";
                }
                if (message.updateSessionTimestamp != null && message.hasOwnProperty("updateSessionTimestamp")) {
                    object.updateSessionTimestamp = $root.api.UpdateSessionTimestamp.toObject(message.updateSessionTimestamp, options);
                    if (options.oneofs)
                        object.body = "updateSessionTimestamp";
                }
                if (message.sessionTimestampUpdated != null && message.hasOwnProperty("sessionTimestampUpdated")) {
                    object.sessionTimestampUpdated = $root.api.SessionTimestampUpdated.toObject(message.sessionTimestampUpdated, options);
                    if (options.oneofs)
                        object.body = "sessionTimestampUpdated";
                }
                if (message.unfollowUser != null && message.hasOwnProperty("unfollowUser")) {
                    object.unfollowUser = $root.api.UnfollowUser.toObject(message.unfollowUser, options);
                    if (options.oneofs)
                        object.body = "unfollowUser";
                }
                if (message.exec != null && message.hasOwnProperty("exec")) {
                    object.exec = $root.api.Exec.toObject(message.exec, options);
                    if (options.oneofs)
                        object.body = "exec";
                }
                if (message.packageSearch != null && message.hasOwnProperty("packageSearch")) {
                    object.packageSearch = $root.api.PackageSearch.toObject(message.packageSearch, options);
                    if (options.oneofs)
                        object.body = "packageSearch";
                }
                if (message.packageSearchResp != null && message.hasOwnProperty("packageSearchResp")) {
                    object.packageSearchResp = $root.api.PackageSearchResp.toObject(message.packageSearchResp, options);
                    if (options.oneofs)
                        object.body = "packageSearchResp";
                }
                if (message.packageInfo != null && message.hasOwnProperty("packageInfo")) {
                    object.packageInfo = $root.api.PackageInfo.toObject(message.packageInfo, options);
                    if (options.oneofs)
                        object.body = "packageInfo";
                }
                if (message.packageInfoResp != null && message.hasOwnProperty("packageInfoResp")) {
                    object.packageInfoResp = $root.api.PackageInfoResp.toObject(message.packageInfoResp, options);
                    if (options.oneofs)
                        object.body = "packageInfoResp";
                }
                if (message.packageAdd != null && message.hasOwnProperty("packageAdd")) {
                    object.packageAdd = $root.api.PackageAdd.toObject(message.packageAdd, options);
                    if (options.oneofs)
                        object.body = "packageAdd";
                }
                if (message.packageRemove != null && message.hasOwnProperty("packageRemove")) {
                    object.packageRemove = $root.api.PackageRemove.toObject(message.packageRemove, options);
                    if (options.oneofs)
                        object.body = "packageRemove";
                }
                if (message.packageInstall != null && message.hasOwnProperty("packageInstall")) {
                    object.packageInstall = $root.api.PackageInstall.toObject(message.packageInstall, options);
                    if (options.oneofs)
                        object.body = "packageInstall";
                }
                if (message.packageListSpecfile != null && message.hasOwnProperty("packageListSpecfile")) {
                    object.packageListSpecfile = $root.api.PackageListSpecfile.toObject(message.packageListSpecfile, options);
                    if (options.oneofs)
                        object.body = "packageListSpecfile";
                }
                if (message.packageListSpecfileResp != null && message.hasOwnProperty("packageListSpecfileResp")) {
                    object.packageListSpecfileResp = $root.api.PackageListSpecfileResp.toObject(message.packageListSpecfileResp, options);
                    if (options.oneofs)
                        object.body = "packageListSpecfileResp";
                }
                if (message.packageCacheSave != null && message.hasOwnProperty("packageCacheSave")) {
                    object.packageCacheSave = $root.api.PackageCacheSave.toObject(message.packageCacheSave, options);
                    if (options.oneofs)
                        object.body = "packageCacheSave";
                }
                if (message.chatMessage != null && message.hasOwnProperty("chatMessage")) {
                    object.chatMessage = $root.api.ChatMessage.toObject(message.chatMessage, options);
                    if (options.oneofs)
                        object.body = "chatMessage";
                }
                if (message.chatTyping != null && message.hasOwnProperty("chatTyping")) {
                    object.chatTyping = $root.api.ChatTyping.toObject(message.chatTyping, options);
                    if (options.oneofs)
                        object.body = "chatTyping";
                }
                if (message.chatScrollback != null && message.hasOwnProperty("chatScrollback")) {
                    object.chatScrollback = $root.api.ChatScrollback.toObject(message.chatScrollback, options);
                    if (options.oneofs)
                        object.body = "chatScrollback";
                }
                if (message.transferStart != null && message.hasOwnProperty("transferStart")) {
                    object.transferStart = $root.api.TransferStart.toObject(message.transferStart, options);
                    if (options.oneofs)
                        object.body = "transferStart";
                }
                if (message.transferChunk != null && message.hasOwnProperty("transferChunk")) {
                    object.transferChunk = $root.api.TransferChunk.toObject(message.transferChunk, options);
                    if (options.oneofs)
                        object.body = "transferChunk";
                }
                if (message.transferComplete != null && message.hasOwnProperty("transferComplete")) {
                    object.transferComplete = $root.api.TransferComplete.toObject(message.transferComplete, options);
                    if (options.oneofs)
                        object.body = "transferComplete";
                }
                if (message.transferCancel != null && message.hasOwnProperty("transferCancel")) {
                    object.transferCancel = $root.api.Transfer.toObject(message.transferCancel, options);
                    if (options.oneofs)
                        object.body = "transferCancel";
                }
                if (message.transfer != null && message.hasOwnProperty("transfer")) {
                    object.transfer = $root.api.Transfer.toObject(message.transfer, options);
                    if (options.oneofs)
                        object.body = "transfer";
                }
                if (message.fsSnapshot != null && message.hasOwnProperty("fsSnapshot")) {
                    object.fsSnapshot = $root.api.FSSnapshot.toObject(message.fsSnapshot, options);
                    if (options.oneofs)
                        object.body = "fsSnapshot";
                }
                if (message.fsTakeLock != null && message.hasOwnProperty("fsTakeLock")) {
                    object.fsTakeLock = $root.api.FSLock.toObject(message.fsTakeLock, options);
                    if (options.oneofs)
                        object.body = "fsTakeLock";
                }
                if (message.fsReleaseLock != null && message.hasOwnProperty("fsReleaseLock")) {
                    object.fsReleaseLock = $root.api.FSLock.toObject(message.fsReleaseLock, options);
                    if (options.oneofs)
                        object.body = "fsReleaseLock";
                }
                if (message.hasCap != null && message.hasOwnProperty("hasCap")) {
                    object.hasCap = message.hasCap;
                    if (options.oneofs)
                        object.body = "hasCap";
                }
                if (message.pid1Config != null && message.hasOwnProperty("pid1Config")) {
                    object.pid1Config = $root.api.Pid1Config.toObject(message.pid1Config, options);
                    if (options.oneofs)
                        object.body = "pid1Config";
                }
                if (message.metrics != null && message.hasOwnProperty("metrics")) {
                    object.metrics = $root.api.Metrics.toObject(message.metrics, options);
                    if (options.oneofs)
                        object.body = "metrics";
                }
                if (message.bootStatus != null && message.hasOwnProperty("bootStatus")) {
                    object.bootStatus = $root.api.BootStatus.toObject(message.bootStatus, options);
                    if (options.oneofs)
                        object.body = "bootStatus";
                }
                if (message.readMeta != null && message.hasOwnProperty("readMeta")) {
                    object.readMeta = $root.api.ReadMeta.toObject(message.readMeta, options);
                    if (options.oneofs)
                        object.body = "readMeta";
                }
                if (message.writeMeta != null && message.hasOwnProperty("writeMeta")) {
                    object.writeMeta = $root.api.WriteMeta.toObject(message.writeMeta, options);
                    if (options.oneofs)
                        object.body = "writeMeta";
                }
                if (message.appendMeta != null && message.hasOwnProperty("appendMeta")) {
                    object.appendMeta = $root.api.AppendMeta.toObject(message.appendMeta, options);
                    if (options.oneofs)
                        object.body = "appendMeta";
                }
                if (message.audio != null && message.hasOwnProperty("audio")) {
                    object.audio = $root.api.Audio.toObject(message.audio, options);
                    if (options.oneofs)
                        object.body = "audio";
                }
                if (message.pprofRequest != null && message.hasOwnProperty("pprofRequest")) {
                    object.pprofRequest = $root.api.PprofRequest.toObject(message.pprofRequest, options);
                    if (options.oneofs)
                        object.body = "pprofRequest";
                }
                if (message.pprofResponse != null && message.hasOwnProperty("pprofResponse")) {
                    object.pprofResponse = $root.api.PprofResponse.toObject(message.pprofResponse, options);
                    if (options.oneofs)
                        object.body = "pprofResponse";
                }
                if (message.audio2 != null && message.hasOwnProperty("audio2")) {
                    object.audio2 = $root.api.Audio2.toObject(message.audio2, options);
                    if (options.oneofs)
                        object.body = "audio2";
                }
                if (message.PTYConfig != null && message.hasOwnProperty("PTYConfig")) {
                    object.PTYConfig = $root.api.PTYConfig.toObject(message.PTYConfig, options);
                    if (options.oneofs)
                        object.body = "PTYConfig";
                }
                if (message.stat != null && message.hasOwnProperty("stat")) {
                    object.stat = $root.api.File.toObject(message.stat, options);
                    if (options.oneofs)
                        object.body = "stat";
                }
                if (message.statRes != null && message.hasOwnProperty("statRes")) {
                    object.statRes = $root.api.StatResult.toObject(message.statRes, options);
                    if (options.oneofs)
                        object.body = "statRes";
                }
                if (message.debugMain != null && message.hasOwnProperty("debugMain")) {
                    object.debugMain = $root.api.DebugMain.toObject(message.debugMain, options);
                    if (options.oneofs)
                        object.body = "debugMain";
                }
                if (message.debugState != null && message.hasOwnProperty("debugState")) {
                    object.debugState = $root.api.DebugState.toObject(message.debugState, options);
                    if (options.oneofs)
                        object.body = "debugState";
                }
                if (message.debugMainReply != null && message.hasOwnProperty("debugMainReply")) {
                    object.debugMainReply = $root.api.DebugMainReply.toObject(message.debugMainReply, options);
                    if (options.oneofs)
                        object.body = "debugMainReply";
                }
                if (message.debugInput != null && message.hasOwnProperty("debugInput")) {
                    object.debugInput = $root.api.DebugInput.toObject(message.debugInput, options);
                    if (options.oneofs)
                        object.body = "debugInput";
                }
                if (message.debugOutput != null && message.hasOwnProperty("debugOutput")) {
                    object.debugOutput = $root.api.DebugOutput.toObject(message.debugOutput, options);
                    if (options.oneofs)
                        object.body = "debugOutput";
                }
                if (message.debugStop != null && message.hasOwnProperty("debugStop")) {
                    object.debugStop = $root.api.DebugStop.toObject(message.debugStop, options);
                    if (options.oneofs)
                        object.body = "debugStop";
                }
                if (message.debugLeave != null && message.hasOwnProperty("debugLeave")) {
                    object.debugLeave = $root.api.DebugLeave.toObject(message.debugLeave, options);
                    if (options.oneofs)
                        object.body = "debugLeave";
                }
                if (message.debugSessions != null && message.hasOwnProperty("debugSessions")) {
                    object.debugSessions = $root.api.DebugSessions.toObject(message.debugSessions, options);
                    if (options.oneofs)
                        object.body = "debugSessions";
                }
                if (message.dotReplitGetRequest != null && message.hasOwnProperty("dotReplitGetRequest")) {
                    object.dotReplitGetRequest = $root.api.DotReplitGetRequest.toObject(message.dotReplitGetRequest, options);
                    if (options.oneofs)
                        object.body = "dotReplitGetRequest";
                }
                if (message.dotReplitGetResponse != null && message.hasOwnProperty("dotReplitGetResponse")) {
                    object.dotReplitGetResponse = $root.api.DotReplitGetResponse.toObject(message.dotReplitGetResponse, options);
                    if (options.oneofs)
                        object.body = "dotReplitGetResponse";
                }
                if (message.debugAddBreakpointRequest != null && message.hasOwnProperty("debugAddBreakpointRequest")) {
                    object.debugAddBreakpointRequest = $root.api.DebugAddBreakpointRequest.toObject(message.debugAddBreakpointRequest, options);
                    if (options.oneofs)
                        object.body = "debugAddBreakpointRequest";
                }
                if (message.debugRemoveBreakpointRequest != null && message.hasOwnProperty("debugRemoveBreakpointRequest")) {
                    object.debugRemoveBreakpointRequest = $root.api.DebugRemoveBreakpointRequest.toObject(message.debugRemoveBreakpointRequest, options);
                    if (options.oneofs)
                        object.body = "debugRemoveBreakpointRequest";
                }
                if (message.debugBreakpointEvent != null && message.hasOwnProperty("debugBreakpointEvent")) {
                    object.debugBreakpointEvent = $root.api.DebugBreakpointEvent.toObject(message.debugBreakpointEvent, options);
                    if (options.oneofs)
                        object.body = "debugBreakpointEvent";
                }
                if (message.ref != null && message.hasOwnProperty("ref"))
                    object.ref = message.ref;
                return object;
            };
    
            /**
             * Converts this Command to JSON.
             * @function toJSON
             * @memberof api.Command
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Command.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Command;
        })();
    
        api.Audio = (function() {
    
            /**
             * Properties of an Audio.
             * @memberof api
             * @interface IAudio
             * @property {Array.<number>|null} [data] Audio data
             */
    
            /**
             * Constructs a new Audio.
             * @memberof api
             * @classdesc Represents an Audio.
             * @constructor
             * @param {api.IAudio=} [properties] Properties to set
             */
            function Audio(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Audio data.
             * @member {Array.<number>} data
             * @memberof api.Audio
             * @instance
             */
            Audio.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new Audio instance using the specified properties.
             * @function create
             * @memberof api.Audio
             * @static
             * @param {api.IAudio=} [properties] Properties to set
             * @returns {api.Audio} Audio instance
             */
            Audio.create = function create(properties) {
                return Audio.fromObject(properties);
            };
    
            /**
             * Encodes the specified Audio message. Does not implicitly {@link api.Audio.verify|verify} messages.
             * @function encode
             * @memberof api.Audio
             * @static
             * @param {api.Audio} message Audio message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Audio.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && message.data.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.data.length; ++i)
                        writer.int32(message.data[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified Audio message, length delimited. Does not implicitly {@link api.Audio.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Audio
             * @static
             * @param {api.Audio} message Audio message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Audio.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Audio message from the specified reader or buffer.
             * @function decode
             * @memberof api.Audio
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Audio} Audio
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Audio.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Audio();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.data.push(reader.int32());
                        } else
                            message.data.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Audio message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Audio
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Audio} Audio
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Audio.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Audio message.
             * @function verify
             * @memberof api.Audio
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Audio.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isInteger(message.data[i]))
                            return "data: integer[] expected";
                }
                return null;
            };
    
            /**
             * Creates an Audio message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Audio
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Audio} Audio
             */
            Audio.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Audio)
                    return object;
                var message = new $root.api.Audio();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".api.Audio.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = object.data[i] | 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Audio message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Audio
             * @static
             * @param {api.Audio} message Audio
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Audio.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this Audio to JSON.
             * @function toJSON
             * @memberof api.Audio
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Audio.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Audio;
        })();
    
        api.Audio2 = (function() {
    
            /**
             * Properties of an Audio2.
             * @memberof api
             * @interface IAudio2
             * @property {Array.<number>|null} [data] Audio2 data
             * @property {number|null} [samples] Audio2 samples
             */
    
            /**
             * Constructs a new Audio2.
             * @memberof api
             * @classdesc Represents an Audio2.
             * @constructor
             * @param {api.IAudio2=} [properties] Properties to set
             */
            function Audio2(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Audio2 data.
             * @member {Array.<number>} data
             * @memberof api.Audio2
             * @instance
             */
            Audio2.prototype.data = $util.emptyArray;
    
            /**
             * Audio2 samples.
             * @member {number} samples
             * @memberof api.Audio2
             * @instance
             */
            Audio2.prototype.samples = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new Audio2 instance using the specified properties.
             * @function create
             * @memberof api.Audio2
             * @static
             * @param {api.IAudio2=} [properties] Properties to set
             * @returns {api.Audio2} Audio2 instance
             */
            Audio2.create = function create(properties) {
                return Audio2.fromObject(properties);
            };
    
            /**
             * Encodes the specified Audio2 message. Does not implicitly {@link api.Audio2.verify|verify} messages.
             * @function encode
             * @memberof api.Audio2
             * @static
             * @param {api.Audio2} message Audio2 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Audio2.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && message.data.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.data.length; ++i)
                        writer.sint32(message.data[i]);
                    writer.ldelim();
                }
                if (message.samples != null && Object.hasOwnProperty.call(message, "samples"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.samples);
                return writer;
            };
    
            /**
             * Encodes the specified Audio2 message, length delimited. Does not implicitly {@link api.Audio2.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Audio2
             * @static
             * @param {api.Audio2} message Audio2 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Audio2.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Audio2 message from the specified reader or buffer.
             * @function decode
             * @memberof api.Audio2
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Audio2} Audio2
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Audio2.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Audio2();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.data.push(reader.sint32());
                        } else
                            message.data.push(reader.sint32());
                        break;
                    case 2:
                        message.samples = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Audio2 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Audio2
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Audio2} Audio2
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Audio2.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Audio2 message.
             * @function verify
             * @memberof api.Audio2
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Audio2.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isInteger(message.data[i]))
                            return "data: integer[] expected";
                }
                if (message.samples != null && message.hasOwnProperty("samples"))
                    if (!$util.isInteger(message.samples) && !(message.samples && $util.isInteger(message.samples.low) && $util.isInteger(message.samples.high)))
                        return "samples: integer|Long expected";
                return null;
            };
    
            /**
             * Creates an Audio2 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Audio2
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Audio2} Audio2
             */
            Audio2.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Audio2)
                    return object;
                var message = new $root.api.Audio2();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".api.Audio2.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = object.data[i] | 0;
                }
                if (object.samples != null)
                    if ($util.Long)
                        (message.samples = $util.Long.fromValue(object.samples)).unsigned = false;
                    else if (typeof object.samples === "string")
                        message.samples = parseInt(object.samples, 10);
                    else if (typeof object.samples === "number")
                        message.samples = object.samples;
                    else if (typeof object.samples === "object")
                        message.samples = new $util.LongBits(object.samples.low >>> 0, object.samples.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from an Audio2 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Audio2
             * @static
             * @param {api.Audio2} message Audio2
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Audio2.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.samples = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.samples = options.longs === String ? "0" : 0;
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                if (message.samples != null && message.hasOwnProperty("samples"))
                    if (typeof message.samples === "number")
                        object.samples = options.longs === String ? String(message.samples) : message.samples;
                    else
                        object.samples = options.longs === String ? $util.Long.prototype.toString.call(message.samples) : options.longs === Number ? new $util.LongBits(message.samples.low >>> 0, message.samples.high >>> 0).toNumber() : message.samples;
                return object;
            };
    
            /**
             * Converts this Audio2 to JSON.
             * @function toJSON
             * @memberof api.Audio2
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Audio2.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Audio2;
        })();
    
        api.ReadMeta = (function() {
    
            /**
             * Properties of a ReadMeta.
             * @memberof api
             * @interface IReadMeta
             * @property {string|null} [key] ReadMeta key
             * @property {boolean|null} [exists] ReadMeta exists
             * @property {Uint8Array|null} [data] ReadMeta data
             */
    
            /**
             * Constructs a new ReadMeta.
             * @memberof api
             * @classdesc Represents a ReadMeta.
             * @constructor
             * @param {api.IReadMeta=} [properties] Properties to set
             */
            function ReadMeta(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReadMeta key.
             * @member {string} key
             * @memberof api.ReadMeta
             * @instance
             */
            ReadMeta.prototype.key = "";
    
            /**
             * ReadMeta exists.
             * @member {boolean} exists
             * @memberof api.ReadMeta
             * @instance
             */
            ReadMeta.prototype.exists = false;
    
            /**
             * ReadMeta data.
             * @member {Uint8Array} data
             * @memberof api.ReadMeta
             * @instance
             */
            ReadMeta.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new ReadMeta instance using the specified properties.
             * @function create
             * @memberof api.ReadMeta
             * @static
             * @param {api.IReadMeta=} [properties] Properties to set
             * @returns {api.ReadMeta} ReadMeta instance
             */
            ReadMeta.create = function create(properties) {
                return ReadMeta.fromObject(properties);
            };
    
            /**
             * Encodes the specified ReadMeta message. Does not implicitly {@link api.ReadMeta.verify|verify} messages.
             * @function encode
             * @memberof api.ReadMeta
             * @static
             * @param {api.ReadMeta} message ReadMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.exists != null && Object.hasOwnProperty.call(message, "exists"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.exists);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified ReadMeta message, length delimited. Does not implicitly {@link api.ReadMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ReadMeta
             * @static
             * @param {api.ReadMeta} message ReadMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ReadMeta message from the specified reader or buffer.
             * @function decode
             * @memberof api.ReadMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ReadMeta} ReadMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ReadMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.exists = reader.bool();
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ReadMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ReadMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ReadMeta} ReadMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ReadMeta message.
             * @function verify
             * @memberof api.ReadMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.exists != null && message.hasOwnProperty("exists"))
                    if (typeof message.exists !== "boolean")
                        return "exists: boolean expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };
    
            /**
             * Creates a ReadMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ReadMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ReadMeta} ReadMeta
             */
            ReadMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ReadMeta)
                    return object;
                var message = new $root.api.ReadMeta();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.exists != null)
                    message.exists = Boolean(object.exists);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };
    
            /**
             * Creates a plain object from a ReadMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ReadMeta
             * @static
             * @param {api.ReadMeta} message ReadMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.exists = false;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.exists != null && message.hasOwnProperty("exists"))
                    object.exists = message.exists;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };
    
            /**
             * Converts this ReadMeta to JSON.
             * @function toJSON
             * @memberof api.ReadMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ReadMeta;
        })();
    
        api.WriteMeta = (function() {
    
            /**
             * Properties of a WriteMeta.
             * @memberof api
             * @interface IWriteMeta
             * @property {string|null} [key] WriteMeta key
             * @property {Uint8Array|null} [data] WriteMeta data
             */
    
            /**
             * Constructs a new WriteMeta.
             * @memberof api
             * @classdesc Represents a WriteMeta.
             * @constructor
             * @param {api.IWriteMeta=} [properties] Properties to set
             */
            function WriteMeta(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * WriteMeta key.
             * @member {string} key
             * @memberof api.WriteMeta
             * @instance
             */
            WriteMeta.prototype.key = "";
    
            /**
             * WriteMeta data.
             * @member {Uint8Array} data
             * @memberof api.WriteMeta
             * @instance
             */
            WriteMeta.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new WriteMeta instance using the specified properties.
             * @function create
             * @memberof api.WriteMeta
             * @static
             * @param {api.IWriteMeta=} [properties] Properties to set
             * @returns {api.WriteMeta} WriteMeta instance
             */
            WriteMeta.create = function create(properties) {
                return WriteMeta.fromObject(properties);
            };
    
            /**
             * Encodes the specified WriteMeta message. Does not implicitly {@link api.WriteMeta.verify|verify} messages.
             * @function encode
             * @memberof api.WriteMeta
             * @static
             * @param {api.WriteMeta} message WriteMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified WriteMeta message, length delimited. Does not implicitly {@link api.WriteMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.WriteMeta
             * @static
             * @param {api.WriteMeta} message WriteMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a WriteMeta message from the specified reader or buffer.
             * @function decode
             * @memberof api.WriteMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.WriteMeta} WriteMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.WriteMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a WriteMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.WriteMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.WriteMeta} WriteMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a WriteMeta message.
             * @function verify
             * @memberof api.WriteMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };
    
            /**
             * Creates a WriteMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.WriteMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.WriteMeta} WriteMeta
             */
            WriteMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.api.WriteMeta)
                    return object;
                var message = new $root.api.WriteMeta();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };
    
            /**
             * Creates a plain object from a WriteMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.WriteMeta
             * @static
             * @param {api.WriteMeta} message WriteMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };
    
            /**
             * Converts this WriteMeta to JSON.
             * @function toJSON
             * @memberof api.WriteMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return WriteMeta;
        })();
    
        api.AppendMeta = (function() {
    
            /**
             * Properties of an AppendMeta.
             * @memberof api
             * @interface IAppendMeta
             * @property {string|null} [key] AppendMeta key
             * @property {Uint8Array|null} [data] AppendMeta data
             */
    
            /**
             * Constructs a new AppendMeta.
             * @memberof api
             * @classdesc Represents an AppendMeta.
             * @constructor
             * @param {api.IAppendMeta=} [properties] Properties to set
             */
            function AppendMeta(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AppendMeta key.
             * @member {string} key
             * @memberof api.AppendMeta
             * @instance
             */
            AppendMeta.prototype.key = "";
    
            /**
             * AppendMeta data.
             * @member {Uint8Array} data
             * @memberof api.AppendMeta
             * @instance
             */
            AppendMeta.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new AppendMeta instance using the specified properties.
             * @function create
             * @memberof api.AppendMeta
             * @static
             * @param {api.IAppendMeta=} [properties] Properties to set
             * @returns {api.AppendMeta} AppendMeta instance
             */
            AppendMeta.create = function create(properties) {
                return AppendMeta.fromObject(properties);
            };
    
            /**
             * Encodes the specified AppendMeta message. Does not implicitly {@link api.AppendMeta.verify|verify} messages.
             * @function encode
             * @memberof api.AppendMeta
             * @static
             * @param {api.AppendMeta} message AppendMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppendMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified AppendMeta message, length delimited. Does not implicitly {@link api.AppendMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.AppendMeta
             * @static
             * @param {api.AppendMeta} message AppendMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppendMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AppendMeta message from the specified reader or buffer.
             * @function decode
             * @memberof api.AppendMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.AppendMeta} AppendMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppendMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.AppendMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AppendMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.AppendMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.AppendMeta} AppendMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppendMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AppendMeta message.
             * @function verify
             * @memberof api.AppendMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppendMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };
    
            /**
             * Creates an AppendMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.AppendMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.AppendMeta} AppendMeta
             */
            AppendMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.api.AppendMeta)
                    return object;
                var message = new $root.api.AppendMeta();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };
    
            /**
             * Creates a plain object from an AppendMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.AppendMeta
             * @static
             * @param {api.AppendMeta} message AppendMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppendMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };
    
            /**
             * Converts this AppendMeta to JSON.
             * @function toJSON
             * @memberof api.AppendMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppendMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AppendMeta;
        })();
    
        api.BootStatus = (function() {
    
            /**
             * Properties of a BootStatus.
             * @memberof api
             * @interface IBootStatus
             * @property {api.BootStatus.Stage|null} [stage] BootStatus stage
             * @property {number|null} [progress] BootStatus progress
             * @property {number|null} [total] BootStatus total
             */
    
            /**
             * Constructs a new BootStatus.
             * @memberof api
             * @classdesc Represents a BootStatus.
             * @constructor
             * @param {api.IBootStatus=} [properties] Properties to set
             */
            function BootStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BootStatus stage.
             * @member {api.BootStatus.Stage} stage
             * @memberof api.BootStatus
             * @instance
             */
            BootStatus.prototype.stage = 0;
    
            /**
             * BootStatus progress.
             * @member {number} progress
             * @memberof api.BootStatus
             * @instance
             */
            BootStatus.prototype.progress = 0;
    
            /**
             * BootStatus total.
             * @member {number} total
             * @memberof api.BootStatus
             * @instance
             */
            BootStatus.prototype.total = 0;
    
            /**
             * Creates a new BootStatus instance using the specified properties.
             * @function create
             * @memberof api.BootStatus
             * @static
             * @param {api.IBootStatus=} [properties] Properties to set
             * @returns {api.BootStatus} BootStatus instance
             */
            BootStatus.create = function create(properties) {
                return BootStatus.fromObject(properties);
            };
    
            /**
             * Encodes the specified BootStatus message. Does not implicitly {@link api.BootStatus.verify|verify} messages.
             * @function encode
             * @memberof api.BootStatus
             * @static
             * @param {api.BootStatus} message BootStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BootStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stage);
                if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.progress);
                if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.total);
                return writer;
            };
    
            /**
             * Encodes the specified BootStatus message, length delimited. Does not implicitly {@link api.BootStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.BootStatus
             * @static
             * @param {api.BootStatus} message BootStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BootStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BootStatus message from the specified reader or buffer.
             * @function decode
             * @memberof api.BootStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.BootStatus} BootStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BootStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.BootStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stage = reader.int32();
                        break;
                    case 2:
                        message.progress = reader.uint32();
                        break;
                    case 3:
                        message.total = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BootStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.BootStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.BootStatus} BootStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BootStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BootStatus message.
             * @function verify
             * @memberof api.BootStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BootStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stage != null && message.hasOwnProperty("stage"))
                    switch (message.stage) {
                    default:
                        return "stage: enum value expected";
                    case 0:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (!$util.isInteger(message.progress))
                        return "progress: integer expected";
                if (message.total != null && message.hasOwnProperty("total"))
                    if (!$util.isInteger(message.total))
                        return "total: integer expected";
                return null;
            };
    
            /**
             * Creates a BootStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.BootStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.BootStatus} BootStatus
             */
            BootStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.api.BootStatus)
                    return object;
                var message = new $root.api.BootStatus();
                switch (object.stage) {
                case "HANDSHAKE":
                case 0:
                    message.stage = 0;
                    break;
                case "ACQUIRING":
                case 3:
                    message.stage = 3;
                    break;
                case "COMPLETE":
                case 4:
                    message.stage = 4;
                    break;
                case "PROXY":
                case 5:
                    message.stage = 5;
                    break;
                case "PULL_FILES":
                case 6:
                    message.stage = 6;
                    break;
                case "LOAD_BLOCK":
                case 7:
                    message.stage = 7;
                    break;
                case "RETRY":
                case 8:
                    message.stage = 8;
                    break;
                }
                if (object.progress != null)
                    message.progress = object.progress >>> 0;
                if (object.total != null)
                    message.total = object.total >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a BootStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.BootStatus
             * @static
             * @param {api.BootStatus} message BootStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BootStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stage = options.enums === String ? "HANDSHAKE" : 0;
                    object.progress = 0;
                    object.total = 0;
                }
                if (message.stage != null && message.hasOwnProperty("stage"))
                    object.stage = options.enums === String ? $root.api.BootStatus.Stage[message.stage] : message.stage;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = message.progress;
                if (message.total != null && message.hasOwnProperty("total"))
                    object.total = message.total;
                return object;
            };
    
            /**
             * Converts this BootStatus to JSON.
             * @function toJSON
             * @memberof api.BootStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BootStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Stage enum.
             * @name api.BootStatus.Stage
             * @enum {number}
             * @property {number} HANDSHAKE=0 HANDSHAKE value
             * @property {number} ACQUIRING=3 ACQUIRING value
             * @property {number} COMPLETE=4 COMPLETE value
             * @property {number} PROXY=5 PROXY value
             * @property {number} PULL_FILES=6 PULL_FILES value
             * @property {number} LOAD_BLOCK=7 LOAD_BLOCK value
             * @property {number} RETRY=8 RETRY value
             */
            BootStatus.Stage = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "HANDSHAKE"] = 0;
                values[valuesById[3] = "ACQUIRING"] = 3;
                values[valuesById[4] = "COMPLETE"] = 4;
                values[valuesById[5] = "PROXY"] = 5;
                values[valuesById[6] = "PULL_FILES"] = 6;
                values[valuesById[7] = "LOAD_BLOCK"] = 7;
                values[valuesById[8] = "RETRY"] = 8;
                return values;
            })();
    
            return BootStatus;
        })();
    
        api.Pid1Config = (function() {
    
            /**
             * Properties of a Pid1Config.
             * @memberof api
             * @interface IPid1Config
             * @property {string|null} [cwd] Pid1Config cwd
             * @property {string|null} [language] Pid1Config language
             * @property {Object.<string,string>|null} [env] Pid1Config env
             */
    
            /**
             * Constructs a new Pid1Config.
             * @memberof api
             * @classdesc Represents a Pid1Config.
             * @constructor
             * @param {api.IPid1Config=} [properties] Properties to set
             */
            function Pid1Config(properties) {
                this.env = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Pid1Config cwd.
             * @member {string} cwd
             * @memberof api.Pid1Config
             * @instance
             */
            Pid1Config.prototype.cwd = "";
    
            /**
             * Pid1Config language.
             * @member {string} language
             * @memberof api.Pid1Config
             * @instance
             */
            Pid1Config.prototype.language = "";
    
            /**
             * Pid1Config env.
             * @member {Object.<string,string>} env
             * @memberof api.Pid1Config
             * @instance
             */
            Pid1Config.prototype.env = $util.emptyObject;
    
            /**
             * Creates a new Pid1Config instance using the specified properties.
             * @function create
             * @memberof api.Pid1Config
             * @static
             * @param {api.IPid1Config=} [properties] Properties to set
             * @returns {api.Pid1Config} Pid1Config instance
             */
            Pid1Config.create = function create(properties) {
                return Pid1Config.fromObject(properties);
            };
    
            /**
             * Encodes the specified Pid1Config message. Does not implicitly {@link api.Pid1Config.verify|verify} messages.
             * @function encode
             * @memberof api.Pid1Config
             * @static
             * @param {api.Pid1Config} message Pid1Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pid1Config.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cwd != null && Object.hasOwnProperty.call(message, "cwd"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cwd);
                if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.language);
                if (message.env != null && Object.hasOwnProperty.call(message, "env"))
                    for (var keys = Object.keys(message.env), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.env[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Pid1Config message, length delimited. Does not implicitly {@link api.Pid1Config.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Pid1Config
             * @static
             * @param {api.Pid1Config} message Pid1Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pid1Config.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Pid1Config message from the specified reader or buffer.
             * @function decode
             * @memberof api.Pid1Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Pid1Config} Pid1Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pid1Config.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Pid1Config(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cwd = reader.string();
                        break;
                    case 2:
                        message.language = reader.string();
                        break;
                    case 3:
                        if (message.env === $util.emptyObject)
                            message.env = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.env[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Pid1Config message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Pid1Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Pid1Config} Pid1Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pid1Config.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Pid1Config message.
             * @function verify
             * @memberof api.Pid1Config
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pid1Config.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cwd != null && message.hasOwnProperty("cwd"))
                    if (!$util.isString(message.cwd))
                        return "cwd: string expected";
                if (message.language != null && message.hasOwnProperty("language"))
                    if (!$util.isString(message.language))
                        return "language: string expected";
                if (message.env != null && message.hasOwnProperty("env")) {
                    if (!$util.isObject(message.env))
                        return "env: object expected";
                    var key = Object.keys(message.env);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.env[key[i]]))
                            return "env: string{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a Pid1Config message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Pid1Config
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Pid1Config} Pid1Config
             */
            Pid1Config.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Pid1Config)
                    return object;
                var message = new $root.api.Pid1Config();
                if (object.cwd != null)
                    message.cwd = String(object.cwd);
                if (object.language != null)
                    message.language = String(object.language);
                if (object.env) {
                    if (typeof object.env !== "object")
                        throw TypeError(".api.Pid1Config.env: object expected");
                    message.env = {};
                    for (var keys = Object.keys(object.env), i = 0; i < keys.length; ++i)
                        message.env[keys[i]] = String(object.env[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Pid1Config message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Pid1Config
             * @static
             * @param {api.Pid1Config} message Pid1Config
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pid1Config.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.env = {};
                if (options.defaults) {
                    object.cwd = "";
                    object.language = "";
                }
                if (message.cwd != null && message.hasOwnProperty("cwd"))
                    object.cwd = message.cwd;
                if (message.language != null && message.hasOwnProperty("language"))
                    object.language = message.language;
                var keys2;
                if (message.env && (keys2 = Object.keys(message.env)).length) {
                    object.env = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.env[keys2[j]] = message.env[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this Pid1Config to JSON.
             * @function toJSON
             * @memberof api.Pid1Config
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pid1Config.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Pid1Config;
        })();
    
        api.FSLock = (function() {
    
            /**
             * Properties of a FSLock.
             * @memberof api
             * @interface IFSLock
             * @property {string|null} [name] FSLock name
             */
    
            /**
             * Constructs a new FSLock.
             * @memberof api
             * @classdesc Represents a FSLock.
             * @constructor
             * @param {api.IFSLock=} [properties] Properties to set
             */
            function FSLock(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FSLock name.
             * @member {string} name
             * @memberof api.FSLock
             * @instance
             */
            FSLock.prototype.name = "";
    
            /**
             * Creates a new FSLock instance using the specified properties.
             * @function create
             * @memberof api.FSLock
             * @static
             * @param {api.IFSLock=} [properties] Properties to set
             * @returns {api.FSLock} FSLock instance
             */
            FSLock.create = function create(properties) {
                return FSLock.fromObject(properties);
            };
    
            /**
             * Encodes the specified FSLock message. Does not implicitly {@link api.FSLock.verify|verify} messages.
             * @function encode
             * @memberof api.FSLock
             * @static
             * @param {api.FSLock} message FSLock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FSLock.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified FSLock message, length delimited. Does not implicitly {@link api.FSLock.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.FSLock
             * @static
             * @param {api.FSLock} message FSLock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FSLock.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FSLock message from the specified reader or buffer.
             * @function decode
             * @memberof api.FSLock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.FSLock} FSLock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FSLock.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.FSLock();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FSLock message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.FSLock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.FSLock} FSLock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FSLock.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FSLock message.
             * @function verify
             * @memberof api.FSLock
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FSLock.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a FSLock message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.FSLock
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.FSLock} FSLock
             */
            FSLock.fromObject = function fromObject(object) {
                if (object instanceof $root.api.FSLock)
                    return object;
                var message = new $root.api.FSLock();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a FSLock message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.FSLock
             * @static
             * @param {api.FSLock} message FSLock
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FSLock.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this FSLock to JSON.
             * @function toJSON
             * @memberof api.FSLock
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FSLock.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FSLock;
        })();
    
        api.FSSnapshot = (function() {
    
            /**
             * Properties of a FSSnapshot.
             * @memberof api
             * @interface IFSSnapshot
             */
    
            /**
             * Constructs a new FSSnapshot.
             * @memberof api
             * @classdesc Represents a FSSnapshot.
             * @constructor
             * @param {api.IFSSnapshot=} [properties] Properties to set
             */
            function FSSnapshot(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new FSSnapshot instance using the specified properties.
             * @function create
             * @memberof api.FSSnapshot
             * @static
             * @param {api.IFSSnapshot=} [properties] Properties to set
             * @returns {api.FSSnapshot} FSSnapshot instance
             */
            FSSnapshot.create = function create(properties) {
                return FSSnapshot.fromObject(properties);
            };
    
            /**
             * Encodes the specified FSSnapshot message. Does not implicitly {@link api.FSSnapshot.verify|verify} messages.
             * @function encode
             * @memberof api.FSSnapshot
             * @static
             * @param {api.FSSnapshot} message FSSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FSSnapshot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified FSSnapshot message, length delimited. Does not implicitly {@link api.FSSnapshot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.FSSnapshot
             * @static
             * @param {api.FSSnapshot} message FSSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FSSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FSSnapshot message from the specified reader or buffer.
             * @function decode
             * @memberof api.FSSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.FSSnapshot} FSSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FSSnapshot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.FSSnapshot();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FSSnapshot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.FSSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.FSSnapshot} FSSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FSSnapshot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FSSnapshot message.
             * @function verify
             * @memberof api.FSSnapshot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FSSnapshot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a FSSnapshot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.FSSnapshot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.FSSnapshot} FSSnapshot
             */
            FSSnapshot.fromObject = function fromObject(object) {
                if (object instanceof $root.api.FSSnapshot)
                    return object;
                return new $root.api.FSSnapshot();
            };
    
            /**
             * Creates a plain object from a FSSnapshot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.FSSnapshot
             * @static
             * @param {api.FSSnapshot} message FSSnapshot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FSSnapshot.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this FSSnapshot to JSON.
             * @function toJSON
             * @memberof api.FSSnapshot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FSSnapshot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FSSnapshot;
        })();
    
        api.SubscribeFile = (function() {
    
            /**
             * Properties of a SubscribeFile.
             * @memberof api
             * @interface ISubscribeFile
             * @property {Array.<api.File|api.IFile>|null} [files] SubscribeFile files
             */
    
            /**
             * Constructs a new SubscribeFile.
             * @memberof api
             * @classdesc Represents a SubscribeFile.
             * @constructor
             * @param {api.ISubscribeFile=} [properties] Properties to set
             */
            function SubscribeFile(properties) {
                this.files = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SubscribeFile files.
             * @member {Array.<api.File>} files
             * @memberof api.SubscribeFile
             * @instance
             */
            SubscribeFile.prototype.files = $util.emptyArray;
    
            /**
             * Creates a new SubscribeFile instance using the specified properties.
             * @function create
             * @memberof api.SubscribeFile
             * @static
             * @param {api.ISubscribeFile=} [properties] Properties to set
             * @returns {api.SubscribeFile} SubscribeFile instance
             */
            SubscribeFile.create = function create(properties) {
                return SubscribeFile.fromObject(properties);
            };
    
            /**
             * Encodes the specified SubscribeFile message. Does not implicitly {@link api.SubscribeFile.verify|verify} messages.
             * @function encode
             * @memberof api.SubscribeFile
             * @static
             * @param {api.SubscribeFile} message SubscribeFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubscribeFile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        $root.api.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SubscribeFile message, length delimited. Does not implicitly {@link api.SubscribeFile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.SubscribeFile
             * @static
             * @param {api.SubscribeFile} message SubscribeFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubscribeFile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SubscribeFile message from the specified reader or buffer.
             * @function decode
             * @memberof api.SubscribeFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.SubscribeFile} SubscribeFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubscribeFile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SubscribeFile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.files && message.files.length))
                            message.files = [];
                        message.files.push($root.api.File.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SubscribeFile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.SubscribeFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.SubscribeFile} SubscribeFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubscribeFile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SubscribeFile message.
             * @function verify
             * @memberof api.SubscribeFile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubscribeFile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i) {
                        var error = $root.api.File.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SubscribeFile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.SubscribeFile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.SubscribeFile} SubscribeFile
             */
            SubscribeFile.fromObject = function fromObject(object) {
                if (object instanceof $root.api.SubscribeFile)
                    return object;
                var message = new $root.api.SubscribeFile();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".api.SubscribeFile.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".api.SubscribeFile.files: object expected");
                        message.files[i] = $root.api.File.fromObject(object.files[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SubscribeFile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.SubscribeFile
             * @static
             * @param {api.SubscribeFile} message SubscribeFile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubscribeFile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.files = [];
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.api.File.toObject(message.files[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SubscribeFile to JSON.
             * @function toJSON
             * @memberof api.SubscribeFile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubscribeFile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SubscribeFile;
        })();
    
        api.FileEvent = (function() {
    
            /**
             * Properties of a FileEvent.
             * @memberof api
             * @interface IFileEvent
             * @property {api.File|api.IFile|null} [file] FileEvent file
             * @property {api.File|api.IFile|null} [dest] FileEvent dest
             * @property {api.FileEvent.Op|null} [op] FileEvent op
             */
    
            /**
             * Constructs a new FileEvent.
             * @memberof api
             * @classdesc Represents a FileEvent.
             * @constructor
             * @param {api.IFileEvent=} [properties] Properties to set
             */
            function FileEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FileEvent file.
             * @member {api.File|null|undefined} file
             * @memberof api.FileEvent
             * @instance
             */
            FileEvent.prototype.file = null;
    
            /**
             * FileEvent dest.
             * @member {api.File|null|undefined} dest
             * @memberof api.FileEvent
             * @instance
             */
            FileEvent.prototype.dest = null;
    
            /**
             * FileEvent op.
             * @member {api.FileEvent.Op} op
             * @memberof api.FileEvent
             * @instance
             */
            FileEvent.prototype.op = 0;
    
            /**
             * Creates a new FileEvent instance using the specified properties.
             * @function create
             * @memberof api.FileEvent
             * @static
             * @param {api.IFileEvent=} [properties] Properties to set
             * @returns {api.FileEvent} FileEvent instance
             */
            FileEvent.create = function create(properties) {
                return FileEvent.fromObject(properties);
            };
    
            /**
             * Encodes the specified FileEvent message. Does not implicitly {@link api.FileEvent.verify|verify} messages.
             * @function encode
             * @memberof api.FileEvent
             * @static
             * @param {api.FileEvent} message FileEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.api.File.encode(message.file, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.op != null && Object.hasOwnProperty.call(message, "op"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.op);
                if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                    $root.api.File.encode(message.dest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FileEvent message, length delimited. Does not implicitly {@link api.FileEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.FileEvent
             * @static
             * @param {api.FileEvent} message FileEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FileEvent message from the specified reader or buffer.
             * @function decode
             * @memberof api.FileEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.FileEvent} FileEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.FileEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.file = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.dest = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.op = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FileEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.FileEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.FileEvent} FileEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FileEvent message.
             * @function verify
             * @memberof api.FileEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    var error = $root.api.File.verify(message.file);
                    if (error)
                        return "file." + error;
                }
                if (message.dest != null && message.hasOwnProperty("dest")) {
                    var error = $root.api.File.verify(message.dest);
                    if (error)
                        return "dest." + error;
                }
                if (message.op != null && message.hasOwnProperty("op"))
                    switch (message.op) {
                    default:
                        return "op: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a FileEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.FileEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.FileEvent} FileEvent
             */
            FileEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.api.FileEvent)
                    return object;
                var message = new $root.api.FileEvent();
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".api.FileEvent.file: object expected");
                    message.file = $root.api.File.fromObject(object.file);
                }
                if (object.dest != null) {
                    if (typeof object.dest !== "object")
                        throw TypeError(".api.FileEvent.dest: object expected");
                    message.dest = $root.api.File.fromObject(object.dest);
                }
                switch (object.op) {
                case "Create":
                case 0:
                    message.op = 0;
                    break;
                case "Move":
                case 1:
                    message.op = 1;
                    break;
                case "Remove":
                case 2:
                    message.op = 2;
                    break;
                case "Modify":
                case 3:
                    message.op = 3;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FileEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.FileEvent
             * @static
             * @param {api.FileEvent} message FileEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.file = null;
                    object.op = options.enums === String ? "Create" : 0;
                    object.dest = null;
                }
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = $root.api.File.toObject(message.file, options);
                if (message.op != null && message.hasOwnProperty("op"))
                    object.op = options.enums === String ? $root.api.FileEvent.Op[message.op] : message.op;
                if (message.dest != null && message.hasOwnProperty("dest"))
                    object.dest = $root.api.File.toObject(message.dest, options);
                return object;
            };
    
            /**
             * Converts this FileEvent to JSON.
             * @function toJSON
             * @memberof api.FileEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Op enum.
             * @name api.FileEvent.Op
             * @enum {number}
             * @property {number} Create=0 Create value
             * @property {number} Move=1 Move value
             * @property {number} Remove=2 Remove value
             * @property {number} Modify=3 Modify value
             */
            FileEvent.Op = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Create"] = 0;
                values[valuesById[1] = "Move"] = 1;
                values[valuesById[2] = "Remove"] = 2;
                values[valuesById[3] = "Modify"] = 3;
                return values;
            })();
    
            return FileEvent;
        })();
    
        api.Flush = (function() {
    
            /**
             * Properties of a Flush.
             * @memberof api
             * @interface IFlush
             */
    
            /**
             * Constructs a new Flush.
             * @memberof api
             * @classdesc Represents a Flush.
             * @constructor
             * @param {api.IFlush=} [properties] Properties to set
             */
            function Flush(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Flush instance using the specified properties.
             * @function create
             * @memberof api.Flush
             * @static
             * @param {api.IFlush=} [properties] Properties to set
             * @returns {api.Flush} Flush instance
             */
            Flush.create = function create(properties) {
                return Flush.fromObject(properties);
            };
    
            /**
             * Encodes the specified Flush message. Does not implicitly {@link api.Flush.verify|verify} messages.
             * @function encode
             * @memberof api.Flush
             * @static
             * @param {api.Flush} message Flush message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Flush.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Flush message, length delimited. Does not implicitly {@link api.Flush.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Flush
             * @static
             * @param {api.Flush} message Flush message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Flush.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Flush message from the specified reader or buffer.
             * @function decode
             * @memberof api.Flush
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Flush} Flush
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Flush.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Flush();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Flush message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Flush
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Flush} Flush
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Flush.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Flush message.
             * @function verify
             * @memberof api.Flush
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Flush.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Flush message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Flush
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Flush} Flush
             */
            Flush.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Flush)
                    return object;
                return new $root.api.Flush();
            };
    
            /**
             * Creates a plain object from a Flush message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Flush
             * @static
             * @param {api.Flush} message Flush
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Flush.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Flush to JSON.
             * @function toJSON
             * @memberof api.Flush
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Flush.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Flush;
        })();
    
        api.OTLinkFile = (function() {
    
            /**
             * Properties of a OTLinkFile.
             * @memberof api
             * @interface IOTLinkFile
             * @property {api.File|api.IFile|null} [file] OTLinkFile file
             * @property {boolean|null} [highConsistency] OTLinkFile highConsistency
             * @property {boolean|null} [OBSOLETEUseModTime] OTLinkFile OBSOLETEUseModTime
             */
    
            /**
             * Constructs a new OTLinkFile.
             * @memberof api
             * @classdesc Represents a OTLinkFile.
             * @constructor
             * @param {api.IOTLinkFile=} [properties] Properties to set
             */
            function OTLinkFile(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTLinkFile file.
             * @member {api.File|null|undefined} file
             * @memberof api.OTLinkFile
             * @instance
             */
            OTLinkFile.prototype.file = null;
    
            /**
             * OTLinkFile highConsistency.
             * @member {boolean} highConsistency
             * @memberof api.OTLinkFile
             * @instance
             */
            OTLinkFile.prototype.highConsistency = false;
    
            /**
             * OTLinkFile OBSOLETEUseModTime.
             * @member {boolean} OBSOLETEUseModTime
             * @memberof api.OTLinkFile
             * @instance
             */
            OTLinkFile.prototype.OBSOLETEUseModTime = false;
    
            /**
             * Creates a new OTLinkFile instance using the specified properties.
             * @function create
             * @memberof api.OTLinkFile
             * @static
             * @param {api.IOTLinkFile=} [properties] Properties to set
             * @returns {api.OTLinkFile} OTLinkFile instance
             */
            OTLinkFile.create = function create(properties) {
                return OTLinkFile.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTLinkFile message. Does not implicitly {@link api.OTLinkFile.verify|verify} messages.
             * @function encode
             * @memberof api.OTLinkFile
             * @static
             * @param {api.OTLinkFile} message OTLinkFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTLinkFile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.api.File.encode(message.file, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.highConsistency != null && Object.hasOwnProperty.call(message, "highConsistency"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.highConsistency);
                if (message.OBSOLETEUseModTime != null && Object.hasOwnProperty.call(message, "OBSOLETEUseModTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.OBSOLETEUseModTime);
                return writer;
            };
    
            /**
             * Encodes the specified OTLinkFile message, length delimited. Does not implicitly {@link api.OTLinkFile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTLinkFile
             * @static
             * @param {api.OTLinkFile} message OTLinkFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTLinkFile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTLinkFile message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTLinkFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTLinkFile} OTLinkFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTLinkFile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTLinkFile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.file = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.highConsistency = reader.bool();
                        break;
                    case 3:
                        message.OBSOLETEUseModTime = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTLinkFile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTLinkFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTLinkFile} OTLinkFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTLinkFile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTLinkFile message.
             * @function verify
             * @memberof api.OTLinkFile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTLinkFile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    var error = $root.api.File.verify(message.file);
                    if (error)
                        return "file." + error;
                }
                if (message.highConsistency != null && message.hasOwnProperty("highConsistency"))
                    if (typeof message.highConsistency !== "boolean")
                        return "highConsistency: boolean expected";
                if (message.OBSOLETEUseModTime != null && message.hasOwnProperty("OBSOLETEUseModTime"))
                    if (typeof message.OBSOLETEUseModTime !== "boolean")
                        return "OBSOLETEUseModTime: boolean expected";
                return null;
            };
    
            /**
             * Creates a OTLinkFile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTLinkFile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTLinkFile} OTLinkFile
             */
            OTLinkFile.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTLinkFile)
                    return object;
                var message = new $root.api.OTLinkFile();
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".api.OTLinkFile.file: object expected");
                    message.file = $root.api.File.fromObject(object.file);
                }
                if (object.highConsistency != null)
                    message.highConsistency = Boolean(object.highConsistency);
                if (object.OBSOLETEUseModTime != null)
                    message.OBSOLETEUseModTime = Boolean(object.OBSOLETEUseModTime);
                return message;
            };
    
            /**
             * Creates a plain object from a OTLinkFile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTLinkFile
             * @static
             * @param {api.OTLinkFile} message OTLinkFile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTLinkFile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.file = null;
                    object.highConsistency = false;
                    object.OBSOLETEUseModTime = false;
                }
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = $root.api.File.toObject(message.file, options);
                if (message.highConsistency != null && message.hasOwnProperty("highConsistency"))
                    object.highConsistency = message.highConsistency;
                if (message.OBSOLETEUseModTime != null && message.hasOwnProperty("OBSOLETEUseModTime"))
                    object.OBSOLETEUseModTime = message.OBSOLETEUseModTime;
                return object;
            };
    
            /**
             * Converts this OTLinkFile to JSON.
             * @function toJSON
             * @memberof api.OTLinkFile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTLinkFile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTLinkFile;
        })();
    
        api.Auth = (function() {
    
            /**
             * Properties of an Auth.
             * @memberof api
             * @interface IAuth
             * @property {string|null} [token] Auth token
             * @property {string|null} [containerID] Auth containerID
             */
    
            /**
             * Constructs a new Auth.
             * @memberof api
             * @classdesc Represents an Auth.
             * @constructor
             * @param {api.IAuth=} [properties] Properties to set
             */
            function Auth(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Auth token.
             * @member {string} token
             * @memberof api.Auth
             * @instance
             */
            Auth.prototype.token = "";
    
            /**
             * Auth containerID.
             * @member {string} containerID
             * @memberof api.Auth
             * @instance
             */
            Auth.prototype.containerID = "";
    
            /**
             * Creates a new Auth instance using the specified properties.
             * @function create
             * @memberof api.Auth
             * @static
             * @param {api.IAuth=} [properties] Properties to set
             * @returns {api.Auth} Auth instance
             */
            Auth.create = function create(properties) {
                return Auth.fromObject(properties);
            };
    
            /**
             * Encodes the specified Auth message. Does not implicitly {@link api.Auth.verify|verify} messages.
             * @function encode
             * @memberof api.Auth
             * @static
             * @param {api.Auth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                if (message.containerID != null && Object.hasOwnProperty.call(message, "containerID"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.containerID);
                return writer;
            };
    
            /**
             * Encodes the specified Auth message, length delimited. Does not implicitly {@link api.Auth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Auth
             * @static
             * @param {api.Auth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Auth message from the specified reader or buffer.
             * @function decode
             * @memberof api.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Auth();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    case 2:
                        message.containerID = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Auth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Auth message.
             * @function verify
             * @memberof api.Auth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Auth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.containerID != null && message.hasOwnProperty("containerID"))
                    if (!$util.isString(message.containerID))
                        return "containerID: string expected";
                return null;
            };
    
            /**
             * Creates an Auth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Auth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Auth} Auth
             */
            Auth.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Auth)
                    return object;
                var message = new $root.api.Auth();
                if (object.token != null)
                    message.token = String(object.token);
                if (object.containerID != null)
                    message.containerID = String(object.containerID);
                return message;
            };
    
            /**
             * Creates a plain object from an Auth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Auth
             * @static
             * @param {api.Auth} message Auth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Auth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.token = "";
                    object.containerID = "";
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.containerID != null && message.hasOwnProperty("containerID"))
                    object.containerID = message.containerID;
                return object;
            };
    
            /**
             * Converts this Auth to JSON.
             * @function toJSON
             * @memberof api.Auth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Auth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Auth;
        })();
    
        api.VCREntry = (function() {
    
            /**
             * Properties of a VCREntry.
             * @memberof api
             * @interface IVCREntry
             * @property {number|null} [timestamp] VCREntry timestamp
             * @property {api.VCREntry.Direction|null} [direction] VCREntry direction
             * @property {api.Command|api.ICommand|null} [command] VCREntry command
             * @property {string|null} [uid] VCREntry uid
             * @property {string|null} [replid] VCREntry replid
             */
    
            /**
             * Constructs a new VCREntry.
             * @memberof api
             * @classdesc Represents a VCREntry.
             * @constructor
             * @param {api.IVCREntry=} [properties] Properties to set
             */
            function VCREntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * VCREntry timestamp.
             * @member {number} timestamp
             * @memberof api.VCREntry
             * @instance
             */
            VCREntry.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * VCREntry direction.
             * @member {api.VCREntry.Direction} direction
             * @memberof api.VCREntry
             * @instance
             */
            VCREntry.prototype.direction = 0;
    
            /**
             * VCREntry command.
             * @member {api.Command|null|undefined} command
             * @memberof api.VCREntry
             * @instance
             */
            VCREntry.prototype.command = null;
    
            /**
             * VCREntry uid.
             * @member {string} uid
             * @memberof api.VCREntry
             * @instance
             */
            VCREntry.prototype.uid = "";
    
            /**
             * VCREntry replid.
             * @member {string} replid
             * @memberof api.VCREntry
             * @instance
             */
            VCREntry.prototype.replid = "";
    
            /**
             * Creates a new VCREntry instance using the specified properties.
             * @function create
             * @memberof api.VCREntry
             * @static
             * @param {api.IVCREntry=} [properties] Properties to set
             * @returns {api.VCREntry} VCREntry instance
             */
            VCREntry.create = function create(properties) {
                return VCREntry.fromObject(properties);
            };
    
            /**
             * Encodes the specified VCREntry message. Does not implicitly {@link api.VCREntry.verify|verify} messages.
             * @function encode
             * @memberof api.VCREntry
             * @static
             * @param {api.VCREntry} message VCREntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VCREntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.direction);
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.api.Command.encode(message.command, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.uid);
                if (message.replid != null && Object.hasOwnProperty.call(message, "replid"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.replid);
                return writer;
            };
    
            /**
             * Encodes the specified VCREntry message, length delimited. Does not implicitly {@link api.VCREntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.VCREntry
             * @static
             * @param {api.VCREntry} message VCREntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VCREntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a VCREntry message from the specified reader or buffer.
             * @function decode
             * @memberof api.VCREntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.VCREntry} VCREntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VCREntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.VCREntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.uint64();
                        break;
                    case 2:
                        message.direction = reader.int32();
                        break;
                    case 3:
                        message.command = $root.api.Command.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.uid = reader.string();
                        break;
                    case 5:
                        message.replid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a VCREntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.VCREntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.VCREntry} VCREntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VCREntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a VCREntry message.
             * @function verify
             * @memberof api.VCREntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VCREntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    switch (message.direction) {
                    default:
                        return "direction: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.command != null && message.hasOwnProperty("command")) {
                    var error = $root.api.Command.verify(message.command);
                    if (error)
                        return "command." + error;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.replid != null && message.hasOwnProperty("replid"))
                    if (!$util.isString(message.replid))
                        return "replid: string expected";
                return null;
            };
    
            /**
             * Creates a VCREntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.VCREntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.VCREntry} VCREntry
             */
            VCREntry.fromObject = function fromObject(object) {
                if (object instanceof $root.api.VCREntry)
                    return object;
                var message = new $root.api.VCREntry();
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                switch (object.direction) {
                case "IN":
                case 0:
                    message.direction = 0;
                    break;
                case "OUT":
                case 1:
                    message.direction = 1;
                    break;
                }
                if (object.command != null) {
                    if (typeof object.command !== "object")
                        throw TypeError(".api.VCREntry.command: object expected");
                    message.command = $root.api.Command.fromObject(object.command);
                }
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.replid != null)
                    message.replid = String(object.replid);
                return message;
            };
    
            /**
             * Creates a plain object from a VCREntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.VCREntry
             * @static
             * @param {api.VCREntry} message VCREntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VCREntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.direction = options.enums === String ? "IN" : 0;
                    object.command = null;
                    object.uid = "";
                    object.replid = "";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = options.enums === String ? $root.api.VCREntry.Direction[message.direction] : message.direction;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = $root.api.Command.toObject(message.command, options);
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.replid != null && message.hasOwnProperty("replid"))
                    object.replid = message.replid;
                return object;
            };
    
            /**
             * Converts this VCREntry to JSON.
             * @function toJSON
             * @memberof api.VCREntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VCREntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Direction enum.
             * @name api.VCREntry.Direction
             * @enum {number}
             * @property {number} IN=0 IN value
             * @property {number} OUT=1 OUT value
             */
            VCREntry.Direction = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IN"] = 0;
                values[valuesById[1] = "OUT"] = 1;
                return values;
            })();
    
            return VCREntry;
        })();
    
        api.StartVCR = (function() {
    
            /**
             * Properties of a StartVCR.
             * @memberof api
             * @interface IStartVCR
             */
    
            /**
             * Constructs a new StartVCR.
             * @memberof api
             * @classdesc Represents a StartVCR.
             * @constructor
             * @param {api.IStartVCR=} [properties] Properties to set
             */
            function StartVCR(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new StartVCR instance using the specified properties.
             * @function create
             * @memberof api.StartVCR
             * @static
             * @param {api.IStartVCR=} [properties] Properties to set
             * @returns {api.StartVCR} StartVCR instance
             */
            StartVCR.create = function create(properties) {
                return StartVCR.fromObject(properties);
            };
    
            /**
             * Encodes the specified StartVCR message. Does not implicitly {@link api.StartVCR.verify|verify} messages.
             * @function encode
             * @memberof api.StartVCR
             * @static
             * @param {api.StartVCR} message StartVCR message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartVCR.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified StartVCR message, length delimited. Does not implicitly {@link api.StartVCR.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.StartVCR
             * @static
             * @param {api.StartVCR} message StartVCR message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartVCR.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StartVCR message from the specified reader or buffer.
             * @function decode
             * @memberof api.StartVCR
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.StartVCR} StartVCR
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartVCR.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.StartVCR();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StartVCR message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.StartVCR
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.StartVCR} StartVCR
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartVCR.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StartVCR message.
             * @function verify
             * @memberof api.StartVCR
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartVCR.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a StartVCR message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.StartVCR
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.StartVCR} StartVCR
             */
            StartVCR.fromObject = function fromObject(object) {
                if (object instanceof $root.api.StartVCR)
                    return object;
                return new $root.api.StartVCR();
            };
    
            /**
             * Creates a plain object from a StartVCR message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.StartVCR
             * @static
             * @param {api.StartVCR} message StartVCR
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartVCR.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this StartVCR to JSON.
             * @function toJSON
             * @memberof api.StartVCR
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartVCR.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StartVCR;
        })();
    
        api.ReadVCR = (function() {
    
            /**
             * Properties of a ReadVCR.
             * @memberof api
             * @interface IReadVCR
             */
    
            /**
             * Constructs a new ReadVCR.
             * @memberof api
             * @classdesc Represents a ReadVCR.
             * @constructor
             * @param {api.IReadVCR=} [properties] Properties to set
             */
            function ReadVCR(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ReadVCR instance using the specified properties.
             * @function create
             * @memberof api.ReadVCR
             * @static
             * @param {api.IReadVCR=} [properties] Properties to set
             * @returns {api.ReadVCR} ReadVCR instance
             */
            ReadVCR.create = function create(properties) {
                return ReadVCR.fromObject(properties);
            };
    
            /**
             * Encodes the specified ReadVCR message. Does not implicitly {@link api.ReadVCR.verify|verify} messages.
             * @function encode
             * @memberof api.ReadVCR
             * @static
             * @param {api.ReadVCR} message ReadVCR message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadVCR.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ReadVCR message, length delimited. Does not implicitly {@link api.ReadVCR.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ReadVCR
             * @static
             * @param {api.ReadVCR} message ReadVCR message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadVCR.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ReadVCR message from the specified reader or buffer.
             * @function decode
             * @memberof api.ReadVCR
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ReadVCR} ReadVCR
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadVCR.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ReadVCR();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ReadVCR message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ReadVCR
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ReadVCR} ReadVCR
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadVCR.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ReadVCR message.
             * @function verify
             * @memberof api.ReadVCR
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadVCR.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ReadVCR message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ReadVCR
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ReadVCR} ReadVCR
             */
            ReadVCR.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ReadVCR)
                    return object;
                return new $root.api.ReadVCR();
            };
    
            /**
             * Creates a plain object from a ReadVCR message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ReadVCR
             * @static
             * @param {api.ReadVCR} message ReadVCR
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadVCR.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ReadVCR to JSON.
             * @function toJSON
             * @memberof api.ReadVCR
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadVCR.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ReadVCR;
        })();
    
        api.VCRLog = (function() {
    
            /**
             * Properties of a VCRLog.
             * @memberof api
             * @interface IVCRLog
             * @property {Array.<api.VCREntry|api.IVCREntry>|null} [log] VCRLog log
             * @property {api.File|api.IFile|null} [logfile] VCRLog logfile
             */
    
            /**
             * Constructs a new VCRLog.
             * @memberof api
             * @classdesc Represents a VCRLog.
             * @constructor
             * @param {api.IVCRLog=} [properties] Properties to set
             */
            function VCRLog(properties) {
                this.log = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * VCRLog log.
             * @member {Array.<api.VCREntry>} log
             * @memberof api.VCRLog
             * @instance
             */
            VCRLog.prototype.log = $util.emptyArray;
    
            /**
             * VCRLog logfile.
             * @member {api.File|null|undefined} logfile
             * @memberof api.VCRLog
             * @instance
             */
            VCRLog.prototype.logfile = null;
    
            /**
             * Creates a new VCRLog instance using the specified properties.
             * @function create
             * @memberof api.VCRLog
             * @static
             * @param {api.IVCRLog=} [properties] Properties to set
             * @returns {api.VCRLog} VCRLog instance
             */
            VCRLog.create = function create(properties) {
                return VCRLog.fromObject(properties);
            };
    
            /**
             * Encodes the specified VCRLog message. Does not implicitly {@link api.VCRLog.verify|verify} messages.
             * @function encode
             * @memberof api.VCRLog
             * @static
             * @param {api.VCRLog} message VCRLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VCRLog.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.log != null && message.log.length)
                    for (var i = 0; i < message.log.length; ++i)
                        $root.api.VCREntry.encode(message.log[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.logfile != null && Object.hasOwnProperty.call(message, "logfile"))
                    $root.api.File.encode(message.logfile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified VCRLog message, length delimited. Does not implicitly {@link api.VCRLog.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.VCRLog
             * @static
             * @param {api.VCRLog} message VCRLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VCRLog.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a VCRLog message from the specified reader or buffer.
             * @function decode
             * @memberof api.VCRLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.VCRLog} VCRLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VCRLog.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.VCRLog();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.log && message.log.length))
                            message.log = [];
                        message.log.push($root.api.VCREntry.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.logfile = $root.api.File.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a VCRLog message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.VCRLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.VCRLog} VCRLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VCRLog.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a VCRLog message.
             * @function verify
             * @memberof api.VCRLog
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VCRLog.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.log != null && message.hasOwnProperty("log")) {
                    if (!Array.isArray(message.log))
                        return "log: array expected";
                    for (var i = 0; i < message.log.length; ++i) {
                        var error = $root.api.VCREntry.verify(message.log[i]);
                        if (error)
                            return "log." + error;
                    }
                }
                if (message.logfile != null && message.hasOwnProperty("logfile")) {
                    var error = $root.api.File.verify(message.logfile);
                    if (error)
                        return "logfile." + error;
                }
                return null;
            };
    
            /**
             * Creates a VCRLog message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.VCRLog
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.VCRLog} VCRLog
             */
            VCRLog.fromObject = function fromObject(object) {
                if (object instanceof $root.api.VCRLog)
                    return object;
                var message = new $root.api.VCRLog();
                if (object.log) {
                    if (!Array.isArray(object.log))
                        throw TypeError(".api.VCRLog.log: array expected");
                    message.log = [];
                    for (var i = 0; i < object.log.length; ++i) {
                        if (typeof object.log[i] !== "object")
                            throw TypeError(".api.VCRLog.log: object expected");
                        message.log[i] = $root.api.VCREntry.fromObject(object.log[i]);
                    }
                }
                if (object.logfile != null) {
                    if (typeof object.logfile !== "object")
                        throw TypeError(".api.VCRLog.logfile: object expected");
                    message.logfile = $root.api.File.fromObject(object.logfile);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a VCRLog message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.VCRLog
             * @static
             * @param {api.VCRLog} message VCRLog
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VCRLog.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.log = [];
                if (options.defaults)
                    object.logfile = null;
                if (message.log && message.log.length) {
                    object.log = [];
                    for (var j = 0; j < message.log.length; ++j)
                        object.log[j] = $root.api.VCREntry.toObject(message.log[j], options);
                }
                if (message.logfile != null && message.hasOwnProperty("logfile"))
                    object.logfile = $root.api.File.toObject(message.logfile, options);
                return object;
            };
    
            /**
             * Converts this VCRLog to JSON.
             * @function toJSON
             * @memberof api.VCRLog
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VCRLog.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return VCRLog;
        })();
    
        api.ExecInfo = (function() {
    
            /**
             * Properties of an ExecInfo.
             * @memberof api
             * @interface IExecInfo
             * @property {Array.<string>|null} [command] ExecInfo command
             * @property {string|null} [reason] ExecInfo reason
             */
    
            /**
             * Constructs a new ExecInfo.
             * @memberof api
             * @classdesc Represents an ExecInfo.
             * @constructor
             * @param {api.IExecInfo=} [properties] Properties to set
             */
            function ExecInfo(properties) {
                this.command = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ExecInfo command.
             * @member {Array.<string>} command
             * @memberof api.ExecInfo
             * @instance
             */
            ExecInfo.prototype.command = $util.emptyArray;
    
            /**
             * ExecInfo reason.
             * @member {string} reason
             * @memberof api.ExecInfo
             * @instance
             */
            ExecInfo.prototype.reason = "";
    
            /**
             * Creates a new ExecInfo instance using the specified properties.
             * @function create
             * @memberof api.ExecInfo
             * @static
             * @param {api.IExecInfo=} [properties] Properties to set
             * @returns {api.ExecInfo} ExecInfo instance
             */
            ExecInfo.create = function create(properties) {
                return ExecInfo.fromObject(properties);
            };
    
            /**
             * Encodes the specified ExecInfo message. Does not implicitly {@link api.ExecInfo.verify|verify} messages.
             * @function encode
             * @memberof api.ExecInfo
             * @static
             * @param {api.ExecInfo} message ExecInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && message.command.length)
                    for (var i = 0; i < message.command.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command[i]);
                if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
                return writer;
            };
    
            /**
             * Encodes the specified ExecInfo message, length delimited. Does not implicitly {@link api.ExecInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ExecInfo
             * @static
             * @param {api.ExecInfo} message ExecInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ExecInfo message from the specified reader or buffer.
             * @function decode
             * @memberof api.ExecInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ExecInfo} ExecInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExecInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.command && message.command.length))
                            message.command = [];
                        message.command.push(reader.string());
                        break;
                    case 2:
                        message.reason = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ExecInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ExecInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ExecInfo} ExecInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ExecInfo message.
             * @function verify
             * @memberof api.ExecInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.command != null && message.hasOwnProperty("command")) {
                    if (!Array.isArray(message.command))
                        return "command: array expected";
                    for (var i = 0; i < message.command.length; ++i)
                        if (!$util.isString(message.command[i]))
                            return "command: string[] expected";
                }
                if (message.reason != null && message.hasOwnProperty("reason"))
                    if (!$util.isString(message.reason))
                        return "reason: string expected";
                return null;
            };
    
            /**
             * Creates an ExecInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ExecInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ExecInfo} ExecInfo
             */
            ExecInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ExecInfo)
                    return object;
                var message = new $root.api.ExecInfo();
                if (object.command) {
                    if (!Array.isArray(object.command))
                        throw TypeError(".api.ExecInfo.command: array expected");
                    message.command = [];
                    for (var i = 0; i < object.command.length; ++i)
                        message.command[i] = String(object.command[i]);
                }
                if (object.reason != null)
                    message.reason = String(object.reason);
                return message;
            };
    
            /**
             * Creates a plain object from an ExecInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ExecInfo
             * @static
             * @param {api.ExecInfo} message ExecInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.command = [];
                if (options.defaults)
                    object.reason = "";
                if (message.command && message.command.length) {
                    object.command = [];
                    for (var j = 0; j < message.command.length; ++j)
                        object.command[j] = message.command[j];
                }
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = message.reason;
                return object;
            };
    
            /**
             * Converts this ExecInfo to JSON.
             * @function toJSON
             * @memberof api.ExecInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ExecInfo;
        })();
    
        api.Debug = (function() {
    
            /**
             * Properties of a Debug.
             * @memberof api
             * @interface IDebug
             * @property {string|null} [text] Debug text
             */
    
            /**
             * Constructs a new Debug.
             * @memberof api
             * @classdesc Represents a Debug.
             * @constructor
             * @param {api.IDebug=} [properties] Properties to set
             */
            function Debug(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Debug text.
             * @member {string} text
             * @memberof api.Debug
             * @instance
             */
            Debug.prototype.text = "";
    
            /**
             * Creates a new Debug instance using the specified properties.
             * @function create
             * @memberof api.Debug
             * @static
             * @param {api.IDebug=} [properties] Properties to set
             * @returns {api.Debug} Debug instance
             */
            Debug.create = function create(properties) {
                return Debug.fromObject(properties);
            };
    
            /**
             * Encodes the specified Debug message. Does not implicitly {@link api.Debug.verify|verify} messages.
             * @function encode
             * @memberof api.Debug
             * @static
             * @param {api.Debug} message Debug message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Debug.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };
    
            /**
             * Encodes the specified Debug message, length delimited. Does not implicitly {@link api.Debug.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Debug
             * @static
             * @param {api.Debug} message Debug message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Debug.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Debug message from the specified reader or buffer.
             * @function decode
             * @memberof api.Debug
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Debug} Debug
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Debug.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Debug();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.text = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Debug message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Debug
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Debug} Debug
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Debug.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Debug message.
             * @function verify
             * @memberof api.Debug
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Debug.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };
    
            /**
             * Creates a Debug message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Debug
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Debug} Debug
             */
            Debug.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Debug)
                    return object;
                var message = new $root.api.Debug();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };
    
            /**
             * Creates a plain object from a Debug message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Debug
             * @static
             * @param {api.Debug} message Debug
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Debug.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };
    
            /**
             * Converts this Debug to JSON.
             * @function toJSON
             * @memberof api.Debug
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Debug.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Debug;
        })();
    
        /**
         * FileAuthMethod enum.
         * @name api.FileAuthMethod
         * @enum {number}
         * @property {number} GET=0 GET value
         * @property {number} HEAD=1 HEAD value
         * @property {number} PUT=2 PUT value
         * @property {number} DELETE=3 DELETE value
         */
        api.FileAuthMethod = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GET"] = 0;
            values[valuesById[1] = "HEAD"] = 1;
            values[valuesById[2] = "PUT"] = 2;
            values[valuesById[3] = "DELETE"] = 3;
            return values;
        })();
    
        api.FileAuthReq = (function() {
    
            /**
             * Properties of a FileAuthReq.
             * @memberof api
             * @interface IFileAuthReq
             * @property {api.File|api.IFile|null} [file] FileAuthReq file
             * @property {api.FileAuthMethod|null} [method] FileAuthReq method
             */
    
            /**
             * Constructs a new FileAuthReq.
             * @memberof api
             * @classdesc Represents a FileAuthReq.
             * @constructor
             * @param {api.IFileAuthReq=} [properties] Properties to set
             */
            function FileAuthReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FileAuthReq file.
             * @member {api.File|null|undefined} file
             * @memberof api.FileAuthReq
             * @instance
             */
            FileAuthReq.prototype.file = null;
    
            /**
             * FileAuthReq method.
             * @member {api.FileAuthMethod} method
             * @memberof api.FileAuthReq
             * @instance
             */
            FileAuthReq.prototype.method = 0;
    
            /**
             * Creates a new FileAuthReq instance using the specified properties.
             * @function create
             * @memberof api.FileAuthReq
             * @static
             * @param {api.IFileAuthReq=} [properties] Properties to set
             * @returns {api.FileAuthReq} FileAuthReq instance
             */
            FileAuthReq.create = function create(properties) {
                return FileAuthReq.fromObject(properties);
            };
    
            /**
             * Encodes the specified FileAuthReq message. Does not implicitly {@link api.FileAuthReq.verify|verify} messages.
             * @function encode
             * @memberof api.FileAuthReq
             * @static
             * @param {api.FileAuthReq} message FileAuthReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileAuthReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.api.File.encode(message.file, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                return writer;
            };
    
            /**
             * Encodes the specified FileAuthReq message, length delimited. Does not implicitly {@link api.FileAuthReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.FileAuthReq
             * @static
             * @param {api.FileAuthReq} message FileAuthReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileAuthReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FileAuthReq message from the specified reader or buffer.
             * @function decode
             * @memberof api.FileAuthReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.FileAuthReq} FileAuthReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileAuthReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.FileAuthReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.file = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.method = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FileAuthReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.FileAuthReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.FileAuthReq} FileAuthReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileAuthReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FileAuthReq message.
             * @function verify
             * @memberof api.FileAuthReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileAuthReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    var error = $root.api.File.verify(message.file);
                    if (error)
                        return "file." + error;
                }
                if (message.method != null && message.hasOwnProperty("method"))
                    switch (message.method) {
                    default:
                        return "method: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a FileAuthReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.FileAuthReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.FileAuthReq} FileAuthReq
             */
            FileAuthReq.fromObject = function fromObject(object) {
                if (object instanceof $root.api.FileAuthReq)
                    return object;
                var message = new $root.api.FileAuthReq();
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".api.FileAuthReq.file: object expected");
                    message.file = $root.api.File.fromObject(object.file);
                }
                switch (object.method) {
                case "GET":
                case 0:
                    message.method = 0;
                    break;
                case "HEAD":
                case 1:
                    message.method = 1;
                    break;
                case "PUT":
                case 2:
                    message.method = 2;
                    break;
                case "DELETE":
                case 3:
                    message.method = 3;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FileAuthReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.FileAuthReq
             * @static
             * @param {api.FileAuthReq} message FileAuthReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileAuthReq.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.file = null;
                    object.method = options.enums === String ? "GET" : 0;
                }
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = $root.api.File.toObject(message.file, options);
                if (message.method != null && message.hasOwnProperty("method"))
                    object.method = options.enums === String ? $root.api.FileAuthMethod[message.method] : message.method;
                return object;
            };
    
            /**
             * Converts this FileAuthReq to JSON.
             * @function toJSON
             * @memberof api.FileAuthReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileAuthReq.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FileAuthReq;
        })();
    
        api.MultiFileAuthRes = (function() {
    
            /**
             * Properties of a MultiFileAuthRes.
             * @memberof api
             * @interface IMultiFileAuthRes
             * @property {api.FileAuthRes|api.IFileAuthRes|null} [put] MultiFileAuthRes put
             * @property {api.FileAuthRes|api.IFileAuthRes|null} [del] MultiFileAuthRes del
             * @property {api.FileAuthRes|api.IFileAuthRes|null} [get] MultiFileAuthRes get
             */
    
            /**
             * Constructs a new MultiFileAuthRes.
             * @memberof api
             * @classdesc Represents a MultiFileAuthRes.
             * @constructor
             * @param {api.IMultiFileAuthRes=} [properties] Properties to set
             */
            function MultiFileAuthRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MultiFileAuthRes put.
             * @member {api.FileAuthRes|null|undefined} put
             * @memberof api.MultiFileAuthRes
             * @instance
             */
            MultiFileAuthRes.prototype.put = null;
    
            /**
             * MultiFileAuthRes del.
             * @member {api.FileAuthRes|null|undefined} del
             * @memberof api.MultiFileAuthRes
             * @instance
             */
            MultiFileAuthRes.prototype.del = null;
    
            /**
             * MultiFileAuthRes get.
             * @member {api.FileAuthRes|null|undefined} get
             * @memberof api.MultiFileAuthRes
             * @instance
             */
            MultiFileAuthRes.prototype.get = null;
    
            /**
             * Creates a new MultiFileAuthRes instance using the specified properties.
             * @function create
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {api.IMultiFileAuthRes=} [properties] Properties to set
             * @returns {api.MultiFileAuthRes} MultiFileAuthRes instance
             */
            MultiFileAuthRes.create = function create(properties) {
                return MultiFileAuthRes.fromObject(properties);
            };
    
            /**
             * Encodes the specified MultiFileAuthRes message. Does not implicitly {@link api.MultiFileAuthRes.verify|verify} messages.
             * @function encode
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {api.MultiFileAuthRes} message MultiFileAuthRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiFileAuthRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.put != null && Object.hasOwnProperty.call(message, "put"))
                    $root.api.FileAuthRes.encode(message.put, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.del != null && Object.hasOwnProperty.call(message, "del"))
                    $root.api.FileAuthRes.encode(message.del, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.get != null && Object.hasOwnProperty.call(message, "get"))
                    $root.api.FileAuthRes.encode(message.get, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified MultiFileAuthRes message, length delimited. Does not implicitly {@link api.MultiFileAuthRes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {api.MultiFileAuthRes} message MultiFileAuthRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiFileAuthRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MultiFileAuthRes message from the specified reader or buffer.
             * @function decode
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.MultiFileAuthRes} MultiFileAuthRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiFileAuthRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.MultiFileAuthRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.put = $root.api.FileAuthRes.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.del = $root.api.FileAuthRes.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.get = $root.api.FileAuthRes.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MultiFileAuthRes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.MultiFileAuthRes} MultiFileAuthRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiFileAuthRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MultiFileAuthRes message.
             * @function verify
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MultiFileAuthRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.put != null && message.hasOwnProperty("put")) {
                    var error = $root.api.FileAuthRes.verify(message.put);
                    if (error)
                        return "put." + error;
                }
                if (message.del != null && message.hasOwnProperty("del")) {
                    var error = $root.api.FileAuthRes.verify(message.del);
                    if (error)
                        return "del." + error;
                }
                if (message.get != null && message.hasOwnProperty("get")) {
                    var error = $root.api.FileAuthRes.verify(message.get);
                    if (error)
                        return "get." + error;
                }
                return null;
            };
    
            /**
             * Creates a MultiFileAuthRes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.MultiFileAuthRes} MultiFileAuthRes
             */
            MultiFileAuthRes.fromObject = function fromObject(object) {
                if (object instanceof $root.api.MultiFileAuthRes)
                    return object;
                var message = new $root.api.MultiFileAuthRes();
                if (object.put != null) {
                    if (typeof object.put !== "object")
                        throw TypeError(".api.MultiFileAuthRes.put: object expected");
                    message.put = $root.api.FileAuthRes.fromObject(object.put);
                }
                if (object.del != null) {
                    if (typeof object.del !== "object")
                        throw TypeError(".api.MultiFileAuthRes.del: object expected");
                    message.del = $root.api.FileAuthRes.fromObject(object.del);
                }
                if (object.get != null) {
                    if (typeof object.get !== "object")
                        throw TypeError(".api.MultiFileAuthRes.get: object expected");
                    message.get = $root.api.FileAuthRes.fromObject(object.get);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MultiFileAuthRes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.MultiFileAuthRes
             * @static
             * @param {api.MultiFileAuthRes} message MultiFileAuthRes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MultiFileAuthRes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.put = null;
                    object.del = null;
                    object.get = null;
                }
                if (message.put != null && message.hasOwnProperty("put"))
                    object.put = $root.api.FileAuthRes.toObject(message.put, options);
                if (message.del != null && message.hasOwnProperty("del"))
                    object.del = $root.api.FileAuthRes.toObject(message.del, options);
                if (message.get != null && message.hasOwnProperty("get"))
                    object.get = $root.api.FileAuthRes.toObject(message.get, options);
                return object;
            };
    
            /**
             * Converts this MultiFileAuthRes to JSON.
             * @function toJSON
             * @memberof api.MultiFileAuthRes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MultiFileAuthRes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MultiFileAuthRes;
        })();
    
        api.FileAuthRes = (function() {
    
            /**
             * Properties of a FileAuthRes.
             * @memberof api
             * @interface IFileAuthRes
             * @property {api.File|api.IFile|null} [file] FileAuthRes file
             * @property {string|null} [url] FileAuthRes url
             * @property {api.FileAuthMethod|null} [method] FileAuthRes method
             * @property {number|null} [expire] FileAuthRes expire
             * @property {string|null} [error] FileAuthRes error
             */
    
            /**
             * Constructs a new FileAuthRes.
             * @memberof api
             * @classdesc Represents a FileAuthRes.
             * @constructor
             * @param {api.IFileAuthRes=} [properties] Properties to set
             */
            function FileAuthRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FileAuthRes file.
             * @member {api.File|null|undefined} file
             * @memberof api.FileAuthRes
             * @instance
             */
            FileAuthRes.prototype.file = null;
    
            /**
             * FileAuthRes url.
             * @member {string} url
             * @memberof api.FileAuthRes
             * @instance
             */
            FileAuthRes.prototype.url = "";
    
            /**
             * FileAuthRes method.
             * @member {api.FileAuthMethod} method
             * @memberof api.FileAuthRes
             * @instance
             */
            FileAuthRes.prototype.method = 0;
    
            /**
             * FileAuthRes expire.
             * @member {number} expire
             * @memberof api.FileAuthRes
             * @instance
             */
            FileAuthRes.prototype.expire = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * FileAuthRes error.
             * @member {string} error
             * @memberof api.FileAuthRes
             * @instance
             */
            FileAuthRes.prototype.error = "";
    
            /**
             * Creates a new FileAuthRes instance using the specified properties.
             * @function create
             * @memberof api.FileAuthRes
             * @static
             * @param {api.IFileAuthRes=} [properties] Properties to set
             * @returns {api.FileAuthRes} FileAuthRes instance
             */
            FileAuthRes.create = function create(properties) {
                return FileAuthRes.fromObject(properties);
            };
    
            /**
             * Encodes the specified FileAuthRes message. Does not implicitly {@link api.FileAuthRes.verify|verify} messages.
             * @function encode
             * @memberof api.FileAuthRes
             * @static
             * @param {api.FileAuthRes} message FileAuthRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileAuthRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.api.File.encode(message.file, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.method);
                if (message.expire != null && Object.hasOwnProperty.call(message, "expire"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.expire);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.error);
                return writer;
            };
    
            /**
             * Encodes the specified FileAuthRes message, length delimited. Does not implicitly {@link api.FileAuthRes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.FileAuthRes
             * @static
             * @param {api.FileAuthRes} message FileAuthRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileAuthRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FileAuthRes message from the specified reader or buffer.
             * @function decode
             * @memberof api.FileAuthRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.FileAuthRes} FileAuthRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileAuthRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.FileAuthRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.file = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.url = reader.string();
                        break;
                    case 3:
                        message.method = reader.int32();
                        break;
                    case 4:
                        message.expire = reader.int64();
                        break;
                    case 5:
                        message.error = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FileAuthRes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.FileAuthRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.FileAuthRes} FileAuthRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileAuthRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FileAuthRes message.
             * @function verify
             * @memberof api.FileAuthRes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileAuthRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    var error = $root.api.File.verify(message.file);
                    if (error)
                        return "file." + error;
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.method != null && message.hasOwnProperty("method"))
                    switch (message.method) {
                    default:
                        return "method: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.expire != null && message.hasOwnProperty("expire"))
                    if (!$util.isInteger(message.expire) && !(message.expire && $util.isInteger(message.expire.low) && $util.isInteger(message.expire.high)))
                        return "expire: integer|Long expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                return null;
            };
    
            /**
             * Creates a FileAuthRes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.FileAuthRes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.FileAuthRes} FileAuthRes
             */
            FileAuthRes.fromObject = function fromObject(object) {
                if (object instanceof $root.api.FileAuthRes)
                    return object;
                var message = new $root.api.FileAuthRes();
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".api.FileAuthRes.file: object expected");
                    message.file = $root.api.File.fromObject(object.file);
                }
                if (object.url != null)
                    message.url = String(object.url);
                switch (object.method) {
                case "GET":
                case 0:
                    message.method = 0;
                    break;
                case "HEAD":
                case 1:
                    message.method = 1;
                    break;
                case "PUT":
                case 2:
                    message.method = 2;
                    break;
                case "DELETE":
                case 3:
                    message.method = 3;
                    break;
                }
                if (object.expire != null)
                    if ($util.Long)
                        (message.expire = $util.Long.fromValue(object.expire)).unsigned = false;
                    else if (typeof object.expire === "string")
                        message.expire = parseInt(object.expire, 10);
                    else if (typeof object.expire === "number")
                        message.expire = object.expire;
                    else if (typeof object.expire === "object")
                        message.expire = new $util.LongBits(object.expire.low >>> 0, object.expire.high >>> 0).toNumber();
                if (object.error != null)
                    message.error = String(object.error);
                return message;
            };
    
            /**
             * Creates a plain object from a FileAuthRes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.FileAuthRes
             * @static
             * @param {api.FileAuthRes} message FileAuthRes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileAuthRes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.file = null;
                    object.url = "";
                    object.method = options.enums === String ? "GET" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expire = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expire = options.longs === String ? "0" : 0;
                    object.error = "";
                }
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = $root.api.File.toObject(message.file, options);
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.method != null && message.hasOwnProperty("method"))
                    object.method = options.enums === String ? $root.api.FileAuthMethod[message.method] : message.method;
                if (message.expire != null && message.hasOwnProperty("expire"))
                    if (typeof message.expire === "number")
                        object.expire = options.longs === String ? String(message.expire) : message.expire;
                    else
                        object.expire = options.longs === String ? $util.Long.prototype.toString.call(message.expire) : options.longs === Number ? new $util.LongBits(message.expire.low >>> 0, message.expire.high >>> 0).toNumber() : message.expire;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                return object;
            };
    
            /**
             * Converts this FileAuthRes to JSON.
             * @function toJSON
             * @memberof api.FileAuthRes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileAuthRes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FileAuthRes;
        })();
    
        api.ListObjects = (function() {
    
            /**
             * Properties of a ListObjects.
             * @memberof api
             * @interface IListObjects
             * @property {string|null} [prefix] ListObjects prefix
             */
    
            /**
             * Constructs a new ListObjects.
             * @memberof api
             * @classdesc Represents a ListObjects.
             * @constructor
             * @param {api.IListObjects=} [properties] Properties to set
             */
            function ListObjects(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ListObjects prefix.
             * @member {string} prefix
             * @memberof api.ListObjects
             * @instance
             */
            ListObjects.prototype.prefix = "";
    
            /**
             * Creates a new ListObjects instance using the specified properties.
             * @function create
             * @memberof api.ListObjects
             * @static
             * @param {api.IListObjects=} [properties] Properties to set
             * @returns {api.ListObjects} ListObjects instance
             */
            ListObjects.create = function create(properties) {
                return ListObjects.fromObject(properties);
            };
    
            /**
             * Encodes the specified ListObjects message. Does not implicitly {@link api.ListObjects.verify|verify} messages.
             * @function encode
             * @memberof api.ListObjects
             * @static
             * @param {api.ListObjects} message ListObjects message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListObjects.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.prefix);
                return writer;
            };
    
            /**
             * Encodes the specified ListObjects message, length delimited. Does not implicitly {@link api.ListObjects.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ListObjects
             * @static
             * @param {api.ListObjects} message ListObjects message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListObjects.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ListObjects message from the specified reader or buffer.
             * @function decode
             * @memberof api.ListObjects
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ListObjects} ListObjects
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListObjects.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ListObjects();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.prefix = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ListObjects message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ListObjects
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ListObjects} ListObjects
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListObjects.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ListObjects message.
             * @function verify
             * @memberof api.ListObjects
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListObjects.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    if (!$util.isString(message.prefix))
                        return "prefix: string expected";
                return null;
            };
    
            /**
             * Creates a ListObjects message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ListObjects
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ListObjects} ListObjects
             */
            ListObjects.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ListObjects)
                    return object;
                var message = new $root.api.ListObjects();
                if (object.prefix != null)
                    message.prefix = String(object.prefix);
                return message;
            };
    
            /**
             * Creates a plain object from a ListObjects message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ListObjects
             * @static
             * @param {api.ListObjects} message ListObjects
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListObjects.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.prefix = "";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    object.prefix = message.prefix;
                return object;
            };
    
            /**
             * Converts this ListObjects to JSON.
             * @function toJSON
             * @memberof api.ListObjects
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListObjects.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ListObjects;
        })();
    
        api.ListObjectsResp = (function() {
    
            /**
             * Properties of a ListObjectsResp.
             * @memberof api
             * @interface IListObjectsResp
             * @property {Array.<string>|null} [objects] ListObjectsResp objects
             */
    
            /**
             * Constructs a new ListObjectsResp.
             * @memberof api
             * @classdesc Represents a ListObjectsResp.
             * @constructor
             * @param {api.IListObjectsResp=} [properties] Properties to set
             */
            function ListObjectsResp(properties) {
                this.objects = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ListObjectsResp objects.
             * @member {Array.<string>} objects
             * @memberof api.ListObjectsResp
             * @instance
             */
            ListObjectsResp.prototype.objects = $util.emptyArray;
    
            /**
             * Creates a new ListObjectsResp instance using the specified properties.
             * @function create
             * @memberof api.ListObjectsResp
             * @static
             * @param {api.IListObjectsResp=} [properties] Properties to set
             * @returns {api.ListObjectsResp} ListObjectsResp instance
             */
            ListObjectsResp.create = function create(properties) {
                return ListObjectsResp.fromObject(properties);
            };
    
            /**
             * Encodes the specified ListObjectsResp message. Does not implicitly {@link api.ListObjectsResp.verify|verify} messages.
             * @function encode
             * @memberof api.ListObjectsResp
             * @static
             * @param {api.ListObjectsResp} message ListObjectsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListObjectsResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.objects != null && message.objects.length)
                    for (var i = 0; i < message.objects.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.objects[i]);
                return writer;
            };
    
            /**
             * Encodes the specified ListObjectsResp message, length delimited. Does not implicitly {@link api.ListObjectsResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ListObjectsResp
             * @static
             * @param {api.ListObjectsResp} message ListObjectsResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListObjectsResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ListObjectsResp message from the specified reader or buffer.
             * @function decode
             * @memberof api.ListObjectsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ListObjectsResp} ListObjectsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListObjectsResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ListObjectsResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.objects && message.objects.length))
                            message.objects = [];
                        message.objects.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ListObjectsResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ListObjectsResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ListObjectsResp} ListObjectsResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListObjectsResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ListObjectsResp message.
             * @function verify
             * @memberof api.ListObjectsResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListObjectsResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.objects != null && message.hasOwnProperty("objects")) {
                    if (!Array.isArray(message.objects))
                        return "objects: array expected";
                    for (var i = 0; i < message.objects.length; ++i)
                        if (!$util.isString(message.objects[i]))
                            return "objects: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a ListObjectsResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ListObjectsResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ListObjectsResp} ListObjectsResp
             */
            ListObjectsResp.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ListObjectsResp)
                    return object;
                var message = new $root.api.ListObjectsResp();
                if (object.objects) {
                    if (!Array.isArray(object.objects))
                        throw TypeError(".api.ListObjectsResp.objects: array expected");
                    message.objects = [];
                    for (var i = 0; i < object.objects.length; ++i)
                        message.objects[i] = String(object.objects[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ListObjectsResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ListObjectsResp
             * @static
             * @param {api.ListObjectsResp} message ListObjectsResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListObjectsResp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.objects = [];
                if (message.objects && message.objects.length) {
                    object.objects = [];
                    for (var j = 0; j < message.objects.length; ++j)
                        object.objects[j] = message.objects[j];
                }
                return object;
            };
    
            /**
             * Converts this ListObjectsResp to JSON.
             * @function toJSON
             * @memberof api.ListObjectsResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListObjectsResp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ListObjectsResp;
        })();
    
        api.Disconnect = (function() {
    
            /**
             * Properties of a Disconnect.
             * @memberof api
             * @interface IDisconnect
             * @property {string|null} [error] Disconnect error
             */
    
            /**
             * Constructs a new Disconnect.
             * @memberof api
             * @classdesc Represents a Disconnect.
             * @constructor
             * @param {api.IDisconnect=} [properties] Properties to set
             */
            function Disconnect(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Disconnect error.
             * @member {string} error
             * @memberof api.Disconnect
             * @instance
             */
            Disconnect.prototype.error = "";
    
            /**
             * Creates a new Disconnect instance using the specified properties.
             * @function create
             * @memberof api.Disconnect
             * @static
             * @param {api.IDisconnect=} [properties] Properties to set
             * @returns {api.Disconnect} Disconnect instance
             */
            Disconnect.create = function create(properties) {
                return Disconnect.fromObject(properties);
            };
    
            /**
             * Encodes the specified Disconnect message. Does not implicitly {@link api.Disconnect.verify|verify} messages.
             * @function encode
             * @memberof api.Disconnect
             * @static
             * @param {api.Disconnect} message Disconnect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Disconnect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
                return writer;
            };
    
            /**
             * Encodes the specified Disconnect message, length delimited. Does not implicitly {@link api.Disconnect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Disconnect
             * @static
             * @param {api.Disconnect} message Disconnect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Disconnect message from the specified reader or buffer.
             * @function decode
             * @memberof api.Disconnect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Disconnect} Disconnect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Disconnect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Disconnect();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Disconnect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Disconnect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Disconnect} Disconnect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Disconnect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Disconnect message.
             * @function verify
             * @memberof api.Disconnect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Disconnect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                return null;
            };
    
            /**
             * Creates a Disconnect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Disconnect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Disconnect} Disconnect
             */
            Disconnect.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Disconnect)
                    return object;
                var message = new $root.api.Disconnect();
                if (object.error != null)
                    message.error = String(object.error);
                return message;
            };
    
            /**
             * Creates a plain object from a Disconnect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Disconnect
             * @static
             * @param {api.Disconnect} message Disconnect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Disconnect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.error = "";
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                return object;
            };
    
            /**
             * Converts this Disconnect to JSON.
             * @function toJSON
             * @memberof api.Disconnect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Disconnect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Disconnect;
        })();
    
        api.Send = (function() {
    
            /**
             * Properties of a Send.
             * @memberof api
             * @interface ISend
             * @property {Uint8Array|null} [buff] Send buff
             */
    
            /**
             * Constructs a new Send.
             * @memberof api
             * @classdesc Represents a Send.
             * @constructor
             * @param {api.ISend=} [properties] Properties to set
             */
            function Send(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Send buff.
             * @member {Uint8Array} buff
             * @memberof api.Send
             * @instance
             */
            Send.prototype.buff = $util.newBuffer([]);
    
            /**
             * Creates a new Send instance using the specified properties.
             * @function create
             * @memberof api.Send
             * @static
             * @param {api.ISend=} [properties] Properties to set
             * @returns {api.Send} Send instance
             */
            Send.create = function create(properties) {
                return Send.fromObject(properties);
            };
    
            /**
             * Encodes the specified Send message. Does not implicitly {@link api.Send.verify|verify} messages.
             * @function encode
             * @memberof api.Send
             * @static
             * @param {api.Send} message Send message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Send.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.buff);
                return writer;
            };
    
            /**
             * Encodes the specified Send message, length delimited. Does not implicitly {@link api.Send.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Send
             * @static
             * @param {api.Send} message Send message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Send.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Send message from the specified reader or buffer.
             * @function decode
             * @memberof api.Send
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Send} Send
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Send.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Send();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.buff = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Send message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Send
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Send} Send
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Send.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Send message.
             * @function verify
             * @memberof api.Send
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Send.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.buff != null && message.hasOwnProperty("buff"))
                    if (!(message.buff && typeof message.buff.length === "number" || $util.isString(message.buff)))
                        return "buff: buffer expected";
                return null;
            };
    
            /**
             * Creates a Send message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Send
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Send} Send
             */
            Send.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Send)
                    return object;
                var message = new $root.api.Send();
                if (object.buff != null)
                    if (typeof object.buff === "string")
                        $util.base64.decode(object.buff, message.buff = $util.newBuffer($util.base64.length(object.buff)), 0);
                    else if (object.buff.length)
                        message.buff = object.buff;
                return message;
            };
    
            /**
             * Creates a plain object from a Send message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Send
             * @static
             * @param {api.Send} message Send
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Send.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.buff = "";
                    else {
                        object.buff = [];
                        if (options.bytes !== Array)
                            object.buff = $util.newBuffer(object.buff);
                    }
                if (message.buff != null && message.hasOwnProperty("buff"))
                    object.buff = options.bytes === String ? $util.base64.encode(message.buff, 0, message.buff.length) : options.bytes === Array ? Array.prototype.slice.call(message.buff) : message.buff;
                return object;
            };
    
            /**
             * Converts this Send to JSON.
             * @function toJSON
             * @memberof api.Send
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Send.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Send;
        })();
    
        api.Recv = (function() {
    
            /**
             * Properties of a Recv.
             * @memberof api
             * @interface IRecv
             * @property {Uint8Array|null} [buff] Recv buff
             */
    
            /**
             * Constructs a new Recv.
             * @memberof api
             * @classdesc Represents a Recv.
             * @constructor
             * @param {api.IRecv=} [properties] Properties to set
             */
            function Recv(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Recv buff.
             * @member {Uint8Array} buff
             * @memberof api.Recv
             * @instance
             */
            Recv.prototype.buff = $util.newBuffer([]);
    
            /**
             * Creates a new Recv instance using the specified properties.
             * @function create
             * @memberof api.Recv
             * @static
             * @param {api.IRecv=} [properties] Properties to set
             * @returns {api.Recv} Recv instance
             */
            Recv.create = function create(properties) {
                return Recv.fromObject(properties);
            };
    
            /**
             * Encodes the specified Recv message. Does not implicitly {@link api.Recv.verify|verify} messages.
             * @function encode
             * @memberof api.Recv
             * @static
             * @param {api.Recv} message Recv message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Recv.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.buff);
                return writer;
            };
    
            /**
             * Encodes the specified Recv message, length delimited. Does not implicitly {@link api.Recv.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Recv
             * @static
             * @param {api.Recv} message Recv message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Recv.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Recv message from the specified reader or buffer.
             * @function decode
             * @memberof api.Recv
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Recv} Recv
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Recv.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Recv();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.buff = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Recv message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Recv
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Recv} Recv
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Recv.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Recv message.
             * @function verify
             * @memberof api.Recv
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Recv.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.buff != null && message.hasOwnProperty("buff"))
                    if (!(message.buff && typeof message.buff.length === "number" || $util.isString(message.buff)))
                        return "buff: buffer expected";
                return null;
            };
    
            /**
             * Creates a Recv message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Recv
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Recv} Recv
             */
            Recv.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Recv)
                    return object;
                var message = new $root.api.Recv();
                if (object.buff != null)
                    if (typeof object.buff === "string")
                        $util.base64.decode(object.buff, message.buff = $util.newBuffer($util.base64.length(object.buff)), 0);
                    else if (object.buff.length)
                        message.buff = object.buff;
                return message;
            };
    
            /**
             * Creates a plain object from a Recv message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Recv
             * @static
             * @param {api.Recv} message Recv
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Recv.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.buff = "";
                    else {
                        object.buff = [];
                        if (options.bytes !== Array)
                            object.buff = $util.newBuffer(object.buff);
                    }
                if (message.buff != null && message.hasOwnProperty("buff"))
                    object.buff = options.bytes === String ? $util.base64.encode(message.buff, 0, message.buff.length) : options.bytes === Array ? Array.prototype.slice.call(message.buff) : message.buff;
                return object;
            };
    
            /**
             * Converts this Recv to JSON.
             * @function toJSON
             * @memberof api.Recv
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Recv.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Recv;
        })();
    
        api.Connect = (function() {
    
            /**
             * Properties of a Connect.
             * @memberof api
             * @interface IConnect
             * @property {string|null} [proto] Connect proto
             * @property {string|null} [addr] Connect addr
             */
    
            /**
             * Constructs a new Connect.
             * @memberof api
             * @classdesc Represents a Connect.
             * @constructor
             * @param {api.IConnect=} [properties] Properties to set
             */
            function Connect(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Connect proto.
             * @member {string} proto
             * @memberof api.Connect
             * @instance
             */
            Connect.prototype.proto = "";
    
            /**
             * Connect addr.
             * @member {string} addr
             * @memberof api.Connect
             * @instance
             */
            Connect.prototype.addr = "";
    
            /**
             * Creates a new Connect instance using the specified properties.
             * @function create
             * @memberof api.Connect
             * @static
             * @param {api.IConnect=} [properties] Properties to set
             * @returns {api.Connect} Connect instance
             */
            Connect.create = function create(properties) {
                return Connect.fromObject(properties);
            };
    
            /**
             * Encodes the specified Connect message. Does not implicitly {@link api.Connect.verify|verify} messages.
             * @function encode
             * @memberof api.Connect
             * @static
             * @param {api.Connect} message Connect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Connect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.proto != null && Object.hasOwnProperty.call(message, "proto"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.proto);
                if (message.addr != null && Object.hasOwnProperty.call(message, "addr"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.addr);
                return writer;
            };
    
            /**
             * Encodes the specified Connect message, length delimited. Does not implicitly {@link api.Connect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Connect
             * @static
             * @param {api.Connect} message Connect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Connect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Connect message from the specified reader or buffer.
             * @function decode
             * @memberof api.Connect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Connect} Connect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Connect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Connect();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.proto = reader.string();
                        break;
                    case 2:
                        message.addr = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Connect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Connect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Connect} Connect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Connect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Connect message.
             * @function verify
             * @memberof api.Connect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Connect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.proto != null && message.hasOwnProperty("proto"))
                    if (!$util.isString(message.proto))
                        return "proto: string expected";
                if (message.addr != null && message.hasOwnProperty("addr"))
                    if (!$util.isString(message.addr))
                        return "addr: string expected";
                return null;
            };
    
            /**
             * Creates a Connect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Connect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Connect} Connect
             */
            Connect.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Connect)
                    return object;
                var message = new $root.api.Connect();
                if (object.proto != null)
                    message.proto = String(object.proto);
                if (object.addr != null)
                    message.addr = String(object.addr);
                return message;
            };
    
            /**
             * Creates a plain object from a Connect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Connect
             * @static
             * @param {api.Connect} message Connect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Connect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.proto = "";
                    object.addr = "";
                }
                if (message.proto != null && message.hasOwnProperty("proto"))
                    object.proto = message.proto;
                if (message.addr != null && message.hasOwnProperty("addr"))
                    object.addr = message.addr;
                return object;
            };
    
            /**
             * Converts this Connect to JSON.
             * @function toJSON
             * @memberof api.Connect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Connect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Connect;
        })();
    
        api.Hint = (function() {
    
            /**
             * Properties of a Hint.
             * @memberof api
             * @interface IHint
             * @property {string|null} [text] Hint text
             */
    
            /**
             * Constructs a new Hint.
             * @memberof api
             * @classdesc Represents a Hint.
             * @constructor
             * @param {api.IHint=} [properties] Properties to set
             */
            function Hint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Hint text.
             * @member {string} text
             * @memberof api.Hint
             * @instance
             */
            Hint.prototype.text = "";
    
            /**
             * Creates a new Hint instance using the specified properties.
             * @function create
             * @memberof api.Hint
             * @static
             * @param {api.IHint=} [properties] Properties to set
             * @returns {api.Hint} Hint instance
             */
            Hint.create = function create(properties) {
                return Hint.fromObject(properties);
            };
    
            /**
             * Encodes the specified Hint message. Does not implicitly {@link api.Hint.verify|verify} messages.
             * @function encode
             * @memberof api.Hint
             * @static
             * @param {api.Hint} message Hint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };
    
            /**
             * Encodes the specified Hint message, length delimited. Does not implicitly {@link api.Hint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Hint
             * @static
             * @param {api.Hint} message Hint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Hint message from the specified reader or buffer.
             * @function decode
             * @memberof api.Hint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Hint} Hint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Hint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.text = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Hint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Hint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Hint} Hint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Hint message.
             * @function verify
             * @memberof api.Hint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Hint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };
    
            /**
             * Creates a Hint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Hint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Hint} Hint
             */
            Hint.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Hint)
                    return object;
                var message = new $root.api.Hint();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };
    
            /**
             * Creates a plain object from a Hint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Hint
             * @static
             * @param {api.Hint} message Hint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Hint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };
    
            /**
             * Converts this Hint to JSON.
             * @function toJSON
             * @memberof api.Hint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Hint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Hint;
        })();
    
        api.Ping = (function() {
    
            /**
             * Properties of a Ping.
             * @memberof api
             * @interface IPing
             */
    
            /**
             * Constructs a new Ping.
             * @memberof api
             * @classdesc Represents a Ping.
             * @constructor
             * @param {api.IPing=} [properties] Properties to set
             */
            function Ping(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Ping instance using the specified properties.
             * @function create
             * @memberof api.Ping
             * @static
             * @param {api.IPing=} [properties] Properties to set
             * @returns {api.Ping} Ping instance
             */
            Ping.create = function create(properties) {
                return Ping.fromObject(properties);
            };
    
            /**
             * Encodes the specified Ping message. Does not implicitly {@link api.Ping.verify|verify} messages.
             * @function encode
             * @memberof api.Ping
             * @static
             * @param {api.Ping} message Ping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ping.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Ping message, length delimited. Does not implicitly {@link api.Ping.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Ping
             * @static
             * @param {api.Ping} message Ping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ping.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Ping message from the specified reader or buffer.
             * @function decode
             * @memberof api.Ping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Ping} Ping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ping.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Ping();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Ping message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Ping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Ping} Ping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ping.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Ping message.
             * @function verify
             * @memberof api.Ping
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Ping.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Ping message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Ping
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Ping} Ping
             */
            Ping.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Ping)
                    return object;
                return new $root.api.Ping();
            };
    
            /**
             * Creates a plain object from a Ping message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Ping
             * @static
             * @param {api.Ping} message Ping
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ping.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Ping to JSON.
             * @function toJSON
             * @memberof api.Ping
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Ping.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Ping;
        })();
    
        api.Pong = (function() {
    
            /**
             * Properties of a Pong.
             * @memberof api
             * @interface IPong
             */
    
            /**
             * Constructs a new Pong.
             * @memberof api
             * @classdesc Represents a Pong.
             * @constructor
             * @param {api.IPong=} [properties] Properties to set
             */
            function Pong(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Pong instance using the specified properties.
             * @function create
             * @memberof api.Pong
             * @static
             * @param {api.IPong=} [properties] Properties to set
             * @returns {api.Pong} Pong instance
             */
            Pong.create = function create(properties) {
                return Pong.fromObject(properties);
            };
    
            /**
             * Encodes the specified Pong message. Does not implicitly {@link api.Pong.verify|verify} messages.
             * @function encode
             * @memberof api.Pong
             * @static
             * @param {api.Pong} message Pong message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pong.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Pong message, length delimited. Does not implicitly {@link api.Pong.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Pong
             * @static
             * @param {api.Pong} message Pong message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pong.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Pong message from the specified reader or buffer.
             * @function decode
             * @memberof api.Pong
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Pong} Pong
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pong.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Pong();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Pong message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Pong
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Pong} Pong
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pong.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Pong message.
             * @function verify
             * @memberof api.Pong
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pong.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Pong message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Pong
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Pong} Pong
             */
            Pong.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Pong)
                    return object;
                return new $root.api.Pong();
            };
    
            /**
             * Creates a plain object from a Pong message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Pong
             * @static
             * @param {api.Pong} message Pong
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pong.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Pong to JSON.
             * @function toJSON
             * @memberof api.Pong
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pong.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Pong;
        })();
    
        api.Hello = (function() {
    
            /**
             * Properties of a Hello.
             * @memberof api
             * @interface IHello
             * @property {number|null} [userid] Hello userid
             * @property {string|null} [username] Hello username
             * @property {string|null} [token] Hello token
             */
    
            /**
             * Constructs a new Hello.
             * @memberof api
             * @classdesc Represents a Hello.
             * @constructor
             * @param {api.IHello=} [properties] Properties to set
             */
            function Hello(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Hello userid.
             * @member {number} userid
             * @memberof api.Hello
             * @instance
             */
            Hello.prototype.userid = 0;
    
            /**
             * Hello username.
             * @member {string} username
             * @memberof api.Hello
             * @instance
             */
            Hello.prototype.username = "";
    
            /**
             * Hello token.
             * @member {string} token
             * @memberof api.Hello
             * @instance
             */
            Hello.prototype.token = "";
    
            /**
             * Creates a new Hello instance using the specified properties.
             * @function create
             * @memberof api.Hello
             * @static
             * @param {api.IHello=} [properties] Properties to set
             * @returns {api.Hello} Hello instance
             */
            Hello.create = function create(properties) {
                return Hello.fromObject(properties);
            };
    
            /**
             * Encodes the specified Hello message. Does not implicitly {@link api.Hello.verify|verify} messages.
             * @function encode
             * @memberof api.Hello
             * @static
             * @param {api.Hello} message Hello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hello.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userid != null && Object.hasOwnProperty.call(message, "userid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.userid);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                return writer;
            };
    
            /**
             * Encodes the specified Hello message, length delimited. Does not implicitly {@link api.Hello.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Hello
             * @static
             * @param {api.Hello} message Hello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Hello.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Hello message from the specified reader or buffer.
             * @function decode
             * @memberof api.Hello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Hello} Hello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hello.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Hello();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.userid = reader.uint32();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Hello message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Hello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Hello} Hello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Hello.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Hello message.
             * @function verify
             * @memberof api.Hello
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Hello.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userid != null && message.hasOwnProperty("userid"))
                    if (!$util.isInteger(message.userid))
                        return "userid: integer expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };
    
            /**
             * Creates a Hello message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Hello
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Hello} Hello
             */
            Hello.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Hello)
                    return object;
                var message = new $root.api.Hello();
                if (object.userid != null)
                    message.userid = object.userid >>> 0;
                if (object.username != null)
                    message.username = String(object.username);
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };
    
            /**
             * Creates a plain object from a Hello message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Hello
             * @static
             * @param {api.Hello} message Hello
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Hello.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.userid = 0;
                    object.username = "";
                    object.token = "";
                }
                if (message.userid != null && message.hasOwnProperty("userid"))
                    object.userid = message.userid;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };
    
            /**
             * Converts this Hello to JSON.
             * @function toJSON
             * @memberof api.Hello
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Hello.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Hello;
        })();
    
        api.Goodbye = (function() {
    
            /**
             * Properties of a Goodbye.
             * @memberof api
             * @interface IGoodbye
             */
    
            /**
             * Constructs a new Goodbye.
             * @memberof api
             * @classdesc Represents a Goodbye.
             * @constructor
             * @param {api.IGoodbye=} [properties] Properties to set
             */
            function Goodbye(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Goodbye instance using the specified properties.
             * @function create
             * @memberof api.Goodbye
             * @static
             * @param {api.IGoodbye=} [properties] Properties to set
             * @returns {api.Goodbye} Goodbye instance
             */
            Goodbye.create = function create(properties) {
                return Goodbye.fromObject(properties);
            };
    
            /**
             * Encodes the specified Goodbye message. Does not implicitly {@link api.Goodbye.verify|verify} messages.
             * @function encode
             * @memberof api.Goodbye
             * @static
             * @param {api.Goodbye} message Goodbye message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goodbye.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Goodbye message, length delimited. Does not implicitly {@link api.Goodbye.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Goodbye
             * @static
             * @param {api.Goodbye} message Goodbye message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goodbye.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Goodbye message from the specified reader or buffer.
             * @function decode
             * @memberof api.Goodbye
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Goodbye} Goodbye
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goodbye.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Goodbye();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Goodbye message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Goodbye
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Goodbye} Goodbye
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goodbye.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Goodbye message.
             * @function verify
             * @memberof api.Goodbye
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Goodbye.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Goodbye message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Goodbye
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Goodbye} Goodbye
             */
            Goodbye.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Goodbye)
                    return object;
                return new $root.api.Goodbye();
            };
    
            /**
             * Creates a plain object from a Goodbye message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Goodbye
             * @static
             * @param {api.Goodbye} message Goodbye
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Goodbye.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Goodbye to JSON.
             * @function toJSON
             * @memberof api.Goodbye
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Goodbye.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Goodbye;
        })();
    
        /**
         * State enum.
         * @name api.State
         * @enum {number}
         * @property {number} Stopped=0 Stopped value
         * @property {number} Running=1 Running value
         */
        api.State = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Stopped"] = 0;
            values[valuesById[1] = "Running"] = 1;
            return values;
        })();
    
        api.CheckChanges = (function() {
    
            /**
             * Properties of a CheckChanges.
             * @memberof api
             * @interface ICheckChanges
             */
    
            /**
             * Constructs a new CheckChanges.
             * @memberof api
             * @classdesc Represents a CheckChanges.
             * @constructor
             * @param {api.ICheckChanges=} [properties] Properties to set
             */
            function CheckChanges(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new CheckChanges instance using the specified properties.
             * @function create
             * @memberof api.CheckChanges
             * @static
             * @param {api.ICheckChanges=} [properties] Properties to set
             * @returns {api.CheckChanges} CheckChanges instance
             */
            CheckChanges.create = function create(properties) {
                return CheckChanges.fromObject(properties);
            };
    
            /**
             * Encodes the specified CheckChanges message. Does not implicitly {@link api.CheckChanges.verify|verify} messages.
             * @function encode
             * @memberof api.CheckChanges
             * @static
             * @param {api.CheckChanges} message CheckChanges message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckChanges.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified CheckChanges message, length delimited. Does not implicitly {@link api.CheckChanges.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.CheckChanges
             * @static
             * @param {api.CheckChanges} message CheckChanges message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckChanges.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CheckChanges message from the specified reader or buffer.
             * @function decode
             * @memberof api.CheckChanges
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.CheckChanges} CheckChanges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckChanges.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CheckChanges();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CheckChanges message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.CheckChanges
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.CheckChanges} CheckChanges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckChanges.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CheckChanges message.
             * @function verify
             * @memberof api.CheckChanges
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckChanges.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a CheckChanges message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.CheckChanges
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.CheckChanges} CheckChanges
             */
            CheckChanges.fromObject = function fromObject(object) {
                if (object instanceof $root.api.CheckChanges)
                    return object;
                return new $root.api.CheckChanges();
            };
    
            /**
             * Creates a plain object from a CheckChanges message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.CheckChanges
             * @static
             * @param {api.CheckChanges} message CheckChanges
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckChanges.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this CheckChanges to JSON.
             * @function toJSON
             * @memberof api.CheckChanges
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckChanges.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CheckChanges;
        })();
    
        api.EnsurePackages = (function() {
    
            /**
             * Properties of an EnsurePackages.
             * @memberof api
             * @interface IEnsurePackages
             * @property {boolean|null} [install] EnsurePackages install
             * @property {api.File|api.IFile|null} [file] EnsurePackages file
             */
    
            /**
             * Constructs a new EnsurePackages.
             * @memberof api
             * @classdesc Represents an EnsurePackages.
             * @constructor
             * @param {api.IEnsurePackages=} [properties] Properties to set
             */
            function EnsurePackages(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * EnsurePackages install.
             * @member {boolean} install
             * @memberof api.EnsurePackages
             * @instance
             */
            EnsurePackages.prototype.install = false;
    
            /**
             * EnsurePackages file.
             * @member {api.File|null|undefined} file
             * @memberof api.EnsurePackages
             * @instance
             */
            EnsurePackages.prototype.file = null;
    
            /**
             * Creates a new EnsurePackages instance using the specified properties.
             * @function create
             * @memberof api.EnsurePackages
             * @static
             * @param {api.IEnsurePackages=} [properties] Properties to set
             * @returns {api.EnsurePackages} EnsurePackages instance
             */
            EnsurePackages.create = function create(properties) {
                return EnsurePackages.fromObject(properties);
            };
    
            /**
             * Encodes the specified EnsurePackages message. Does not implicitly {@link api.EnsurePackages.verify|verify} messages.
             * @function encode
             * @memberof api.EnsurePackages
             * @static
             * @param {api.EnsurePackages} message EnsurePackages message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnsurePackages.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.install != null && Object.hasOwnProperty.call(message, "install"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.install);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.api.File.encode(message.file, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified EnsurePackages message, length delimited. Does not implicitly {@link api.EnsurePackages.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.EnsurePackages
             * @static
             * @param {api.EnsurePackages} message EnsurePackages message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnsurePackages.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an EnsurePackages message from the specified reader or buffer.
             * @function decode
             * @memberof api.EnsurePackages
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.EnsurePackages} EnsurePackages
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnsurePackages.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.EnsurePackages();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.install = reader.bool();
                        break;
                    case 2:
                        message.file = $root.api.File.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an EnsurePackages message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.EnsurePackages
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.EnsurePackages} EnsurePackages
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnsurePackages.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an EnsurePackages message.
             * @function verify
             * @memberof api.EnsurePackages
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnsurePackages.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.install != null && message.hasOwnProperty("install"))
                    if (typeof message.install !== "boolean")
                        return "install: boolean expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    var error = $root.api.File.verify(message.file);
                    if (error)
                        return "file." + error;
                }
                return null;
            };
    
            /**
             * Creates an EnsurePackages message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.EnsurePackages
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.EnsurePackages} EnsurePackages
             */
            EnsurePackages.fromObject = function fromObject(object) {
                if (object instanceof $root.api.EnsurePackages)
                    return object;
                var message = new $root.api.EnsurePackages();
                if (object.install != null)
                    message.install = Boolean(object.install);
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".api.EnsurePackages.file: object expected");
                    message.file = $root.api.File.fromObject(object.file);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an EnsurePackages message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.EnsurePackages
             * @static
             * @param {api.EnsurePackages} message EnsurePackages
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnsurePackages.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.install = false;
                    object.file = null;
                }
                if (message.install != null && message.hasOwnProperty("install"))
                    object.install = message.install;
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = $root.api.File.toObject(message.file, options);
                return object;
            };
    
            /**
             * Converts this EnsurePackages to JSON.
             * @function toJSON
             * @memberof api.EnsurePackages
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnsurePackages.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return EnsurePackages;
        })();
    
        api.Start = (function() {
    
            /**
             * Properties of a Start.
             * @memberof api
             * @interface IStart
             */
    
            /**
             * Constructs a new Start.
             * @memberof api
             * @classdesc Represents a Start.
             * @constructor
             * @param {api.IStart=} [properties] Properties to set
             */
            function Start(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Start instance using the specified properties.
             * @function create
             * @memberof api.Start
             * @static
             * @param {api.IStart=} [properties] Properties to set
             * @returns {api.Start} Start instance
             */
            Start.create = function create(properties) {
                return Start.fromObject(properties);
            };
    
            /**
             * Encodes the specified Start message. Does not implicitly {@link api.Start.verify|verify} messages.
             * @function encode
             * @memberof api.Start
             * @static
             * @param {api.Start} message Start message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Start.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Start message, length delimited. Does not implicitly {@link api.Start.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Start
             * @static
             * @param {api.Start} message Start message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Start.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Start message from the specified reader or buffer.
             * @function decode
             * @memberof api.Start
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Start} Start
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Start.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Start();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Start message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Start
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Start} Start
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Start.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Start message.
             * @function verify
             * @memberof api.Start
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Start.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Start message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Start
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Start} Start
             */
            Start.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Start)
                    return object;
                return new $root.api.Start();
            };
    
            /**
             * Creates a plain object from a Start message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Start
             * @static
             * @param {api.Start} message Start
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Start.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Start to JSON.
             * @function toJSON
             * @memberof api.Start
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Start.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Start;
        })();
    
        api.DebugStatus = (function() {
    
            /**
             * Properties of a DebugStatus.
             * @memberof api
             * @interface IDebugStatus
             * @property {boolean|null} [done] DebugStatus done
             * @property {Array.<api.StackFrame|api.IStackFrame>|null} [stack] DebugStatus stack
             */
    
            /**
             * Constructs a new DebugStatus.
             * @memberof api
             * @classdesc Represents a DebugStatus.
             * @constructor
             * @param {api.IDebugStatus=} [properties] Properties to set
             */
            function DebugStatus(properties) {
                this.stack = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugStatus done.
             * @member {boolean} done
             * @memberof api.DebugStatus
             * @instance
             */
            DebugStatus.prototype.done = false;
    
            /**
             * DebugStatus stack.
             * @member {Array.<api.StackFrame>} stack
             * @memberof api.DebugStatus
             * @instance
             */
            DebugStatus.prototype.stack = $util.emptyArray;
    
            /**
             * Creates a new DebugStatus instance using the specified properties.
             * @function create
             * @memberof api.DebugStatus
             * @static
             * @param {api.IDebugStatus=} [properties] Properties to set
             * @returns {api.DebugStatus} DebugStatus instance
             */
            DebugStatus.create = function create(properties) {
                return DebugStatus.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugStatus message. Does not implicitly {@link api.DebugStatus.verify|verify} messages.
             * @function encode
             * @memberof api.DebugStatus
             * @static
             * @param {api.DebugStatus} message DebugStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.done != null && Object.hasOwnProperty.call(message, "done"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.done);
                if (message.stack != null && message.stack.length)
                    for (var i = 0; i < message.stack.length; ++i)
                        $root.api.StackFrame.encode(message.stack[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DebugStatus message, length delimited. Does not implicitly {@link api.DebugStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugStatus
             * @static
             * @param {api.DebugStatus} message DebugStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugStatus message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugStatus} DebugStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.done = reader.bool();
                        break;
                    case 2:
                        if (!(message.stack && message.stack.length))
                            message.stack = [];
                        message.stack.push($root.api.StackFrame.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugStatus} DebugStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugStatus message.
             * @function verify
             * @memberof api.DebugStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.done != null && message.hasOwnProperty("done"))
                    if (typeof message.done !== "boolean")
                        return "done: boolean expected";
                if (message.stack != null && message.hasOwnProperty("stack")) {
                    if (!Array.isArray(message.stack))
                        return "stack: array expected";
                    for (var i = 0; i < message.stack.length; ++i) {
                        var error = $root.api.StackFrame.verify(message.stack[i]);
                        if (error)
                            return "stack." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DebugStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugStatus} DebugStatus
             */
            DebugStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugStatus)
                    return object;
                var message = new $root.api.DebugStatus();
                if (object.done != null)
                    message.done = Boolean(object.done);
                if (object.stack) {
                    if (!Array.isArray(object.stack))
                        throw TypeError(".api.DebugStatus.stack: array expected");
                    message.stack = [];
                    for (var i = 0; i < object.stack.length; ++i) {
                        if (typeof object.stack[i] !== "object")
                            throw TypeError(".api.DebugStatus.stack: object expected");
                        message.stack[i] = $root.api.StackFrame.fromObject(object.stack[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DebugStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugStatus
             * @static
             * @param {api.DebugStatus} message DebugStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.stack = [];
                if (options.defaults)
                    object.done = false;
                if (message.done != null && message.hasOwnProperty("done"))
                    object.done = message.done;
                if (message.stack && message.stack.length) {
                    object.stack = [];
                    for (var j = 0; j < message.stack.length; ++j)
                        object.stack[j] = $root.api.StackFrame.toObject(message.stack[j], options);
                }
                return object;
            };
    
            /**
             * Converts this DebugStatus to JSON.
             * @function toJSON
             * @memberof api.DebugStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugStatus;
        })();
    
        api.StackFrame = (function() {
    
            /**
             * Properties of a StackFrame.
             * @memberof api
             * @interface IStackFrame
             * @property {string|null} ["function"] StackFrame function
             * @property {number|null} [line] StackFrame line
             */
    
            /**
             * Constructs a new StackFrame.
             * @memberof api
             * @classdesc Represents a StackFrame.
             * @constructor
             * @param {api.IStackFrame=} [properties] Properties to set
             */
            function StackFrame(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StackFrame function.
             * @member {string} function
             * @memberof api.StackFrame
             * @instance
             */
            StackFrame.prototype["function"] = "";
    
            /**
             * StackFrame line.
             * @member {number} line
             * @memberof api.StackFrame
             * @instance
             */
            StackFrame.prototype.line = 0;
    
            /**
             * Creates a new StackFrame instance using the specified properties.
             * @function create
             * @memberof api.StackFrame
             * @static
             * @param {api.IStackFrame=} [properties] Properties to set
             * @returns {api.StackFrame} StackFrame instance
             */
            StackFrame.create = function create(properties) {
                return StackFrame.fromObject(properties);
            };
    
            /**
             * Encodes the specified StackFrame message. Does not implicitly {@link api.StackFrame.verify|verify} messages.
             * @function encode
             * @memberof api.StackFrame
             * @static
             * @param {api.StackFrame} message StackFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StackFrame.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["function"] != null && Object.hasOwnProperty.call(message, "function"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message["function"]);
                if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.line);
                return writer;
            };
    
            /**
             * Encodes the specified StackFrame message, length delimited. Does not implicitly {@link api.StackFrame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.StackFrame
             * @static
             * @param {api.StackFrame} message StackFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StackFrame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StackFrame message from the specified reader or buffer.
             * @function decode
             * @memberof api.StackFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.StackFrame} StackFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StackFrame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.StackFrame();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message["function"] = reader.string();
                        break;
                    case 2:
                        message.line = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StackFrame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.StackFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.StackFrame} StackFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StackFrame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StackFrame message.
             * @function verify
             * @memberof api.StackFrame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StackFrame.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message["function"] != null && message.hasOwnProperty("function"))
                    if (!$util.isString(message["function"]))
                        return "function: string expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                return null;
            };
    
            /**
             * Creates a StackFrame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.StackFrame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.StackFrame} StackFrame
             */
            StackFrame.fromObject = function fromObject(object) {
                if (object instanceof $root.api.StackFrame)
                    return object;
                var message = new $root.api.StackFrame();
                if (object["function"] != null)
                    message["function"] = String(object["function"]);
                if (object.line != null)
                    message.line = object.line >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a StackFrame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.StackFrame
             * @static
             * @param {api.StackFrame} message StackFrame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StackFrame.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object["function"] = "";
                    object.line = 0;
                }
                if (message["function"] != null && message.hasOwnProperty("function"))
                    object["function"] = message["function"];
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                return object;
            };
    
            /**
             * Converts this StackFrame to JSON.
             * @function toJSON
             * @memberof api.StackFrame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StackFrame.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StackFrame;
        })();
    
        api.ContainedTest = (function() {
    
            /**
             * Properties of a ContainedTest.
             * @memberof api
             * @interface IContainedTest
             * @property {api.File|api.IFile|null} [suite] ContainedTest suite
             * @property {Array.<api.File|api.IFile>|null} [project] ContainedTest project
             */
    
            /**
             * Constructs a new ContainedTest.
             * @memberof api
             * @classdesc Represents a ContainedTest.
             * @constructor
             * @param {api.IContainedTest=} [properties] Properties to set
             */
            function ContainedTest(properties) {
                this.project = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ContainedTest suite.
             * @member {api.File|null|undefined} suite
             * @memberof api.ContainedTest
             * @instance
             */
            ContainedTest.prototype.suite = null;
    
            /**
             * ContainedTest project.
             * @member {Array.<api.File>} project
             * @memberof api.ContainedTest
             * @instance
             */
            ContainedTest.prototype.project = $util.emptyArray;
    
            /**
             * Creates a new ContainedTest instance using the specified properties.
             * @function create
             * @memberof api.ContainedTest
             * @static
             * @param {api.IContainedTest=} [properties] Properties to set
             * @returns {api.ContainedTest} ContainedTest instance
             */
            ContainedTest.create = function create(properties) {
                return ContainedTest.fromObject(properties);
            };
    
            /**
             * Encodes the specified ContainedTest message. Does not implicitly {@link api.ContainedTest.verify|verify} messages.
             * @function encode
             * @memberof api.ContainedTest
             * @static
             * @param {api.ContainedTest} message ContainedTest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContainedTest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.suite != null && Object.hasOwnProperty.call(message, "suite"))
                    $root.api.File.encode(message.suite, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.project != null && message.project.length)
                    for (var i = 0; i < message.project.length; ++i)
                        $root.api.File.encode(message.project[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ContainedTest message, length delimited. Does not implicitly {@link api.ContainedTest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ContainedTest
             * @static
             * @param {api.ContainedTest} message ContainedTest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContainedTest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ContainedTest message from the specified reader or buffer.
             * @function decode
             * @memberof api.ContainedTest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ContainedTest} ContainedTest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContainedTest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ContainedTest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.suite = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.project && message.project.length))
                            message.project = [];
                        message.project.push($root.api.File.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ContainedTest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ContainedTest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ContainedTest} ContainedTest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContainedTest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ContainedTest message.
             * @function verify
             * @memberof api.ContainedTest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContainedTest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.suite != null && message.hasOwnProperty("suite")) {
                    var error = $root.api.File.verify(message.suite);
                    if (error)
                        return "suite." + error;
                }
                if (message.project != null && message.hasOwnProperty("project")) {
                    if (!Array.isArray(message.project))
                        return "project: array expected";
                    for (var i = 0; i < message.project.length; ++i) {
                        var error = $root.api.File.verify(message.project[i]);
                        if (error)
                            return "project." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ContainedTest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ContainedTest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ContainedTest} ContainedTest
             */
            ContainedTest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ContainedTest)
                    return object;
                var message = new $root.api.ContainedTest();
                if (object.suite != null) {
                    if (typeof object.suite !== "object")
                        throw TypeError(".api.ContainedTest.suite: object expected");
                    message.suite = $root.api.File.fromObject(object.suite);
                }
                if (object.project) {
                    if (!Array.isArray(object.project))
                        throw TypeError(".api.ContainedTest.project: array expected");
                    message.project = [];
                    for (var i = 0; i < object.project.length; ++i) {
                        if (typeof object.project[i] !== "object")
                            throw TypeError(".api.ContainedTest.project: object expected");
                        message.project[i] = $root.api.File.fromObject(object.project[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ContainedTest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ContainedTest
             * @static
             * @param {api.ContainedTest} message ContainedTest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContainedTest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.project = [];
                if (options.defaults)
                    object.suite = null;
                if (message.suite != null && message.hasOwnProperty("suite"))
                    object.suite = $root.api.File.toObject(message.suite, options);
                if (message.project && message.project.length) {
                    object.project = [];
                    for (var j = 0; j < message.project.length; ++j)
                        object.project[j] = $root.api.File.toObject(message.project[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ContainedTest to JSON.
             * @function toJSON
             * @memberof api.ContainedTest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContainedTest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ContainedTest;
        })();
    
        api.TestResult = (function() {
    
            /**
             * Properties of a TestResult.
             * @memberof api
             * @interface ITestResult
             * @property {boolean|null} [passed] TestResult passed
             * @property {string|null} [stderr] TestResult stderr
             * @property {Array.<api.TestFailure|api.ITestFailure>|null} [fails] TestResult fails
             */
    
            /**
             * Constructs a new TestResult.
             * @memberof api
             * @classdesc Represents a TestResult.
             * @constructor
             * @param {api.ITestResult=} [properties] Properties to set
             */
            function TestResult(properties) {
                this.fails = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TestResult passed.
             * @member {boolean} passed
             * @memberof api.TestResult
             * @instance
             */
            TestResult.prototype.passed = false;
    
            /**
             * TestResult stderr.
             * @member {string} stderr
             * @memberof api.TestResult
             * @instance
             */
            TestResult.prototype.stderr = "";
    
            /**
             * TestResult fails.
             * @member {Array.<api.TestFailure>} fails
             * @memberof api.TestResult
             * @instance
             */
            TestResult.prototype.fails = $util.emptyArray;
    
            /**
             * Creates a new TestResult instance using the specified properties.
             * @function create
             * @memberof api.TestResult
             * @static
             * @param {api.ITestResult=} [properties] Properties to set
             * @returns {api.TestResult} TestResult instance
             */
            TestResult.create = function create(properties) {
                return TestResult.fromObject(properties);
            };
    
            /**
             * Encodes the specified TestResult message. Does not implicitly {@link api.TestResult.verify|verify} messages.
             * @function encode
             * @memberof api.TestResult
             * @static
             * @param {api.TestResult} message TestResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.passed != null && Object.hasOwnProperty.call(message, "passed"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.passed);
                if (message.stderr != null && Object.hasOwnProperty.call(message, "stderr"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.stderr);
                if (message.fails != null && message.fails.length)
                    for (var i = 0; i < message.fails.length; ++i)
                        $root.api.TestFailure.encode(message.fails[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TestResult message, length delimited. Does not implicitly {@link api.TestResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.TestResult
             * @static
             * @param {api.TestResult} message TestResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TestResult message from the specified reader or buffer.
             * @function decode
             * @memberof api.TestResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.TestResult} TestResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TestResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.passed = reader.bool();
                        break;
                    case 2:
                        message.stderr = reader.string();
                        break;
                    case 3:
                        if (!(message.fails && message.fails.length))
                            message.fails = [];
                        message.fails.push($root.api.TestFailure.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TestResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.TestResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.TestResult} TestResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TestResult message.
             * @function verify
             * @memberof api.TestResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.passed != null && message.hasOwnProperty("passed"))
                    if (typeof message.passed !== "boolean")
                        return "passed: boolean expected";
                if (message.stderr != null && message.hasOwnProperty("stderr"))
                    if (!$util.isString(message.stderr))
                        return "stderr: string expected";
                if (message.fails != null && message.hasOwnProperty("fails")) {
                    if (!Array.isArray(message.fails))
                        return "fails: array expected";
                    for (var i = 0; i < message.fails.length; ++i) {
                        var error = $root.api.TestFailure.verify(message.fails[i]);
                        if (error)
                            return "fails." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.TestResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.TestResult} TestResult
             */
            TestResult.fromObject = function fromObject(object) {
                if (object instanceof $root.api.TestResult)
                    return object;
                var message = new $root.api.TestResult();
                if (object.passed != null)
                    message.passed = Boolean(object.passed);
                if (object.stderr != null)
                    message.stderr = String(object.stderr);
                if (object.fails) {
                    if (!Array.isArray(object.fails))
                        throw TypeError(".api.TestResult.fails: array expected");
                    message.fails = [];
                    for (var i = 0; i < object.fails.length; ++i) {
                        if (typeof object.fails[i] !== "object")
                            throw TypeError(".api.TestResult.fails: object expected");
                        message.fails[i] = $root.api.TestFailure.fromObject(object.fails[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TestResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.TestResult
             * @static
             * @param {api.TestResult} message TestResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fails = [];
                if (options.defaults) {
                    object.passed = false;
                    object.stderr = "";
                }
                if (message.passed != null && message.hasOwnProperty("passed"))
                    object.passed = message.passed;
                if (message.stderr != null && message.hasOwnProperty("stderr"))
                    object.stderr = message.stderr;
                if (message.fails && message.fails.length) {
                    object.fails = [];
                    for (var j = 0; j < message.fails.length; ++j)
                        object.fails[j] = $root.api.TestFailure.toObject(message.fails[j], options);
                }
                return object;
            };
    
            /**
             * Converts this TestResult to JSON.
             * @function toJSON
             * @memberof api.TestResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TestResult;
        })();
    
        api.TestFailure = (function() {
    
            /**
             * Properties of a TestFailure.
             * @memberof api
             * @interface ITestFailure
             * @property {string|null} [name] TestFailure name
             * @property {string|null} [trace] TestFailure trace
             */
    
            /**
             * Constructs a new TestFailure.
             * @memberof api
             * @classdesc Represents a TestFailure.
             * @constructor
             * @param {api.ITestFailure=} [properties] Properties to set
             */
            function TestFailure(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TestFailure name.
             * @member {string} name
             * @memberof api.TestFailure
             * @instance
             */
            TestFailure.prototype.name = "";
    
            /**
             * TestFailure trace.
             * @member {string} trace
             * @memberof api.TestFailure
             * @instance
             */
            TestFailure.prototype.trace = "";
    
            /**
             * Creates a new TestFailure instance using the specified properties.
             * @function create
             * @memberof api.TestFailure
             * @static
             * @param {api.ITestFailure=} [properties] Properties to set
             * @returns {api.TestFailure} TestFailure instance
             */
            TestFailure.create = function create(properties) {
                return TestFailure.fromObject(properties);
            };
    
            /**
             * Encodes the specified TestFailure message. Does not implicitly {@link api.TestFailure.verify|verify} messages.
             * @function encode
             * @memberof api.TestFailure
             * @static
             * @param {api.TestFailure} message TestFailure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestFailure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.trace);
                return writer;
            };
    
            /**
             * Encodes the specified TestFailure message, length delimited. Does not implicitly {@link api.TestFailure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.TestFailure
             * @static
             * @param {api.TestFailure} message TestFailure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TestFailure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TestFailure message from the specified reader or buffer.
             * @function decode
             * @memberof api.TestFailure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.TestFailure} TestFailure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestFailure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TestFailure();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.trace = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TestFailure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.TestFailure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.TestFailure} TestFailure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TestFailure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TestFailure message.
             * @function verify
             * @memberof api.TestFailure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TestFailure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.trace != null && message.hasOwnProperty("trace"))
                    if (!$util.isString(message.trace))
                        return "trace: string expected";
                return null;
            };
    
            /**
             * Creates a TestFailure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.TestFailure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.TestFailure} TestFailure
             */
            TestFailure.fromObject = function fromObject(object) {
                if (object instanceof $root.api.TestFailure)
                    return object;
                var message = new $root.api.TestFailure();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.trace != null)
                    message.trace = String(object.trace);
                return message;
            };
    
            /**
             * Creates a plain object from a TestFailure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.TestFailure
             * @static
             * @param {api.TestFailure} message TestFailure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TestFailure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.trace = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.trace != null && message.hasOwnProperty("trace"))
                    object.trace = message.trace;
                return object;
            };
    
            /**
             * Converts this TestFailure to JSON.
             * @function toJSON
             * @memberof api.TestFailure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TestFailure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TestFailure;
        })();
    
        api.ResizeTerm = (function() {
    
            /**
             * Properties of a ResizeTerm.
             * @memberof api
             * @interface IResizeTerm
             * @property {number|null} [rows] ResizeTerm rows
             * @property {number|null} [cols] ResizeTerm cols
             */
    
            /**
             * Constructs a new ResizeTerm.
             * @memberof api
             * @classdesc Represents a ResizeTerm.
             * @constructor
             * @param {api.IResizeTerm=} [properties] Properties to set
             */
            function ResizeTerm(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ResizeTerm rows.
             * @member {number} rows
             * @memberof api.ResizeTerm
             * @instance
             */
            ResizeTerm.prototype.rows = 0;
    
            /**
             * ResizeTerm cols.
             * @member {number} cols
             * @memberof api.ResizeTerm
             * @instance
             */
            ResizeTerm.prototype.cols = 0;
    
            /**
             * Creates a new ResizeTerm instance using the specified properties.
             * @function create
             * @memberof api.ResizeTerm
             * @static
             * @param {api.IResizeTerm=} [properties] Properties to set
             * @returns {api.ResizeTerm} ResizeTerm instance
             */
            ResizeTerm.create = function create(properties) {
                return ResizeTerm.fromObject(properties);
            };
    
            /**
             * Encodes the specified ResizeTerm message. Does not implicitly {@link api.ResizeTerm.verify|verify} messages.
             * @function encode
             * @memberof api.ResizeTerm
             * @static
             * @param {api.ResizeTerm} message ResizeTerm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResizeTerm.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
                if (message.cols != null && Object.hasOwnProperty.call(message, "cols"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
                return writer;
            };
    
            /**
             * Encodes the specified ResizeTerm message, length delimited. Does not implicitly {@link api.ResizeTerm.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ResizeTerm
             * @static
             * @param {api.ResizeTerm} message ResizeTerm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResizeTerm.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ResizeTerm message from the specified reader or buffer.
             * @function decode
             * @memberof api.ResizeTerm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ResizeTerm} ResizeTerm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResizeTerm.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResizeTerm();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rows = reader.uint32();
                        break;
                    case 2:
                        message.cols = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ResizeTerm message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ResizeTerm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ResizeTerm} ResizeTerm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResizeTerm.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ResizeTerm message.
             * @function verify
             * @memberof api.ResizeTerm
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResizeTerm.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows"))
                    if (!$util.isInteger(message.rows))
                        return "rows: integer expected";
                if (message.cols != null && message.hasOwnProperty("cols"))
                    if (!$util.isInteger(message.cols))
                        return "cols: integer expected";
                return null;
            };
    
            /**
             * Creates a ResizeTerm message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ResizeTerm
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ResizeTerm} ResizeTerm
             */
            ResizeTerm.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ResizeTerm)
                    return object;
                var message = new $root.api.ResizeTerm();
                if (object.rows != null)
                    message.rows = object.rows >>> 0;
                if (object.cols != null)
                    message.cols = object.cols >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a ResizeTerm message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ResizeTerm
             * @static
             * @param {api.ResizeTerm} message ResizeTerm
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResizeTerm.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.rows = 0;
                    object.cols = 0;
                }
                if (message.rows != null && message.hasOwnProperty("rows"))
                    object.rows = message.rows;
                if (message.cols != null && message.hasOwnProperty("cols"))
                    object.cols = message.cols;
                return object;
            };
    
            /**
             * Converts this ResizeTerm to JSON.
             * @function toJSON
             * @memberof api.ResizeTerm
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResizeTerm.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ResizeTerm;
        })();
    
        api.SaneTerm = (function() {
    
            /**
             * Properties of a SaneTerm.
             * @memberof api
             * @interface ISaneTerm
             */
    
            /**
             * Constructs a new SaneTerm.
             * @memberof api
             * @classdesc Represents a SaneTerm.
             * @constructor
             * @param {api.ISaneTerm=} [properties] Properties to set
             */
            function SaneTerm(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SaneTerm instance using the specified properties.
             * @function create
             * @memberof api.SaneTerm
             * @static
             * @param {api.ISaneTerm=} [properties] Properties to set
             * @returns {api.SaneTerm} SaneTerm instance
             */
            SaneTerm.create = function create(properties) {
                return SaneTerm.fromObject(properties);
            };
    
            /**
             * Encodes the specified SaneTerm message. Does not implicitly {@link api.SaneTerm.verify|verify} messages.
             * @function encode
             * @memberof api.SaneTerm
             * @static
             * @param {api.SaneTerm} message SaneTerm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaneTerm.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified SaneTerm message, length delimited. Does not implicitly {@link api.SaneTerm.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.SaneTerm
             * @static
             * @param {api.SaneTerm} message SaneTerm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaneTerm.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SaneTerm message from the specified reader or buffer.
             * @function decode
             * @memberof api.SaneTerm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.SaneTerm} SaneTerm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaneTerm.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SaneTerm();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SaneTerm message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.SaneTerm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.SaneTerm} SaneTerm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaneTerm.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SaneTerm message.
             * @function verify
             * @memberof api.SaneTerm
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaneTerm.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a SaneTerm message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.SaneTerm
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.SaneTerm} SaneTerm
             */
            SaneTerm.fromObject = function fromObject(object) {
                if (object instanceof $root.api.SaneTerm)
                    return object;
                return new $root.api.SaneTerm();
            };
    
            /**
             * Creates a plain object from a SaneTerm message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.SaneTerm
             * @static
             * @param {api.SaneTerm} message SaneTerm
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaneTerm.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this SaneTerm to JSON.
             * @function toJSON
             * @memberof api.SaneTerm
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaneTerm.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SaneTerm;
        })();
    
        api.LintResults = (function() {
    
            /**
             * Properties of a LintResults.
             * @memberof api
             * @interface ILintResults
             * @property {Array.<api.LintResult|api.ILintResult>|null} [results] LintResults results
             */
    
            /**
             * Constructs a new LintResults.
             * @memberof api
             * @classdesc Represents a LintResults.
             * @constructor
             * @param {api.ILintResults=} [properties] Properties to set
             */
            function LintResults(properties) {
                this.results = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LintResults results.
             * @member {Array.<api.LintResult>} results
             * @memberof api.LintResults
             * @instance
             */
            LintResults.prototype.results = $util.emptyArray;
    
            /**
             * Creates a new LintResults instance using the specified properties.
             * @function create
             * @memberof api.LintResults
             * @static
             * @param {api.ILintResults=} [properties] Properties to set
             * @returns {api.LintResults} LintResults instance
             */
            LintResults.create = function create(properties) {
                return LintResults.fromObject(properties);
            };
    
            /**
             * Encodes the specified LintResults message. Does not implicitly {@link api.LintResults.verify|verify} messages.
             * @function encode
             * @memberof api.LintResults
             * @static
             * @param {api.LintResults} message LintResults message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LintResults.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && message.results.length)
                    for (var i = 0; i < message.results.length; ++i)
                        $root.api.LintResult.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified LintResults message, length delimited. Does not implicitly {@link api.LintResults.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.LintResults
             * @static
             * @param {api.LintResults} message LintResults message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LintResults.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LintResults message from the specified reader or buffer.
             * @function decode
             * @memberof api.LintResults
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.LintResults} LintResults
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LintResults.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LintResults();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.results && message.results.length))
                            message.results = [];
                        message.results.push($root.api.LintResult.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LintResults message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.LintResults
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.LintResults} LintResults
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LintResults.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LintResults message.
             * @function verify
             * @memberof api.LintResults
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LintResults.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results")) {
                    if (!Array.isArray(message.results))
                        return "results: array expected";
                    for (var i = 0; i < message.results.length; ++i) {
                        var error = $root.api.LintResult.verify(message.results[i]);
                        if (error)
                            return "results." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a LintResults message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.LintResults
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.LintResults} LintResults
             */
            LintResults.fromObject = function fromObject(object) {
                if (object instanceof $root.api.LintResults)
                    return object;
                var message = new $root.api.LintResults();
                if (object.results) {
                    if (!Array.isArray(object.results))
                        throw TypeError(".api.LintResults.results: array expected");
                    message.results = [];
                    for (var i = 0; i < object.results.length; ++i) {
                        if (typeof object.results[i] !== "object")
                            throw TypeError(".api.LintResults.results: object expected");
                        message.results[i] = $root.api.LintResult.fromObject(object.results[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a LintResults message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.LintResults
             * @static
             * @param {api.LintResults} message LintResults
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LintResults.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.results = [];
                if (message.results && message.results.length) {
                    object.results = [];
                    for (var j = 0; j < message.results.length; ++j)
                        object.results[j] = $root.api.LintResult.toObject(message.results[j], options);
                }
                return object;
            };
    
            /**
             * Converts this LintResults to JSON.
             * @function toJSON
             * @memberof api.LintResults
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LintResults.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LintResults;
        })();
    
        api.LintResult = (function() {
    
            /**
             * Properties of a LintResult.
             * @memberof api
             * @interface ILintResult
             * @property {string|null} [text] LintResult text
             * @property {number|null} [row] LintResult row
             * @property {number|null} [column] LintResult column
             * @property {string|null} [type] LintResult type
             */
    
            /**
             * Constructs a new LintResult.
             * @memberof api
             * @classdesc Represents a LintResult.
             * @constructor
             * @param {api.ILintResult=} [properties] Properties to set
             */
            function LintResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LintResult text.
             * @member {string} text
             * @memberof api.LintResult
             * @instance
             */
            LintResult.prototype.text = "";
    
            /**
             * LintResult row.
             * @member {number} row
             * @memberof api.LintResult
             * @instance
             */
            LintResult.prototype.row = 0;
    
            /**
             * LintResult column.
             * @member {number} column
             * @memberof api.LintResult
             * @instance
             */
            LintResult.prototype.column = 0;
    
            /**
             * LintResult type.
             * @member {string} type
             * @memberof api.LintResult
             * @instance
             */
            LintResult.prototype.type = "";
    
            /**
             * Creates a new LintResult instance using the specified properties.
             * @function create
             * @memberof api.LintResult
             * @static
             * @param {api.ILintResult=} [properties] Properties to set
             * @returns {api.LintResult} LintResult instance
             */
            LintResult.create = function create(properties) {
                return LintResult.fromObject(properties);
            };
    
            /**
             * Encodes the specified LintResult message. Does not implicitly {@link api.LintResult.verify|verify} messages.
             * @function encode
             * @memberof api.LintResult
             * @static
             * @param {api.LintResult} message LintResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LintResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.row);
                if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.column);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
                return writer;
            };
    
            /**
             * Encodes the specified LintResult message, length delimited. Does not implicitly {@link api.LintResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.LintResult
             * @static
             * @param {api.LintResult} message LintResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LintResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LintResult message from the specified reader or buffer.
             * @function decode
             * @memberof api.LintResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.LintResult} LintResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LintResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LintResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.text = reader.string();
                        break;
                    case 2:
                        message.row = reader.int32();
                        break;
                    case 3:
                        message.column = reader.int32();
                        break;
                    case 4:
                        message.type = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LintResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.LintResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.LintResult} LintResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LintResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LintResult message.
             * @function verify
             * @memberof api.LintResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LintResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                if (message.row != null && message.hasOwnProperty("row"))
                    if (!$util.isInteger(message.row))
                        return "row: integer expected";
                if (message.column != null && message.hasOwnProperty("column"))
                    if (!$util.isInteger(message.column))
                        return "column: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                return null;
            };
    
            /**
             * Creates a LintResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.LintResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.LintResult} LintResult
             */
            LintResult.fromObject = function fromObject(object) {
                if (object instanceof $root.api.LintResult)
                    return object;
                var message = new $root.api.LintResult();
                if (object.text != null)
                    message.text = String(object.text);
                if (object.row != null)
                    message.row = object.row | 0;
                if (object.column != null)
                    message.column = object.column | 0;
                if (object.type != null)
                    message.type = String(object.type);
                return message;
            };
    
            /**
             * Creates a plain object from a LintResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.LintResult
             * @static
             * @param {api.LintResult} message LintResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LintResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.text = "";
                    object.row = 0;
                    object.column = 0;
                    object.type = "";
                }
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = message.row;
                if (message.column != null && message.hasOwnProperty("column"))
                    object.column = message.column;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                return object;
            };
    
            /**
             * Converts this LintResult to JSON.
             * @function toJSON
             * @memberof api.LintResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LintResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LintResult;
        })();
    
        api.OK = (function() {
    
            /**
             * Properties of a OK.
             * @memberof api
             * @interface IOK
             */
    
            /**
             * Constructs a new OK.
             * @memberof api
             * @classdesc Represents a OK.
             * @constructor
             * @param {api.IOK=} [properties] Properties to set
             */
            function OK(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new OK instance using the specified properties.
             * @function create
             * @memberof api.OK
             * @static
             * @param {api.IOK=} [properties] Properties to set
             * @returns {api.OK} OK instance
             */
            OK.create = function create(properties) {
                return OK.fromObject(properties);
            };
    
            /**
             * Encodes the specified OK message. Does not implicitly {@link api.OK.verify|verify} messages.
             * @function encode
             * @memberof api.OK
             * @static
             * @param {api.OK} message OK message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OK.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified OK message, length delimited. Does not implicitly {@link api.OK.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OK
             * @static
             * @param {api.OK} message OK message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OK.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OK message from the specified reader or buffer.
             * @function decode
             * @memberof api.OK
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OK} OK
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OK.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OK();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OK message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OK
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OK} OK
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OK.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OK message.
             * @function verify
             * @memberof api.OK
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OK.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a OK message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OK
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OK} OK
             */
            OK.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OK)
                    return object;
                return new $root.api.OK();
            };
    
            /**
             * Creates a plain object from a OK message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OK
             * @static
             * @param {api.OK} message OK
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OK.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this OK to JSON.
             * @function toJSON
             * @memberof api.OK
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OK.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OK;
        })();
    
        api.Move = (function() {
    
            /**
             * Properties of a Move.
             * @memberof api
             * @interface IMove
             * @property {string|null} [oldPath] Move oldPath
             * @property {string|null} [newPath] Move newPath
             */
    
            /**
             * Constructs a new Move.
             * @memberof api
             * @classdesc Represents a Move.
             * @constructor
             * @param {api.IMove=} [properties] Properties to set
             */
            function Move(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Move oldPath.
             * @member {string} oldPath
             * @memberof api.Move
             * @instance
             */
            Move.prototype.oldPath = "";
    
            /**
             * Move newPath.
             * @member {string} newPath
             * @memberof api.Move
             * @instance
             */
            Move.prototype.newPath = "";
    
            /**
             * Creates a new Move instance using the specified properties.
             * @function create
             * @memberof api.Move
             * @static
             * @param {api.IMove=} [properties] Properties to set
             * @returns {api.Move} Move instance
             */
            Move.create = function create(properties) {
                return Move.fromObject(properties);
            };
    
            /**
             * Encodes the specified Move message. Does not implicitly {@link api.Move.verify|verify} messages.
             * @function encode
             * @memberof api.Move
             * @static
             * @param {api.Move} message Move message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Move.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.oldPath != null && Object.hasOwnProperty.call(message, "oldPath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.oldPath);
                if (message.newPath != null && Object.hasOwnProperty.call(message, "newPath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.newPath);
                return writer;
            };
    
            /**
             * Encodes the specified Move message, length delimited. Does not implicitly {@link api.Move.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Move
             * @static
             * @param {api.Move} message Move message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Move.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Move message from the specified reader or buffer.
             * @function decode
             * @memberof api.Move
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Move} Move
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Move.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Move();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.oldPath = reader.string();
                        break;
                    case 2:
                        message.newPath = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Move message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Move
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Move} Move
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Move.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Move message.
             * @function verify
             * @memberof api.Move
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Move.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.oldPath != null && message.hasOwnProperty("oldPath"))
                    if (!$util.isString(message.oldPath))
                        return "oldPath: string expected";
                if (message.newPath != null && message.hasOwnProperty("newPath"))
                    if (!$util.isString(message.newPath))
                        return "newPath: string expected";
                return null;
            };
    
            /**
             * Creates a Move message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Move
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Move} Move
             */
            Move.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Move)
                    return object;
                var message = new $root.api.Move();
                if (object.oldPath != null)
                    message.oldPath = String(object.oldPath);
                if (object.newPath != null)
                    message.newPath = String(object.newPath);
                return message;
            };
    
            /**
             * Creates a plain object from a Move message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Move
             * @static
             * @param {api.Move} message Move
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Move.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.oldPath = "";
                    object.newPath = "";
                }
                if (message.oldPath != null && message.hasOwnProperty("oldPath"))
                    object.oldPath = message.oldPath;
                if (message.newPath != null && message.hasOwnProperty("newPath"))
                    object.newPath = message.newPath;
                return object;
            };
    
            /**
             * Converts this Move to JSON.
             * @function toJSON
             * @memberof api.Move
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Move.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Move;
        })();
    
        api.Files = (function() {
    
            /**
             * Properties of a Files.
             * @memberof api
             * @interface IFiles
             * @property {Array.<api.File|api.IFile>|null} [files] Files files
             */
    
            /**
             * Constructs a new Files.
             * @memberof api
             * @classdesc Represents a Files.
             * @constructor
             * @param {api.IFiles=} [properties] Properties to set
             */
            function Files(properties) {
                this.files = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Files files.
             * @member {Array.<api.File>} files
             * @memberof api.Files
             * @instance
             */
            Files.prototype.files = $util.emptyArray;
    
            /**
             * Creates a new Files instance using the specified properties.
             * @function create
             * @memberof api.Files
             * @static
             * @param {api.IFiles=} [properties] Properties to set
             * @returns {api.Files} Files instance
             */
            Files.create = function create(properties) {
                return Files.fromObject(properties);
            };
    
            /**
             * Encodes the specified Files message. Does not implicitly {@link api.Files.verify|verify} messages.
             * @function encode
             * @memberof api.Files
             * @static
             * @param {api.Files} message Files message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Files.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        $root.api.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Files message, length delimited. Does not implicitly {@link api.Files.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Files
             * @static
             * @param {api.Files} message Files message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Files.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Files message from the specified reader or buffer.
             * @function decode
             * @memberof api.Files
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Files} Files
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Files.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Files();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.files && message.files.length))
                            message.files = [];
                        message.files.push($root.api.File.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Files message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Files
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Files} Files
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Files.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Files message.
             * @function verify
             * @memberof api.Files
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Files.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i) {
                        var error = $root.api.File.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Files message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Files
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Files} Files
             */
            Files.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Files)
                    return object;
                var message = new $root.api.Files();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".api.Files.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".api.Files.files: object expected");
                        message.files[i] = $root.api.File.fromObject(object.files[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Files message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Files
             * @static
             * @param {api.Files} message Files
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Files.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.files = [];
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.api.File.toObject(message.files[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Files to JSON.
             * @function toJSON
             * @memberof api.Files
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Files.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Files;
        })();
    
        api.StatResult = (function() {
    
            /**
             * Properties of a StatResult.
             * @memberof api
             * @interface IStatResult
             * @property {boolean|null} [exists] StatResult exists
             * @property {api.File.Type|null} [type] StatResult type
             * @property {number|null} [size] StatResult size
             * @property {string|null} [fileMode] StatResult fileMode
             * @property {number|null} [modTime] StatResult modTime
             */
    
            /**
             * Constructs a new StatResult.
             * @memberof api
             * @classdesc Represents a StatResult.
             * @constructor
             * @param {api.IStatResult=} [properties] Properties to set
             */
            function StatResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StatResult exists.
             * @member {boolean} exists
             * @memberof api.StatResult
             * @instance
             */
            StatResult.prototype.exists = false;
    
            /**
             * StatResult type.
             * @member {api.File.Type} type
             * @memberof api.StatResult
             * @instance
             */
            StatResult.prototype.type = 0;
    
            /**
             * StatResult size.
             * @member {number} size
             * @memberof api.StatResult
             * @instance
             */
            StatResult.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * StatResult fileMode.
             * @member {string} fileMode
             * @memberof api.StatResult
             * @instance
             */
            StatResult.prototype.fileMode = "";
    
            /**
             * StatResult modTime.
             * @member {number} modTime
             * @memberof api.StatResult
             * @instance
             */
            StatResult.prototype.modTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new StatResult instance using the specified properties.
             * @function create
             * @memberof api.StatResult
             * @static
             * @param {api.IStatResult=} [properties] Properties to set
             * @returns {api.StatResult} StatResult instance
             */
            StatResult.create = function create(properties) {
                return StatResult.fromObject(properties);
            };
    
            /**
             * Encodes the specified StatResult message. Does not implicitly {@link api.StatResult.verify|verify} messages.
             * @function encode
             * @memberof api.StatResult
             * @static
             * @param {api.StatResult} message StatResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StatResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exists != null && Object.hasOwnProperty.call(message, "exists"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.exists);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.size);
                if (message.fileMode != null && Object.hasOwnProperty.call(message, "fileMode"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileMode);
                if (message.modTime != null && Object.hasOwnProperty.call(message, "modTime"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.modTime);
                return writer;
            };
    
            /**
             * Encodes the specified StatResult message, length delimited. Does not implicitly {@link api.StatResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.StatResult
             * @static
             * @param {api.StatResult} message StatResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StatResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StatResult message from the specified reader or buffer.
             * @function decode
             * @memberof api.StatResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.StatResult} StatResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StatResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.StatResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exists = reader.bool();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.size = reader.int64();
                        break;
                    case 4:
                        message.fileMode = reader.string();
                        break;
                    case 5:
                        message.modTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StatResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.StatResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.StatResult} StatResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StatResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StatResult message.
             * @function verify
             * @memberof api.StatResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StatResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exists != null && message.hasOwnProperty("exists"))
                    if (typeof message.exists !== "boolean")
                        return "exists: boolean expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                if (message.fileMode != null && message.hasOwnProperty("fileMode"))
                    if (!$util.isString(message.fileMode))
                        return "fileMode: string expected";
                if (message.modTime != null && message.hasOwnProperty("modTime"))
                    if (!$util.isInteger(message.modTime) && !(message.modTime && $util.isInteger(message.modTime.low) && $util.isInteger(message.modTime.high)))
                        return "modTime: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a StatResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.StatResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.StatResult} StatResult
             */
            StatResult.fromObject = function fromObject(object) {
                if (object instanceof $root.api.StatResult)
                    return object;
                var message = new $root.api.StatResult();
                if (object.exists != null)
                    message.exists = Boolean(object.exists);
                switch (object.type) {
                case "REGULAR":
                case 0:
                    message.type = 0;
                    break;
                case "DIRECTORY":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
                if (object.fileMode != null)
                    message.fileMode = String(object.fileMode);
                if (object.modTime != null)
                    if ($util.Long)
                        (message.modTime = $util.Long.fromValue(object.modTime)).unsigned = false;
                    else if (typeof object.modTime === "string")
                        message.modTime = parseInt(object.modTime, 10);
                    else if (typeof object.modTime === "number")
                        message.modTime = object.modTime;
                    else if (typeof object.modTime === "object")
                        message.modTime = new $util.LongBits(object.modTime.low >>> 0, object.modTime.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a StatResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.StatResult
             * @static
             * @param {api.StatResult} message StatResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StatResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.exists = false;
                    object.type = options.enums === String ? "REGULAR" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.size = options.longs === String ? "0" : 0;
                    object.fileMode = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.modTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.modTime = options.longs === String ? "0" : 0;
                }
                if (message.exists != null && message.hasOwnProperty("exists"))
                    object.exists = message.exists;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.api.File.Type[message.type] : message.type;
                if (message.size != null && message.hasOwnProperty("size"))
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
                if (message.fileMode != null && message.hasOwnProperty("fileMode"))
                    object.fileMode = message.fileMode;
                if (message.modTime != null && message.hasOwnProperty("modTime"))
                    if (typeof message.modTime === "number")
                        object.modTime = options.longs === String ? String(message.modTime) : message.modTime;
                    else
                        object.modTime = options.longs === String ? $util.Long.prototype.toString.call(message.modTime) : options.longs === Number ? new $util.LongBits(message.modTime.low >>> 0, message.modTime.high >>> 0).toNumber() : message.modTime;
                return object;
            };
    
            /**
             * Converts this StatResult to JSON.
             * @function toJSON
             * @memberof api.StatResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StatResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StatResult;
        })();
    
        api.File = (function() {
    
            /**
             * Properties of a File.
             * @memberof api
             * @interface IFile
             * @property {string|null} [path] File path
             * @property {api.File.Type|null} [type] File type
             * @property {Uint8Array|null} [content] File content
             */
    
            /**
             * Constructs a new File.
             * @memberof api
             * @classdesc Represents a File.
             * @constructor
             * @param {api.IFile=} [properties] Properties to set
             */
            function File(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * File path.
             * @member {string} path
             * @memberof api.File
             * @instance
             */
            File.prototype.path = "";
    
            /**
             * File type.
             * @member {api.File.Type} type
             * @memberof api.File
             * @instance
             */
            File.prototype.type = 0;
    
            /**
             * File content.
             * @member {Uint8Array} content
             * @memberof api.File
             * @instance
             */
            File.prototype.content = $util.newBuffer([]);
    
            /**
             * Creates a new File instance using the specified properties.
             * @function create
             * @memberof api.File
             * @static
             * @param {api.IFile=} [properties] Properties to set
             * @returns {api.File} File instance
             */
            File.create = function create(properties) {
                return File.fromObject(properties);
            };
    
            /**
             * Encodes the specified File message. Does not implicitly {@link api.File.verify|verify} messages.
             * @function encode
             * @memberof api.File
             * @static
             * @param {api.File} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.content);
                return writer;
            };
    
            /**
             * Encodes the specified File message, length delimited. Does not implicitly {@link api.File.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.File
             * @static
             * @param {api.File} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a File message from the specified reader or buffer.
             * @function decode
             * @memberof api.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.File();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.content = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a File message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a File message.
             * @function verify
             * @memberof api.File
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            File.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                        return "content: buffer expected";
                return null;
            };
    
            /**
             * Creates a File message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.File
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.File} File
             */
            File.fromObject = function fromObject(object) {
                if (object instanceof $root.api.File)
                    return object;
                var message = new $root.api.File();
                if (object.path != null)
                    message.path = String(object.path);
                switch (object.type) {
                case "REGULAR":
                case 0:
                    message.type = 0;
                    break;
                case "DIRECTORY":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length)
                        message.content = object.content;
                return message;
            };
    
            /**
             * Creates a plain object from a File message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.File
             * @static
             * @param {api.File} message File
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            File.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.type = options.enums === String ? "REGULAR" : 0;
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.api.File.Type[message.type] : message.type;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                return object;
            };
    
            /**
             * Converts this File to JSON.
             * @function toJSON
             * @memberof api.File
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            File.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Type enum.
             * @name api.File.Type
             * @enum {number}
             * @property {number} REGULAR=0 REGULAR value
             * @property {number} DIRECTORY=1 DIRECTORY value
             */
            File.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "REGULAR"] = 0;
                values[valuesById[1] = "DIRECTORY"] = 1;
                return values;
            })();
    
            return File;
        })();
    
        api.Transfer = (function() {
    
            /**
             * Properties of a Transfer.
             * @memberof api
             * @interface ITransfer
             * @property {string|null} [id] Transfer id
             */
    
            /**
             * Constructs a new Transfer.
             * @memberof api
             * @classdesc Represents a Transfer.
             * @constructor
             * @param {api.ITransfer=} [properties] Properties to set
             */
            function Transfer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Transfer id.
             * @member {string} id
             * @memberof api.Transfer
             * @instance
             */
            Transfer.prototype.id = "";
    
            /**
             * Creates a new Transfer instance using the specified properties.
             * @function create
             * @memberof api.Transfer
             * @static
             * @param {api.ITransfer=} [properties] Properties to set
             * @returns {api.Transfer} Transfer instance
             */
            Transfer.create = function create(properties) {
                return Transfer.fromObject(properties);
            };
    
            /**
             * Encodes the specified Transfer message. Does not implicitly {@link api.Transfer.verify|verify} messages.
             * @function encode
             * @memberof api.Transfer
             * @static
             * @param {api.Transfer} message Transfer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transfer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified Transfer message, length delimited. Does not implicitly {@link api.Transfer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Transfer
             * @static
             * @param {api.Transfer} message Transfer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transfer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Transfer message from the specified reader or buffer.
             * @function decode
             * @memberof api.Transfer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Transfer} Transfer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transfer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Transfer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Transfer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Transfer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Transfer} Transfer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transfer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Transfer message.
             * @function verify
             * @memberof api.Transfer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Transfer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };
    
            /**
             * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Transfer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Transfer} Transfer
             */
            Transfer.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Transfer)
                    return object;
                var message = new $root.api.Transfer();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };
    
            /**
             * Creates a plain object from a Transfer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Transfer
             * @static
             * @param {api.Transfer} message Transfer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transfer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };
    
            /**
             * Converts this Transfer to JSON.
             * @function toJSON
             * @memberof api.Transfer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Transfer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Transfer;
        })();
    
        api.TransferStart = (function() {
    
            /**
             * Properties of a TransferStart.
             * @memberof api
             * @interface ITransferStart
             * @property {string|null} [path] TransferStart path
             * @property {number|null} [size] TransferStart size
             */
    
            /**
             * Constructs a new TransferStart.
             * @memberof api
             * @classdesc Represents a TransferStart.
             * @constructor
             * @param {api.ITransferStart=} [properties] Properties to set
             */
            function TransferStart(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TransferStart path.
             * @member {string} path
             * @memberof api.TransferStart
             * @instance
             */
            TransferStart.prototype.path = "";
    
            /**
             * TransferStart size.
             * @member {number} size
             * @memberof api.TransferStart
             * @instance
             */
            TransferStart.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new TransferStart instance using the specified properties.
             * @function create
             * @memberof api.TransferStart
             * @static
             * @param {api.ITransferStart=} [properties] Properties to set
             * @returns {api.TransferStart} TransferStart instance
             */
            TransferStart.create = function create(properties) {
                return TransferStart.fromObject(properties);
            };
    
            /**
             * Encodes the specified TransferStart message. Does not implicitly {@link api.TransferStart.verify|verify} messages.
             * @function encode
             * @memberof api.TransferStart
             * @static
             * @param {api.TransferStart} message TransferStart message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferStart.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size);
                return writer;
            };
    
            /**
             * Encodes the specified TransferStart message, length delimited. Does not implicitly {@link api.TransferStart.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.TransferStart
             * @static
             * @param {api.TransferStart} message TransferStart message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferStart.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TransferStart message from the specified reader or buffer.
             * @function decode
             * @memberof api.TransferStart
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.TransferStart} TransferStart
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferStart.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TransferStart();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.size = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TransferStart message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.TransferStart
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.TransferStart} TransferStart
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferStart.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TransferStart message.
             * @function verify
             * @memberof api.TransferStart
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransferStart.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a TransferStart message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.TransferStart
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.TransferStart} TransferStart
             */
            TransferStart.fromObject = function fromObject(object) {
                if (object instanceof $root.api.TransferStart)
                    return object;
                var message = new $root.api.TransferStart();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a TransferStart message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.TransferStart
             * @static
             * @param {api.TransferStart} message TransferStart
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransferStart.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.size = options.longs === String ? "0" : 0;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.size != null && message.hasOwnProperty("size"))
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
                return object;
            };
    
            /**
             * Converts this TransferStart to JSON.
             * @function toJSON
             * @memberof api.TransferStart
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransferStart.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TransferStart;
        })();
    
        api.TransferChunk = (function() {
    
            /**
             * Properties of a TransferChunk.
             * @memberof api
             * @interface ITransferChunk
             * @property {string|null} [id] TransferChunk id
             * @property {Uint8Array|null} [content] TransferChunk content
             */
    
            /**
             * Constructs a new TransferChunk.
             * @memberof api
             * @classdesc Represents a TransferChunk.
             * @constructor
             * @param {api.ITransferChunk=} [properties] Properties to set
             */
            function TransferChunk(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TransferChunk id.
             * @member {string} id
             * @memberof api.TransferChunk
             * @instance
             */
            TransferChunk.prototype.id = "";
    
            /**
             * TransferChunk content.
             * @member {Uint8Array} content
             * @memberof api.TransferChunk
             * @instance
             */
            TransferChunk.prototype.content = $util.newBuffer([]);
    
            /**
             * Creates a new TransferChunk instance using the specified properties.
             * @function create
             * @memberof api.TransferChunk
             * @static
             * @param {api.ITransferChunk=} [properties] Properties to set
             * @returns {api.TransferChunk} TransferChunk instance
             */
            TransferChunk.create = function create(properties) {
                return TransferChunk.fromObject(properties);
            };
    
            /**
             * Encodes the specified TransferChunk message. Does not implicitly {@link api.TransferChunk.verify|verify} messages.
             * @function encode
             * @memberof api.TransferChunk
             * @static
             * @param {api.TransferChunk} message TransferChunk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferChunk.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
                return writer;
            };
    
            /**
             * Encodes the specified TransferChunk message, length delimited. Does not implicitly {@link api.TransferChunk.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.TransferChunk
             * @static
             * @param {api.TransferChunk} message TransferChunk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferChunk.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TransferChunk message from the specified reader or buffer.
             * @function decode
             * @memberof api.TransferChunk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.TransferChunk} TransferChunk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferChunk.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TransferChunk();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.content = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TransferChunk message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.TransferChunk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.TransferChunk} TransferChunk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferChunk.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TransferChunk message.
             * @function verify
             * @memberof api.TransferChunk
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransferChunk.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                        return "content: buffer expected";
                return null;
            };
    
            /**
             * Creates a TransferChunk message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.TransferChunk
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.TransferChunk} TransferChunk
             */
            TransferChunk.fromObject = function fromObject(object) {
                if (object instanceof $root.api.TransferChunk)
                    return object;
                var message = new $root.api.TransferChunk();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length)
                        message.content = object.content;
                return message;
            };
    
            /**
             * Creates a plain object from a TransferChunk message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.TransferChunk
             * @static
             * @param {api.TransferChunk} message TransferChunk
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransferChunk.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                return object;
            };
    
            /**
             * Converts this TransferChunk to JSON.
             * @function toJSON
             * @memberof api.TransferChunk
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransferChunk.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TransferChunk;
        })();
    
        api.TransferComplete = (function() {
    
            /**
             * Properties of a TransferComplete.
             * @memberof api
             * @interface ITransferComplete
             * @property {string|null} [id] TransferComplete id
             * @property {number|null} [crc32] TransferComplete crc32
             */
    
            /**
             * Constructs a new TransferComplete.
             * @memberof api
             * @classdesc Represents a TransferComplete.
             * @constructor
             * @param {api.ITransferComplete=} [properties] Properties to set
             */
            function TransferComplete(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TransferComplete id.
             * @member {string} id
             * @memberof api.TransferComplete
             * @instance
             */
            TransferComplete.prototype.id = "";
    
            /**
             * TransferComplete crc32.
             * @member {number} crc32
             * @memberof api.TransferComplete
             * @instance
             */
            TransferComplete.prototype.crc32 = 0;
    
            /**
             * Creates a new TransferComplete instance using the specified properties.
             * @function create
             * @memberof api.TransferComplete
             * @static
             * @param {api.ITransferComplete=} [properties] Properties to set
             * @returns {api.TransferComplete} TransferComplete instance
             */
            TransferComplete.create = function create(properties) {
                return TransferComplete.fromObject(properties);
            };
    
            /**
             * Encodes the specified TransferComplete message. Does not implicitly {@link api.TransferComplete.verify|verify} messages.
             * @function encode
             * @memberof api.TransferComplete
             * @static
             * @param {api.TransferComplete} message TransferComplete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferComplete.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.crc32 != null && Object.hasOwnProperty.call(message, "crc32"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.crc32);
                return writer;
            };
    
            /**
             * Encodes the specified TransferComplete message, length delimited. Does not implicitly {@link api.TransferComplete.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.TransferComplete
             * @static
             * @param {api.TransferComplete} message TransferComplete message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferComplete.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TransferComplete message from the specified reader or buffer.
             * @function decode
             * @memberof api.TransferComplete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.TransferComplete} TransferComplete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferComplete.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TransferComplete();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.crc32 = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TransferComplete message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.TransferComplete
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.TransferComplete} TransferComplete
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferComplete.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TransferComplete message.
             * @function verify
             * @memberof api.TransferComplete
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransferComplete.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.crc32 != null && message.hasOwnProperty("crc32"))
                    if (!$util.isInteger(message.crc32))
                        return "crc32: integer expected";
                return null;
            };
    
            /**
             * Creates a TransferComplete message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.TransferComplete
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.TransferComplete} TransferComplete
             */
            TransferComplete.fromObject = function fromObject(object) {
                if (object instanceof $root.api.TransferComplete)
                    return object;
                var message = new $root.api.TransferComplete();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.crc32 != null)
                    message.crc32 = object.crc32 >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a TransferComplete message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.TransferComplete
             * @static
             * @param {api.TransferComplete} message TransferComplete
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransferComplete.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.crc32 = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.crc32 != null && message.hasOwnProperty("crc32"))
                    object.crc32 = message.crc32;
                return object;
            };
    
            /**
             * Converts this TransferComplete to JSON.
             * @function toJSON
             * @memberof api.TransferComplete
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransferComplete.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TransferComplete;
        })();
    
        api.Clear = (function() {
    
            /**
             * Properties of a Clear.
             * @memberof api
             * @interface IClear
             */
    
            /**
             * Constructs a new Clear.
             * @memberof api
             * @classdesc Represents a Clear.
             * @constructor
             * @param {api.IClear=} [properties] Properties to set
             */
            function Clear(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Clear instance using the specified properties.
             * @function create
             * @memberof api.Clear
             * @static
             * @param {api.IClear=} [properties] Properties to set
             * @returns {api.Clear} Clear instance
             */
            Clear.create = function create(properties) {
                return Clear.fromObject(properties);
            };
    
            /**
             * Encodes the specified Clear message. Does not implicitly {@link api.Clear.verify|verify} messages.
             * @function encode
             * @memberof api.Clear
             * @static
             * @param {api.Clear} message Clear message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Clear.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Clear message, length delimited. Does not implicitly {@link api.Clear.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Clear
             * @static
             * @param {api.Clear} message Clear message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Clear.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Clear message from the specified reader or buffer.
             * @function decode
             * @memberof api.Clear
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Clear} Clear
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Clear.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Clear();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Clear message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Clear
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Clear} Clear
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Clear.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Clear message.
             * @function verify
             * @memberof api.Clear
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Clear.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Clear message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Clear
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Clear} Clear
             */
            Clear.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Clear)
                    return object;
                return new $root.api.Clear();
            };
    
            /**
             * Creates a plain object from a Clear message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Clear
             * @static
             * @param {api.Clear} message Clear
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Clear.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Clear to JSON.
             * @function toJSON
             * @memberof api.Clear
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Clear.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Clear;
        })();
    
        api.Toast = (function() {
    
            /**
             * Properties of a Toast.
             * @memberof api
             * @interface IToast
             * @property {string|null} [text] Toast text
             */
    
            /**
             * Constructs a new Toast.
             * @memberof api
             * @classdesc Represents a Toast.
             * @constructor
             * @param {api.IToast=} [properties] Properties to set
             */
            function Toast(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Toast text.
             * @member {string} text
             * @memberof api.Toast
             * @instance
             */
            Toast.prototype.text = "";
    
            /**
             * Creates a new Toast instance using the specified properties.
             * @function create
             * @memberof api.Toast
             * @static
             * @param {api.IToast=} [properties] Properties to set
             * @returns {api.Toast} Toast instance
             */
            Toast.create = function create(properties) {
                return Toast.fromObject(properties);
            };
    
            /**
             * Encodes the specified Toast message. Does not implicitly {@link api.Toast.verify|verify} messages.
             * @function encode
             * @memberof api.Toast
             * @static
             * @param {api.Toast} message Toast message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Toast.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };
    
            /**
             * Encodes the specified Toast message, length delimited. Does not implicitly {@link api.Toast.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Toast
             * @static
             * @param {api.Toast} message Toast message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Toast.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Toast message from the specified reader or buffer.
             * @function decode
             * @memberof api.Toast
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Toast} Toast
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Toast.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Toast();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.text = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Toast message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Toast
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Toast} Toast
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Toast.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Toast message.
             * @function verify
             * @memberof api.Toast
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Toast.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };
    
            /**
             * Creates a Toast message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Toast
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Toast} Toast
             */
            Toast.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Toast)
                    return object;
                var message = new $root.api.Toast();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };
    
            /**
             * Creates a plain object from a Toast message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Toast
             * @static
             * @param {api.Toast} message Toast
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Toast.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };
    
            /**
             * Converts this Toast to JSON.
             * @function toJSON
             * @memberof api.Toast
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Toast.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Toast;
        })();
    
        api.Redirect = (function() {
    
            /**
             * Properties of a Redirect.
             * @memberof api
             * @interface IRedirect
             * @property {string|null} [url] Redirect url
             */
    
            /**
             * Constructs a new Redirect.
             * @memberof api
             * @classdesc Represents a Redirect.
             * @constructor
             * @param {api.IRedirect=} [properties] Properties to set
             */
            function Redirect(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Redirect url.
             * @member {string} url
             * @memberof api.Redirect
             * @instance
             */
            Redirect.prototype.url = "";
    
            /**
             * Creates a new Redirect instance using the specified properties.
             * @function create
             * @memberof api.Redirect
             * @static
             * @param {api.IRedirect=} [properties] Properties to set
             * @returns {api.Redirect} Redirect instance
             */
            Redirect.create = function create(properties) {
                return Redirect.fromObject(properties);
            };
    
            /**
             * Encodes the specified Redirect message. Does not implicitly {@link api.Redirect.verify|verify} messages.
             * @function encode
             * @memberof api.Redirect
             * @static
             * @param {api.Redirect} message Redirect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Redirect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                return writer;
            };
    
            /**
             * Encodes the specified Redirect message, length delimited. Does not implicitly {@link api.Redirect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Redirect
             * @static
             * @param {api.Redirect} message Redirect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Redirect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Redirect message from the specified reader or buffer.
             * @function decode
             * @memberof api.Redirect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Redirect} Redirect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Redirect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Redirect();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Redirect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Redirect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Redirect} Redirect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Redirect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Redirect message.
             * @function verify
             * @memberof api.Redirect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Redirect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };
    
            /**
             * Creates a Redirect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Redirect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Redirect} Redirect
             */
            Redirect.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Redirect)
                    return object;
                var message = new $root.api.Redirect();
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };
    
            /**
             * Creates a plain object from a Redirect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Redirect
             * @static
             * @param {api.Redirect} message Redirect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Redirect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.url = "";
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };
    
            /**
             * Converts this Redirect to JSON.
             * @function toJSON
             * @memberof api.Redirect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Redirect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Redirect;
        })();
    
        api.AlwaysOn = (function() {
    
            /**
             * Properties of an AlwaysOn.
             * @memberof api
             * @interface IAlwaysOn
             * @property {boolean|null} [enable] AlwaysOn enable
             */
    
            /**
             * Constructs a new AlwaysOn.
             * @memberof api
             * @classdesc Represents an AlwaysOn.
             * @constructor
             * @param {api.IAlwaysOn=} [properties] Properties to set
             */
            function AlwaysOn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AlwaysOn enable.
             * @member {boolean} enable
             * @memberof api.AlwaysOn
             * @instance
             */
            AlwaysOn.prototype.enable = false;
    
            /**
             * Creates a new AlwaysOn instance using the specified properties.
             * @function create
             * @memberof api.AlwaysOn
             * @static
             * @param {api.IAlwaysOn=} [properties] Properties to set
             * @returns {api.AlwaysOn} AlwaysOn instance
             */
            AlwaysOn.create = function create(properties) {
                return AlwaysOn.fromObject(properties);
            };
    
            /**
             * Encodes the specified AlwaysOn message. Does not implicitly {@link api.AlwaysOn.verify|verify} messages.
             * @function encode
             * @memberof api.AlwaysOn
             * @static
             * @param {api.AlwaysOn} message AlwaysOn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlwaysOn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enable);
                return writer;
            };
    
            /**
             * Encodes the specified AlwaysOn message, length delimited. Does not implicitly {@link api.AlwaysOn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.AlwaysOn
             * @static
             * @param {api.AlwaysOn} message AlwaysOn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlwaysOn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AlwaysOn message from the specified reader or buffer.
             * @function decode
             * @memberof api.AlwaysOn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.AlwaysOn} AlwaysOn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlwaysOn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.AlwaysOn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.enable = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AlwaysOn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.AlwaysOn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.AlwaysOn} AlwaysOn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlwaysOn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AlwaysOn message.
             * @function verify
             * @memberof api.AlwaysOn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlwaysOn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enable != null && message.hasOwnProperty("enable"))
                    if (typeof message.enable !== "boolean")
                        return "enable: boolean expected";
                return null;
            };
    
            /**
             * Creates an AlwaysOn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.AlwaysOn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.AlwaysOn} AlwaysOn
             */
            AlwaysOn.fromObject = function fromObject(object) {
                if (object instanceof $root.api.AlwaysOn)
                    return object;
                var message = new $root.api.AlwaysOn();
                if (object.enable != null)
                    message.enable = Boolean(object.enable);
                return message;
            };
    
            /**
             * Creates a plain object from an AlwaysOn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.AlwaysOn
             * @static
             * @param {api.AlwaysOn} message AlwaysOn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlwaysOn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.enable = false;
                if (message.enable != null && message.hasOwnProperty("enable"))
                    object.enable = message.enable;
                return object;
            };
    
            /**
             * Converts this AlwaysOn to JSON.
             * @function toJSON
             * @memberof api.AlwaysOn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlwaysOn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AlwaysOn;
        })();
    
        api.RunMain = (function() {
    
            /**
             * Properties of a RunMain.
             * @memberof api
             * @interface IRunMain
             */
    
            /**
             * Constructs a new RunMain.
             * @memberof api
             * @classdesc Represents a RunMain.
             * @constructor
             * @param {api.IRunMain=} [properties] Properties to set
             */
            function RunMain(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new RunMain instance using the specified properties.
             * @function create
             * @memberof api.RunMain
             * @static
             * @param {api.IRunMain=} [properties] Properties to set
             * @returns {api.RunMain} RunMain instance
             */
            RunMain.create = function create(properties) {
                return RunMain.fromObject(properties);
            };
    
            /**
             * Encodes the specified RunMain message. Does not implicitly {@link api.RunMain.verify|verify} messages.
             * @function encode
             * @memberof api.RunMain
             * @static
             * @param {api.RunMain} message RunMain message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RunMain.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified RunMain message, length delimited. Does not implicitly {@link api.RunMain.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.RunMain
             * @static
             * @param {api.RunMain} message RunMain message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RunMain.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RunMain message from the specified reader or buffer.
             * @function decode
             * @memberof api.RunMain
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.RunMain} RunMain
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RunMain.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.RunMain();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RunMain message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.RunMain
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.RunMain} RunMain
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RunMain.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RunMain message.
             * @function verify
             * @memberof api.RunMain
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RunMain.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a RunMain message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.RunMain
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.RunMain} RunMain
             */
            RunMain.fromObject = function fromObject(object) {
                if (object instanceof $root.api.RunMain)
                    return object;
                return new $root.api.RunMain();
            };
    
            /**
             * Creates a plain object from a RunMain message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.RunMain
             * @static
             * @param {api.RunMain} message RunMain
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RunMain.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this RunMain to JSON.
             * @function toJSON
             * @memberof api.RunMain
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RunMain.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RunMain;
        })();
    
        api.OpenChannel = (function() {
    
            /**
             * Properties of an OpenChannel.
             * @memberof api
             * @interface IOpenChannel
             * @property {string|null} [service] OpenChannel service
             * @property {string|null} [name] OpenChannel name
             * @property {api.OpenChannel.Action|null} [action] OpenChannel action
             * @property {number|null} [id] OpenChannel id
             */
    
            /**
             * Constructs a new OpenChannel.
             * @memberof api
             * @classdesc Represents an OpenChannel.
             * @constructor
             * @param {api.IOpenChannel=} [properties] Properties to set
             */
            function OpenChannel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OpenChannel service.
             * @member {string} service
             * @memberof api.OpenChannel
             * @instance
             */
            OpenChannel.prototype.service = "";
    
            /**
             * OpenChannel name.
             * @member {string} name
             * @memberof api.OpenChannel
             * @instance
             */
            OpenChannel.prototype.name = "";
    
            /**
             * OpenChannel action.
             * @member {api.OpenChannel.Action} action
             * @memberof api.OpenChannel
             * @instance
             */
            OpenChannel.prototype.action = 0;
    
            /**
             * OpenChannel id.
             * @member {number} id
             * @memberof api.OpenChannel
             * @instance
             */
            OpenChannel.prototype.id = 0;
    
            /**
             * Creates a new OpenChannel instance using the specified properties.
             * @function create
             * @memberof api.OpenChannel
             * @static
             * @param {api.IOpenChannel=} [properties] Properties to set
             * @returns {api.OpenChannel} OpenChannel instance
             */
            OpenChannel.create = function create(properties) {
                return OpenChannel.fromObject(properties);
            };
    
            /**
             * Encodes the specified OpenChannel message. Does not implicitly {@link api.OpenChannel.verify|verify} messages.
             * @function encode
             * @memberof api.OpenChannel
             * @static
             * @param {api.OpenChannel} message OpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.service);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.action);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified OpenChannel message, length delimited. Does not implicitly {@link api.OpenChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OpenChannel
             * @static
             * @param {api.OpenChannel} message OpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OpenChannel message from the specified reader or buffer.
             * @function decode
             * @memberof api.OpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OpenChannel} OpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OpenChannel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.service = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.action = reader.int32();
                        break;
                    case 4:
                        message.id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OpenChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OpenChannel} OpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OpenChannel message.
             * @function verify
             * @memberof api.OpenChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OpenChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.service != null && message.hasOwnProperty("service"))
                    if (!$util.isString(message.service))
                        return "service: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };
    
            /**
             * Creates an OpenChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OpenChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OpenChannel} OpenChannel
             */
            OpenChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OpenChannel)
                    return object;
                var message = new $root.api.OpenChannel();
                if (object.service != null)
                    message.service = String(object.service);
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.action) {
                case "CREATE":
                case 0:
                    message.action = 0;
                    break;
                case "ATTACH":
                case 1:
                    message.action = 1;
                    break;
                case "ATTACH_OR_CREATE":
                case 2:
                    message.action = 2;
                    break;
                }
                if (object.id != null)
                    message.id = object.id | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an OpenChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OpenChannel
             * @static
             * @param {api.OpenChannel} message OpenChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OpenChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.service = "";
                    object.name = "";
                    object.action = options.enums === String ? "CREATE" : 0;
                    object.id = 0;
                }
                if (message.service != null && message.hasOwnProperty("service"))
                    object.service = message.service;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = options.enums === String ? $root.api.OpenChannel.Action[message.action] : message.action;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };
    
            /**
             * Converts this OpenChannel to JSON.
             * @function toJSON
             * @memberof api.OpenChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OpenChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Action enum.
             * @name api.OpenChannel.Action
             * @enum {number}
             * @property {number} CREATE=0 CREATE value
             * @property {number} ATTACH=1 ATTACH value
             * @property {number} ATTACH_OR_CREATE=2 ATTACH_OR_CREATE value
             */
            OpenChannel.Action = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CREATE"] = 0;
                values[valuesById[1] = "ATTACH"] = 1;
                values[valuesById[2] = "ATTACH_OR_CREATE"] = 2;
                return values;
            })();
    
            return OpenChannel;
        })();
    
        api.OpenChannelRes = (function() {
    
            /**
             * Properties of an OpenChannelRes.
             * @memberof api
             * @interface IOpenChannelRes
             * @property {number|null} [id] OpenChannelRes id
             * @property {api.OpenChannelRes.State|null} [state] OpenChannelRes state
             * @property {string|null} [error] OpenChannelRes error
             */
    
            /**
             * Constructs a new OpenChannelRes.
             * @memberof api
             * @classdesc Represents an OpenChannelRes.
             * @constructor
             * @param {api.IOpenChannelRes=} [properties] Properties to set
             */
            function OpenChannelRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OpenChannelRes id.
             * @member {number} id
             * @memberof api.OpenChannelRes
             * @instance
             */
            OpenChannelRes.prototype.id = 0;
    
            /**
             * OpenChannelRes state.
             * @member {api.OpenChannelRes.State} state
             * @memberof api.OpenChannelRes
             * @instance
             */
            OpenChannelRes.prototype.state = 0;
    
            /**
             * OpenChannelRes error.
             * @member {string} error
             * @memberof api.OpenChannelRes
             * @instance
             */
            OpenChannelRes.prototype.error = "";
    
            /**
             * Creates a new OpenChannelRes instance using the specified properties.
             * @function create
             * @memberof api.OpenChannelRes
             * @static
             * @param {api.IOpenChannelRes=} [properties] Properties to set
             * @returns {api.OpenChannelRes} OpenChannelRes instance
             */
            OpenChannelRes.create = function create(properties) {
                return OpenChannelRes.fromObject(properties);
            };
    
            /**
             * Encodes the specified OpenChannelRes message. Does not implicitly {@link api.OpenChannelRes.verify|verify} messages.
             * @function encode
             * @memberof api.OpenChannelRes
             * @static
             * @param {api.OpenChannelRes} message OpenChannelRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenChannelRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.error);
                return writer;
            };
    
            /**
             * Encodes the specified OpenChannelRes message, length delimited. Does not implicitly {@link api.OpenChannelRes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OpenChannelRes
             * @static
             * @param {api.OpenChannelRes} message OpenChannelRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenChannelRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OpenChannelRes message from the specified reader or buffer.
             * @function decode
             * @memberof api.OpenChannelRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OpenChannelRes} OpenChannelRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenChannelRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OpenChannelRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    case 3:
                        message.error = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OpenChannelRes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OpenChannelRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OpenChannelRes} OpenChannelRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenChannelRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OpenChannelRes message.
             * @function verify
             * @memberof api.OpenChannelRes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OpenChannelRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                return null;
            };
    
            /**
             * Creates an OpenChannelRes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OpenChannelRes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OpenChannelRes} OpenChannelRes
             */
            OpenChannelRes.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OpenChannelRes)
                    return object;
                var message = new $root.api.OpenChannelRes();
                if (object.id != null)
                    message.id = object.id | 0;
                switch (object.state) {
                case "CREATED":
                case 0:
                    message.state = 0;
                    break;
                case "ATTACHED":
                case 1:
                    message.state = 1;
                    break;
                case "ERROR":
                case 2:
                    message.state = 2;
                    break;
                }
                if (object.error != null)
                    message.error = String(object.error);
                return message;
            };
    
            /**
             * Creates a plain object from an OpenChannelRes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OpenChannelRes
             * @static
             * @param {api.OpenChannelRes} message OpenChannelRes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OpenChannelRes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.state = options.enums === String ? "CREATED" : 0;
                    object.error = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.api.OpenChannelRes.State[message.state] : message.state;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                return object;
            };
    
            /**
             * Converts this OpenChannelRes to JSON.
             * @function toJSON
             * @memberof api.OpenChannelRes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OpenChannelRes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * State enum.
             * @name api.OpenChannelRes.State
             * @enum {number}
             * @property {number} CREATED=0 CREATED value
             * @property {number} ATTACHED=1 ATTACHED value
             * @property {number} ERROR=2 ERROR value
             */
            OpenChannelRes.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CREATED"] = 0;
                values[valuesById[1] = "ATTACHED"] = 1;
                values[valuesById[2] = "ERROR"] = 2;
                return values;
            })();
    
            return OpenChannelRes;
        })();
    
        api.CloseChannel = (function() {
    
            /**
             * Properties of a CloseChannel.
             * @memberof api
             * @interface ICloseChannel
             * @property {number|null} [id] CloseChannel id
             * @property {api.CloseChannel.Action|null} [action] CloseChannel action
             */
    
            /**
             * Constructs a new CloseChannel.
             * @memberof api
             * @classdesc Represents a CloseChannel.
             * @constructor
             * @param {api.ICloseChannel=} [properties] Properties to set
             */
            function CloseChannel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CloseChannel id.
             * @member {number} id
             * @memberof api.CloseChannel
             * @instance
             */
            CloseChannel.prototype.id = 0;
    
            /**
             * CloseChannel action.
             * @member {api.CloseChannel.Action} action
             * @memberof api.CloseChannel
             * @instance
             */
            CloseChannel.prototype.action = 0;
    
            /**
             * Creates a new CloseChannel instance using the specified properties.
             * @function create
             * @memberof api.CloseChannel
             * @static
             * @param {api.ICloseChannel=} [properties] Properties to set
             * @returns {api.CloseChannel} CloseChannel instance
             */
            CloseChannel.create = function create(properties) {
                return CloseChannel.fromObject(properties);
            };
    
            /**
             * Encodes the specified CloseChannel message. Does not implicitly {@link api.CloseChannel.verify|verify} messages.
             * @function encode
             * @memberof api.CloseChannel
             * @static
             * @param {api.CloseChannel} message CloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloseChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
                return writer;
            };
    
            /**
             * Encodes the specified CloseChannel message, length delimited. Does not implicitly {@link api.CloseChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.CloseChannel
             * @static
             * @param {api.CloseChannel} message CloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloseChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CloseChannel message from the specified reader or buffer.
             * @function decode
             * @memberof api.CloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.CloseChannel} CloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloseChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CloseChannel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.action = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CloseChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.CloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.CloseChannel} CloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloseChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CloseChannel message.
             * @function verify
             * @memberof api.CloseChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CloseChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a CloseChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.CloseChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.CloseChannel} CloseChannel
             */
            CloseChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.api.CloseChannel)
                    return object;
                var message = new $root.api.CloseChannel();
                if (object.id != null)
                    message.id = object.id | 0;
                switch (object.action) {
                case "DISCONNECT":
                case 0:
                    message.action = 0;
                    break;
                case "TRY_CLOSE":
                case 1:
                    message.action = 1;
                    break;
                case "CLOSE":
                case 2:
                    message.action = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CloseChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.CloseChannel
             * @static
             * @param {api.CloseChannel} message CloseChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CloseChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.action = options.enums === String ? "DISCONNECT" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = options.enums === String ? $root.api.CloseChannel.Action[message.action] : message.action;
                return object;
            };
    
            /**
             * Converts this CloseChannel to JSON.
             * @function toJSON
             * @memberof api.CloseChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CloseChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Action enum.
             * @name api.CloseChannel.Action
             * @enum {number}
             * @property {number} DISCONNECT=0 DISCONNECT value
             * @property {number} TRY_CLOSE=1 TRY_CLOSE value
             * @property {number} CLOSE=2 CLOSE value
             */
            CloseChannel.Action = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DISCONNECT"] = 0;
                values[valuesById[1] = "TRY_CLOSE"] = 1;
                values[valuesById[2] = "CLOSE"] = 2;
                return values;
            })();
    
            return CloseChannel;
        })();
    
        api.CloseChannelRes = (function() {
    
            /**
             * Properties of a CloseChannelRes.
             * @memberof api
             * @interface ICloseChannelRes
             * @property {number|null} [id] CloseChannelRes id
             * @property {api.CloseChannelRes.Status|null} [status] CloseChannelRes status
             */
    
            /**
             * Constructs a new CloseChannelRes.
             * @memberof api
             * @classdesc Represents a CloseChannelRes.
             * @constructor
             * @param {api.ICloseChannelRes=} [properties] Properties to set
             */
            function CloseChannelRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CloseChannelRes id.
             * @member {number} id
             * @memberof api.CloseChannelRes
             * @instance
             */
            CloseChannelRes.prototype.id = 0;
    
            /**
             * CloseChannelRes status.
             * @member {api.CloseChannelRes.Status} status
             * @memberof api.CloseChannelRes
             * @instance
             */
            CloseChannelRes.prototype.status = 0;
    
            /**
             * Creates a new CloseChannelRes instance using the specified properties.
             * @function create
             * @memberof api.CloseChannelRes
             * @static
             * @param {api.ICloseChannelRes=} [properties] Properties to set
             * @returns {api.CloseChannelRes} CloseChannelRes instance
             */
            CloseChannelRes.create = function create(properties) {
                return CloseChannelRes.fromObject(properties);
            };
    
            /**
             * Encodes the specified CloseChannelRes message. Does not implicitly {@link api.CloseChannelRes.verify|verify} messages.
             * @function encode
             * @memberof api.CloseChannelRes
             * @static
             * @param {api.CloseChannelRes} message CloseChannelRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloseChannelRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                return writer;
            };
    
            /**
             * Encodes the specified CloseChannelRes message, length delimited. Does not implicitly {@link api.CloseChannelRes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.CloseChannelRes
             * @static
             * @param {api.CloseChannelRes} message CloseChannelRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloseChannelRes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CloseChannelRes message from the specified reader or buffer.
             * @function decode
             * @memberof api.CloseChannelRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.CloseChannelRes} CloseChannelRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloseChannelRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CloseChannelRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CloseChannelRes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.CloseChannelRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.CloseChannelRes} CloseChannelRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloseChannelRes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CloseChannelRes message.
             * @function verify
             * @memberof api.CloseChannelRes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CloseChannelRes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a CloseChannelRes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.CloseChannelRes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.CloseChannelRes} CloseChannelRes
             */
            CloseChannelRes.fromObject = function fromObject(object) {
                if (object instanceof $root.api.CloseChannelRes)
                    return object;
                var message = new $root.api.CloseChannelRes();
                if (object.id != null)
                    message.id = object.id | 0;
                switch (object.status) {
                case "DISCONNECT":
                case 0:
                    message.status = 0;
                    break;
                case "CLOSE":
                case 1:
                    message.status = 1;
                    break;
                case "NOTHING":
                case 2:
                    message.status = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CloseChannelRes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.CloseChannelRes
             * @static
             * @param {api.CloseChannelRes} message CloseChannelRes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CloseChannelRes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.status = options.enums === String ? "DISCONNECT" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.api.CloseChannelRes.Status[message.status] : message.status;
                return object;
            };
    
            /**
             * Converts this CloseChannelRes to JSON.
             * @function toJSON
             * @memberof api.CloseChannelRes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CloseChannelRes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Status enum.
             * @name api.CloseChannelRes.Status
             * @enum {number}
             * @property {number} DISCONNECT=0 DISCONNECT value
             * @property {number} CLOSE=1 CLOSE value
             * @property {number} NOTHING=2 NOTHING value
             */
            CloseChannelRes.Status = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DISCONNECT"] = 0;
                values[valuesById[1] = "CLOSE"] = 1;
                values[valuesById[2] = "NOTHING"] = 2;
                return values;
            })();
    
            return CloseChannelRes;
        })();
    
        api.ContainerState = (function() {
    
            /**
             * Properties of a ContainerState.
             * @memberof api
             * @interface IContainerState
             * @property {api.ContainerState.State|null} [state] ContainerState state
             */
    
            /**
             * Constructs a new ContainerState.
             * @memberof api
             * @classdesc Represents a ContainerState.
             * @constructor
             * @param {api.IContainerState=} [properties] Properties to set
             */
            function ContainerState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ContainerState state.
             * @member {api.ContainerState.State} state
             * @memberof api.ContainerState
             * @instance
             */
            ContainerState.prototype.state = 0;
    
            /**
             * Creates a new ContainerState instance using the specified properties.
             * @function create
             * @memberof api.ContainerState
             * @static
             * @param {api.IContainerState=} [properties] Properties to set
             * @returns {api.ContainerState} ContainerState instance
             */
            ContainerState.create = function create(properties) {
                return ContainerState.fromObject(properties);
            };
    
            /**
             * Encodes the specified ContainerState message. Does not implicitly {@link api.ContainerState.verify|verify} messages.
             * @function encode
             * @memberof api.ContainerState
             * @static
             * @param {api.ContainerState} message ContainerState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContainerState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                return writer;
            };
    
            /**
             * Encodes the specified ContainerState message, length delimited. Does not implicitly {@link api.ContainerState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ContainerState
             * @static
             * @param {api.ContainerState} message ContainerState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContainerState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ContainerState message from the specified reader or buffer.
             * @function decode
             * @memberof api.ContainerState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ContainerState} ContainerState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContainerState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ContainerState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ContainerState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ContainerState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ContainerState} ContainerState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContainerState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ContainerState message.
             * @function verify
             * @memberof api.ContainerState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContainerState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a ContainerState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ContainerState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ContainerState} ContainerState
             */
            ContainerState.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ContainerState)
                    return object;
                var message = new $root.api.ContainerState();
                switch (object.state) {
                case "SLEEP":
                case 0:
                    message.state = 0;
                    break;
                case "READY":
                case 1:
                    message.state = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ContainerState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ContainerState
             * @static
             * @param {api.ContainerState} message ContainerState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContainerState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.state = options.enums === String ? "SLEEP" : 0;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.api.ContainerState.State[message.state] : message.state;
                return object;
            };
    
            /**
             * Converts this ContainerState to JSON.
             * @function toJSON
             * @memberof api.ContainerState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContainerState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * State enum.
             * @name api.ContainerState.State
             * @enum {number}
             * @property {number} SLEEP=0 SLEEP value
             * @property {number} READY=1 READY value
             */
            ContainerState.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SLEEP"] = 0;
                values[valuesById[1] = "READY"] = 1;
                return values;
            })();
    
            return ContainerState;
        })();
    
        api.PortOpen = (function() {
    
            /**
             * Properties of a PortOpen.
             * @memberof api
             * @interface IPortOpen
             * @property {boolean|null} [forwarded] PortOpen forwarded
             * @property {number|null} [port] PortOpen port
             * @property {string|null} [address] PortOpen address
             */
    
            /**
             * Constructs a new PortOpen.
             * @memberof api
             * @classdesc Represents a PortOpen.
             * @constructor
             * @param {api.IPortOpen=} [properties] Properties to set
             */
            function PortOpen(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PortOpen forwarded.
             * @member {boolean} forwarded
             * @memberof api.PortOpen
             * @instance
             */
            PortOpen.prototype.forwarded = false;
    
            /**
             * PortOpen port.
             * @member {number} port
             * @memberof api.PortOpen
             * @instance
             */
            PortOpen.prototype.port = 0;
    
            /**
             * PortOpen address.
             * @member {string} address
             * @memberof api.PortOpen
             * @instance
             */
            PortOpen.prototype.address = "";
    
            /**
             * Creates a new PortOpen instance using the specified properties.
             * @function create
             * @memberof api.PortOpen
             * @static
             * @param {api.IPortOpen=} [properties] Properties to set
             * @returns {api.PortOpen} PortOpen instance
             */
            PortOpen.create = function create(properties) {
                return PortOpen.fromObject(properties);
            };
    
            /**
             * Encodes the specified PortOpen message. Does not implicitly {@link api.PortOpen.verify|verify} messages.
             * @function encode
             * @memberof api.PortOpen
             * @static
             * @param {api.PortOpen} message PortOpen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PortOpen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.forwarded != null && Object.hasOwnProperty.call(message, "forwarded"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.forwarded);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
                return writer;
            };
    
            /**
             * Encodes the specified PortOpen message, length delimited. Does not implicitly {@link api.PortOpen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PortOpen
             * @static
             * @param {api.PortOpen} message PortOpen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PortOpen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PortOpen message from the specified reader or buffer.
             * @function decode
             * @memberof api.PortOpen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PortOpen} PortOpen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PortOpen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PortOpen();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.forwarded = reader.bool();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PortOpen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PortOpen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PortOpen} PortOpen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PortOpen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PortOpen message.
             * @function verify
             * @memberof api.PortOpen
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PortOpen.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.forwarded != null && message.hasOwnProperty("forwarded"))
                    if (typeof message.forwarded !== "boolean")
                        return "forwarded: boolean expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };
    
            /**
             * Creates a PortOpen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PortOpen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PortOpen} PortOpen
             */
            PortOpen.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PortOpen)
                    return object;
                var message = new $root.api.PortOpen();
                if (object.forwarded != null)
                    message.forwarded = Boolean(object.forwarded);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };
    
            /**
             * Creates a plain object from a PortOpen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PortOpen
             * @static
             * @param {api.PortOpen} message PortOpen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PortOpen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.forwarded = false;
                    object.port = 0;
                    object.address = "";
                }
                if (message.forwarded != null && message.hasOwnProperty("forwarded"))
                    object.forwarded = message.forwarded;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };
    
            /**
             * Converts this PortOpen to JSON.
             * @function toJSON
             * @memberof api.PortOpen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PortOpen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PortOpen;
        })();
    
        api.OTFetchRequest = (function() {
    
            /**
             * Properties of a OTFetchRequest.
             * @memberof api
             * @interface IOTFetchRequest
             * @property {number|null} [versionFrom] OTFetchRequest versionFrom
             * @property {number|null} [versionTo] OTFetchRequest versionTo
             */
    
            /**
             * Constructs a new OTFetchRequest.
             * @memberof api
             * @classdesc Represents a OTFetchRequest.
             * @constructor
             * @param {api.IOTFetchRequest=} [properties] Properties to set
             */
            function OTFetchRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTFetchRequest versionFrom.
             * @member {number} versionFrom
             * @memberof api.OTFetchRequest
             * @instance
             */
            OTFetchRequest.prototype.versionFrom = 0;
    
            /**
             * OTFetchRequest versionTo.
             * @member {number} versionTo
             * @memberof api.OTFetchRequest
             * @instance
             */
            OTFetchRequest.prototype.versionTo = 0;
    
            /**
             * Creates a new OTFetchRequest instance using the specified properties.
             * @function create
             * @memberof api.OTFetchRequest
             * @static
             * @param {api.IOTFetchRequest=} [properties] Properties to set
             * @returns {api.OTFetchRequest} OTFetchRequest instance
             */
            OTFetchRequest.create = function create(properties) {
                return OTFetchRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTFetchRequest message. Does not implicitly {@link api.OTFetchRequest.verify|verify} messages.
             * @function encode
             * @memberof api.OTFetchRequest
             * @static
             * @param {api.OTFetchRequest} message OTFetchRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTFetchRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.versionFrom != null && Object.hasOwnProperty.call(message, "versionFrom"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.versionFrom);
                if (message.versionTo != null && Object.hasOwnProperty.call(message, "versionTo"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.versionTo);
                return writer;
            };
    
            /**
             * Encodes the specified OTFetchRequest message, length delimited. Does not implicitly {@link api.OTFetchRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTFetchRequest
             * @static
             * @param {api.OTFetchRequest} message OTFetchRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTFetchRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTFetchRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTFetchRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTFetchRequest} OTFetchRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTFetchRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTFetchRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.versionFrom = reader.uint32();
                        break;
                    case 2:
                        message.versionTo = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTFetchRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTFetchRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTFetchRequest} OTFetchRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTFetchRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTFetchRequest message.
             * @function verify
             * @memberof api.OTFetchRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTFetchRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.versionFrom != null && message.hasOwnProperty("versionFrom"))
                    if (!$util.isInteger(message.versionFrom))
                        return "versionFrom: integer expected";
                if (message.versionTo != null && message.hasOwnProperty("versionTo"))
                    if (!$util.isInteger(message.versionTo))
                        return "versionTo: integer expected";
                return null;
            };
    
            /**
             * Creates a OTFetchRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTFetchRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTFetchRequest} OTFetchRequest
             */
            OTFetchRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTFetchRequest)
                    return object;
                var message = new $root.api.OTFetchRequest();
                if (object.versionFrom != null)
                    message.versionFrom = object.versionFrom >>> 0;
                if (object.versionTo != null)
                    message.versionTo = object.versionTo >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a OTFetchRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTFetchRequest
             * @static
             * @param {api.OTFetchRequest} message OTFetchRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTFetchRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.versionFrom = 0;
                    object.versionTo = 0;
                }
                if (message.versionFrom != null && message.hasOwnProperty("versionFrom"))
                    object.versionFrom = message.versionFrom;
                if (message.versionTo != null && message.hasOwnProperty("versionTo"))
                    object.versionTo = message.versionTo;
                return object;
            };
    
            /**
             * Converts this OTFetchRequest to JSON.
             * @function toJSON
             * @memberof api.OTFetchRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTFetchRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTFetchRequest;
        })();
    
        api.OTFetchResponse = (function() {
    
            /**
             * Properties of a OTFetchResponse.
             * @memberof api
             * @interface IOTFetchResponse
             * @property {Array.<api.OTPacket|api.IOTPacket>|null} [packets] OTFetchResponse packets
             */
    
            /**
             * Constructs a new OTFetchResponse.
             * @memberof api
             * @classdesc Represents a OTFetchResponse.
             * @constructor
             * @param {api.IOTFetchResponse=} [properties] Properties to set
             */
            function OTFetchResponse(properties) {
                this.packets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTFetchResponse packets.
             * @member {Array.<api.OTPacket>} packets
             * @memberof api.OTFetchResponse
             * @instance
             */
            OTFetchResponse.prototype.packets = $util.emptyArray;
    
            /**
             * Creates a new OTFetchResponse instance using the specified properties.
             * @function create
             * @memberof api.OTFetchResponse
             * @static
             * @param {api.IOTFetchResponse=} [properties] Properties to set
             * @returns {api.OTFetchResponse} OTFetchResponse instance
             */
            OTFetchResponse.create = function create(properties) {
                return OTFetchResponse.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTFetchResponse message. Does not implicitly {@link api.OTFetchResponse.verify|verify} messages.
             * @function encode
             * @memberof api.OTFetchResponse
             * @static
             * @param {api.OTFetchResponse} message OTFetchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTFetchResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packets != null && message.packets.length)
                    for (var i = 0; i < message.packets.length; ++i)
                        $root.api.OTPacket.encode(message.packets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified OTFetchResponse message, length delimited. Does not implicitly {@link api.OTFetchResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTFetchResponse
             * @static
             * @param {api.OTFetchResponse} message OTFetchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTFetchResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTFetchResponse message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTFetchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTFetchResponse} OTFetchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTFetchResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTFetchResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.packets && message.packets.length))
                            message.packets = [];
                        message.packets.push($root.api.OTPacket.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTFetchResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTFetchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTFetchResponse} OTFetchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTFetchResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTFetchResponse message.
             * @function verify
             * @memberof api.OTFetchResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTFetchResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packets != null && message.hasOwnProperty("packets")) {
                    if (!Array.isArray(message.packets))
                        return "packets: array expected";
                    for (var i = 0; i < message.packets.length; ++i) {
                        var error = $root.api.OTPacket.verify(message.packets[i]);
                        if (error)
                            return "packets." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a OTFetchResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTFetchResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTFetchResponse} OTFetchResponse
             */
            OTFetchResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTFetchResponse)
                    return object;
                var message = new $root.api.OTFetchResponse();
                if (object.packets) {
                    if (!Array.isArray(object.packets))
                        throw TypeError(".api.OTFetchResponse.packets: array expected");
                    message.packets = [];
                    for (var i = 0; i < object.packets.length; ++i) {
                        if (typeof object.packets[i] !== "object")
                            throw TypeError(".api.OTFetchResponse.packets: object expected");
                        message.packets[i] = $root.api.OTPacket.fromObject(object.packets[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a OTFetchResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTFetchResponse
             * @static
             * @param {api.OTFetchResponse} message OTFetchResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTFetchResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.packets = [];
                if (message.packets && message.packets.length) {
                    object.packets = [];
                    for (var j = 0; j < message.packets.length; ++j)
                        object.packets[j] = $root.api.OTPacket.toObject(message.packets[j], options);
                }
                return object;
            };
    
            /**
             * Converts this OTFetchResponse to JSON.
             * @function toJSON
             * @memberof api.OTFetchResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTFetchResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTFetchResponse;
        })();
    
        api.OTTransformSelectionRequest = (function() {
    
            /**
             * Properties of a OTTransformSelectionRequest.
             * @memberof api
             * @interface IOTTransformSelectionRequest
             * @property {number|null} [indexStart] OTTransformSelectionRequest indexStart
             * @property {number|null} [indexEnd] OTTransformSelectionRequest indexEnd
             * @property {number|null} [versionFrom] OTTransformSelectionRequest versionFrom
             * @property {number|null} [versionTo] OTTransformSelectionRequest versionTo
             */
    
            /**
             * Constructs a new OTTransformSelectionRequest.
             * @memberof api
             * @classdesc Represents a OTTransformSelectionRequest.
             * @constructor
             * @param {api.IOTTransformSelectionRequest=} [properties] Properties to set
             */
            function OTTransformSelectionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTTransformSelectionRequest indexStart.
             * @member {number} indexStart
             * @memberof api.OTTransformSelectionRequest
             * @instance
             */
            OTTransformSelectionRequest.prototype.indexStart = 0;
    
            /**
             * OTTransformSelectionRequest indexEnd.
             * @member {number} indexEnd
             * @memberof api.OTTransformSelectionRequest
             * @instance
             */
            OTTransformSelectionRequest.prototype.indexEnd = 0;
    
            /**
             * OTTransformSelectionRequest versionFrom.
             * @member {number} versionFrom
             * @memberof api.OTTransformSelectionRequest
             * @instance
             */
            OTTransformSelectionRequest.prototype.versionFrom = 0;
    
            /**
             * OTTransformSelectionRequest versionTo.
             * @member {number} versionTo
             * @memberof api.OTTransformSelectionRequest
             * @instance
             */
            OTTransformSelectionRequest.prototype.versionTo = 0;
    
            /**
             * Creates a new OTTransformSelectionRequest instance using the specified properties.
             * @function create
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {api.IOTTransformSelectionRequest=} [properties] Properties to set
             * @returns {api.OTTransformSelectionRequest} OTTransformSelectionRequest instance
             */
            OTTransformSelectionRequest.create = function create(properties) {
                return OTTransformSelectionRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTTransformSelectionRequest message. Does not implicitly {@link api.OTTransformSelectionRequest.verify|verify} messages.
             * @function encode
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {api.OTTransformSelectionRequest} message OTTransformSelectionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTTransformSelectionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.indexStart != null && Object.hasOwnProperty.call(message, "indexStart"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.indexStart);
                if (message.indexEnd != null && Object.hasOwnProperty.call(message, "indexEnd"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.indexEnd);
                if (message.versionFrom != null && Object.hasOwnProperty.call(message, "versionFrom"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.versionFrom);
                if (message.versionTo != null && Object.hasOwnProperty.call(message, "versionTo"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.versionTo);
                return writer;
            };
    
            /**
             * Encodes the specified OTTransformSelectionRequest message, length delimited. Does not implicitly {@link api.OTTransformSelectionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {api.OTTransformSelectionRequest} message OTTransformSelectionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTTransformSelectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTTransformSelectionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTTransformSelectionRequest} OTTransformSelectionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTTransformSelectionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTTransformSelectionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.indexStart = reader.uint32();
                        break;
                    case 2:
                        message.indexEnd = reader.uint32();
                        break;
                    case 3:
                        message.versionFrom = reader.uint32();
                        break;
                    case 4:
                        message.versionTo = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTTransformSelectionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTTransformSelectionRequest} OTTransformSelectionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTTransformSelectionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTTransformSelectionRequest message.
             * @function verify
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTTransformSelectionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.indexStart != null && message.hasOwnProperty("indexStart"))
                    if (!$util.isInteger(message.indexStart))
                        return "indexStart: integer expected";
                if (message.indexEnd != null && message.hasOwnProperty("indexEnd"))
                    if (!$util.isInteger(message.indexEnd))
                        return "indexEnd: integer expected";
                if (message.versionFrom != null && message.hasOwnProperty("versionFrom"))
                    if (!$util.isInteger(message.versionFrom))
                        return "versionFrom: integer expected";
                if (message.versionTo != null && message.hasOwnProperty("versionTo"))
                    if (!$util.isInteger(message.versionTo))
                        return "versionTo: integer expected";
                return null;
            };
    
            /**
             * Creates a OTTransformSelectionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTTransformSelectionRequest} OTTransformSelectionRequest
             */
            OTTransformSelectionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTTransformSelectionRequest)
                    return object;
                var message = new $root.api.OTTransformSelectionRequest();
                if (object.indexStart != null)
                    message.indexStart = object.indexStart >>> 0;
                if (object.indexEnd != null)
                    message.indexEnd = object.indexEnd >>> 0;
                if (object.versionFrom != null)
                    message.versionFrom = object.versionFrom >>> 0;
                if (object.versionTo != null)
                    message.versionTo = object.versionTo >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a OTTransformSelectionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTTransformSelectionRequest
             * @static
             * @param {api.OTTransformSelectionRequest} message OTTransformSelectionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTTransformSelectionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.indexStart = 0;
                    object.indexEnd = 0;
                    object.versionFrom = 0;
                    object.versionTo = 0;
                }
                if (message.indexStart != null && message.hasOwnProperty("indexStart"))
                    object.indexStart = message.indexStart;
                if (message.indexEnd != null && message.hasOwnProperty("indexEnd"))
                    object.indexEnd = message.indexEnd;
                if (message.versionFrom != null && message.hasOwnProperty("versionFrom"))
                    object.versionFrom = message.versionFrom;
                if (message.versionTo != null && message.hasOwnProperty("versionTo"))
                    object.versionTo = message.versionTo;
                return object;
            };
    
            /**
             * Converts this OTTransformSelectionRequest to JSON.
             * @function toJSON
             * @memberof api.OTTransformSelectionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTTransformSelectionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTTransformSelectionRequest;
        })();
    
        api.OTTransformSelectionResponse = (function() {
    
            /**
             * Properties of a OTTransformSelectionResponse.
             * @memberof api
             * @interface IOTTransformSelectionResponse
             * @property {number|null} [indexStart] OTTransformSelectionResponse indexStart
             * @property {number|null} [indexEnd] OTTransformSelectionResponse indexEnd
             * @property {number|null} [version] OTTransformSelectionResponse version
             */
    
            /**
             * Constructs a new OTTransformSelectionResponse.
             * @memberof api
             * @classdesc Represents a OTTransformSelectionResponse.
             * @constructor
             * @param {api.IOTTransformSelectionResponse=} [properties] Properties to set
             */
            function OTTransformSelectionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTTransformSelectionResponse indexStart.
             * @member {number} indexStart
             * @memberof api.OTTransformSelectionResponse
             * @instance
             */
            OTTransformSelectionResponse.prototype.indexStart = 0;
    
            /**
             * OTTransformSelectionResponse indexEnd.
             * @member {number} indexEnd
             * @memberof api.OTTransformSelectionResponse
             * @instance
             */
            OTTransformSelectionResponse.prototype.indexEnd = 0;
    
            /**
             * OTTransformSelectionResponse version.
             * @member {number} version
             * @memberof api.OTTransformSelectionResponse
             * @instance
             */
            OTTransformSelectionResponse.prototype.version = 0;
    
            /**
             * Creates a new OTTransformSelectionResponse instance using the specified properties.
             * @function create
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {api.IOTTransformSelectionResponse=} [properties] Properties to set
             * @returns {api.OTTransformSelectionResponse} OTTransformSelectionResponse instance
             */
            OTTransformSelectionResponse.create = function create(properties) {
                return OTTransformSelectionResponse.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTTransformSelectionResponse message. Does not implicitly {@link api.OTTransformSelectionResponse.verify|verify} messages.
             * @function encode
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {api.OTTransformSelectionResponse} message OTTransformSelectionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTTransformSelectionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.indexStart != null && Object.hasOwnProperty.call(message, "indexStart"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.indexStart);
                if (message.indexEnd != null && Object.hasOwnProperty.call(message, "indexEnd"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.indexEnd);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);
                return writer;
            };
    
            /**
             * Encodes the specified OTTransformSelectionResponse message, length delimited. Does not implicitly {@link api.OTTransformSelectionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {api.OTTransformSelectionResponse} message OTTransformSelectionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTTransformSelectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTTransformSelectionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTTransformSelectionResponse} OTTransformSelectionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTTransformSelectionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTTransformSelectionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.indexStart = reader.uint32();
                        break;
                    case 2:
                        message.indexEnd = reader.uint32();
                        break;
                    case 3:
                        message.version = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTTransformSelectionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTTransformSelectionResponse} OTTransformSelectionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTTransformSelectionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTTransformSelectionResponse message.
             * @function verify
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTTransformSelectionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.indexStart != null && message.hasOwnProperty("indexStart"))
                    if (!$util.isInteger(message.indexStart))
                        return "indexStart: integer expected";
                if (message.indexEnd != null && message.hasOwnProperty("indexEnd"))
                    if (!$util.isInteger(message.indexEnd))
                        return "indexEnd: integer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                return null;
            };
    
            /**
             * Creates a OTTransformSelectionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTTransformSelectionResponse} OTTransformSelectionResponse
             */
            OTTransformSelectionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTTransformSelectionResponse)
                    return object;
                var message = new $root.api.OTTransformSelectionResponse();
                if (object.indexStart != null)
                    message.indexStart = object.indexStart >>> 0;
                if (object.indexEnd != null)
                    message.indexEnd = object.indexEnd >>> 0;
                if (object.version != null)
                    message.version = object.version >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a OTTransformSelectionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTTransformSelectionResponse
             * @static
             * @param {api.OTTransformSelectionResponse} message OTTransformSelectionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTTransformSelectionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.indexStart = 0;
                    object.indexEnd = 0;
                    object.version = 0;
                }
                if (message.indexStart != null && message.hasOwnProperty("indexStart"))
                    object.indexStart = message.indexStart;
                if (message.indexEnd != null && message.hasOwnProperty("indexEnd"))
                    object.indexEnd = message.indexEnd;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };
    
            /**
             * Converts this OTTransformSelectionResponse to JSON.
             * @function toJSON
             * @memberof api.OTTransformSelectionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTTransformSelectionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTTransformSelectionResponse;
        })();
    
        api.OTPacket = (function() {
    
            /**
             * Properties of a OTPacket.
             * @memberof api
             * @interface IOTPacket
             * @property {number|null} [spookyVersion] OTPacket spookyVersion
             * @property {number|null} [version] OTPacket version
             * @property {Array.<api.OTRuneTransformOp|api.IOTRuneTransformOp>|null} [ops] OTPacket ops
             * @property {number|null} [crc32] OTPacket crc32
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [committed] OTPacket committed
             * @property {number|null} [nonce] OTPacket nonce
             */
    
            /**
             * Constructs a new OTPacket.
             * @memberof api
             * @classdesc Represents a OTPacket.
             * @constructor
             * @param {api.IOTPacket=} [properties] Properties to set
             */
            function OTPacket(properties) {
                this.ops = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTPacket spookyVersion.
             * @member {number} spookyVersion
             * @memberof api.OTPacket
             * @instance
             */
            OTPacket.prototype.spookyVersion = 0;
    
            /**
             * OTPacket version.
             * @member {number} version
             * @memberof api.OTPacket
             * @instance
             */
            OTPacket.prototype.version = 0;
    
            /**
             * OTPacket ops.
             * @member {Array.<api.OTRuneTransformOp>} ops
             * @memberof api.OTPacket
             * @instance
             */
            OTPacket.prototype.ops = $util.emptyArray;
    
            /**
             * OTPacket crc32.
             * @member {number} crc32
             * @memberof api.OTPacket
             * @instance
             */
            OTPacket.prototype.crc32 = 0;
    
            /**
             * OTPacket committed.
             * @member {google.protobuf.Timestamp|null|undefined} committed
             * @memberof api.OTPacket
             * @instance
             */
            OTPacket.prototype.committed = null;
    
            /**
             * OTPacket nonce.
             * @member {number} nonce
             * @memberof api.OTPacket
             * @instance
             */
            OTPacket.prototype.nonce = 0;
    
            /**
             * Creates a new OTPacket instance using the specified properties.
             * @function create
             * @memberof api.OTPacket
             * @static
             * @param {api.IOTPacket=} [properties] Properties to set
             * @returns {api.OTPacket} OTPacket instance
             */
            OTPacket.create = function create(properties) {
                return OTPacket.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTPacket message. Does not implicitly {@link api.OTPacket.verify|verify} messages.
             * @function encode
             * @memberof api.OTPacket
             * @static
             * @param {api.OTPacket} message OTPacket message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTPacket.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.spookyVersion != null && Object.hasOwnProperty.call(message, "spookyVersion"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.spookyVersion);
                if (message.ops != null && message.ops.length)
                    for (var i = 0; i < message.ops.length; ++i)
                        $root.api.OTRuneTransformOp.encode(message.ops[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.crc32 != null && Object.hasOwnProperty.call(message, "crc32"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.crc32);
                if (message.committed != null && Object.hasOwnProperty.call(message, "committed"))
                    $root.google.protobuf.Timestamp.encode(message.committed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.version);
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.nonce);
                return writer;
            };
    
            /**
             * Encodes the specified OTPacket message, length delimited. Does not implicitly {@link api.OTPacket.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTPacket
             * @static
             * @param {api.OTPacket} message OTPacket message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTPacket.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTPacket message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTPacket
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTPacket} OTPacket
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTPacket.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTPacket();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.spookyVersion = reader.uint32();
                        break;
                    case 5:
                        message.version = reader.uint32();
                        break;
                    case 2:
                        if (!(message.ops && message.ops.length))
                            message.ops = [];
                        message.ops.push($root.api.OTRuneTransformOp.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.crc32 = reader.uint32();
                        break;
                    case 4:
                        message.committed = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.nonce = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTPacket message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTPacket
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTPacket} OTPacket
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTPacket.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTPacket message.
             * @function verify
             * @memberof api.OTPacket
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTPacket.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.spookyVersion != null && message.hasOwnProperty("spookyVersion"))
                    if (!$util.isInteger(message.spookyVersion))
                        return "spookyVersion: integer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.ops != null && message.hasOwnProperty("ops")) {
                    if (!Array.isArray(message.ops))
                        return "ops: array expected";
                    for (var i = 0; i < message.ops.length; ++i) {
                        var error = $root.api.OTRuneTransformOp.verify(message.ops[i]);
                        if (error)
                            return "ops." + error;
                    }
                }
                if (message.crc32 != null && message.hasOwnProperty("crc32"))
                    if (!$util.isInteger(message.crc32))
                        return "crc32: integer expected";
                if (message.committed != null && message.hasOwnProperty("committed")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.committed);
                    if (error)
                        return "committed." + error;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce))
                        return "nonce: integer expected";
                return null;
            };
    
            /**
             * Creates a OTPacket message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTPacket
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTPacket} OTPacket
             */
            OTPacket.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTPacket)
                    return object;
                var message = new $root.api.OTPacket();
                if (object.spookyVersion != null)
                    message.spookyVersion = object.spookyVersion >>> 0;
                if (object.version != null)
                    message.version = object.version >>> 0;
                if (object.ops) {
                    if (!Array.isArray(object.ops))
                        throw TypeError(".api.OTPacket.ops: array expected");
                    message.ops = [];
                    for (var i = 0; i < object.ops.length; ++i) {
                        if (typeof object.ops[i] !== "object")
                            throw TypeError(".api.OTPacket.ops: object expected");
                        message.ops[i] = $root.api.OTRuneTransformOp.fromObject(object.ops[i]);
                    }
                }
                if (object.crc32 != null)
                    message.crc32 = object.crc32 >>> 0;
                if (object.committed != null) {
                    if (typeof object.committed !== "object")
                        throw TypeError(".api.OTPacket.committed: object expected");
                    message.committed = $root.google.protobuf.Timestamp.fromObject(object.committed);
                }
                if (object.nonce != null)
                    message.nonce = object.nonce >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a OTPacket message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTPacket
             * @static
             * @param {api.OTPacket} message OTPacket
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTPacket.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ops = [];
                if (options.defaults) {
                    object.spookyVersion = 0;
                    object.crc32 = 0;
                    object.committed = null;
                    object.version = 0;
                    object.nonce = 0;
                }
                if (message.spookyVersion != null && message.hasOwnProperty("spookyVersion"))
                    object.spookyVersion = message.spookyVersion;
                if (message.ops && message.ops.length) {
                    object.ops = [];
                    for (var j = 0; j < message.ops.length; ++j)
                        object.ops[j] = $root.api.OTRuneTransformOp.toObject(message.ops[j], options);
                }
                if (message.crc32 != null && message.hasOwnProperty("crc32"))
                    object.crc32 = message.crc32;
                if (message.committed != null && message.hasOwnProperty("committed"))
                    object.committed = $root.google.protobuf.Timestamp.toObject(message.committed, options);
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    object.nonce = message.nonce;
                return object;
            };
    
            /**
             * Converts this OTPacket to JSON.
             * @function toJSON
             * @memberof api.OTPacket
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTPacket.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTPacket;
        })();
    
        api.OTRuneTransformOp = (function() {
    
            /**
             * Properties of a OTRuneTransformOp.
             * @memberof api
             * @interface IOTRuneTransformOp
             * @property {number|null} [skip] OTRuneTransformOp skip
             * @property {number|null} ["delete"] OTRuneTransformOp delete
             * @property {string|null} [insert] OTRuneTransformOp insert
             */
    
            /**
             * Constructs a new OTRuneTransformOp.
             * @memberof api
             * @classdesc Represents a OTRuneTransformOp.
             * @constructor
             * @param {api.IOTRuneTransformOp=} [properties] Properties to set
             */
            function OTRuneTransformOp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTRuneTransformOp skip.
             * @member {number} skip
             * @memberof api.OTRuneTransformOp
             * @instance
             */
            OTRuneTransformOp.prototype.skip = 0;
    
            /**
             * OTRuneTransformOp delete.
             * @member {number} delete
             * @memberof api.OTRuneTransformOp
             * @instance
             */
            OTRuneTransformOp.prototype["delete"] = 0;
    
            /**
             * OTRuneTransformOp insert.
             * @member {string} insert
             * @memberof api.OTRuneTransformOp
             * @instance
             */
            OTRuneTransformOp.prototype.insert = "";
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * OTRuneTransformOp op.
             * @member {"skip"|"delete"|"insert"|undefined} op
             * @memberof api.OTRuneTransformOp
             * @instance
             */
            Object.defineProperty(OTRuneTransformOp.prototype, "op", {
                get: $util.oneOfGetter($oneOfFields = ["skip", "delete", "insert"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new OTRuneTransformOp instance using the specified properties.
             * @function create
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {api.IOTRuneTransformOp=} [properties] Properties to set
             * @returns {api.OTRuneTransformOp} OTRuneTransformOp instance
             */
            OTRuneTransformOp.create = function create(properties) {
                return OTRuneTransformOp.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTRuneTransformOp message. Does not implicitly {@link api.OTRuneTransformOp.verify|verify} messages.
             * @function encode
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {api.OTRuneTransformOp} message OTRuneTransformOp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTRuneTransformOp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.skip != null && Object.hasOwnProperty.call(message, "skip"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.skip);
                if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message["delete"]);
                if (message.insert != null && Object.hasOwnProperty.call(message, "insert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.insert);
                return writer;
            };
    
            /**
             * Encodes the specified OTRuneTransformOp message, length delimited. Does not implicitly {@link api.OTRuneTransformOp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {api.OTRuneTransformOp} message OTRuneTransformOp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTRuneTransformOp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTRuneTransformOp message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTRuneTransformOp} OTRuneTransformOp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTRuneTransformOp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTRuneTransformOp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.skip = reader.uint32();
                        break;
                    case 2:
                        message["delete"] = reader.uint32();
                        break;
                    case 3:
                        message.insert = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTRuneTransformOp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTRuneTransformOp} OTRuneTransformOp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTRuneTransformOp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTRuneTransformOp message.
             * @function verify
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTRuneTransformOp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.skip != null && message.hasOwnProperty("skip")) {
                    properties.op = 1;
                    if (!$util.isInteger(message.skip))
                        return "skip: integer expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.op === 1)
                        return "op: multiple values";
                    properties.op = 1;
                    if (!$util.isInteger(message["delete"]))
                        return "delete: integer expected";
                }
                if (message.insert != null && message.hasOwnProperty("insert")) {
                    if (properties.op === 1)
                        return "op: multiple values";
                    properties.op = 1;
                    if (!$util.isString(message.insert))
                        return "insert: string expected";
                }
                return null;
            };
    
            /**
             * Creates a OTRuneTransformOp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTRuneTransformOp} OTRuneTransformOp
             */
            OTRuneTransformOp.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTRuneTransformOp)
                    return object;
                var message = new $root.api.OTRuneTransformOp();
                if (object.skip != null)
                    message.skip = object.skip >>> 0;
                if (object["delete"] != null)
                    message["delete"] = object["delete"] >>> 0;
                if (object.insert != null)
                    message.insert = String(object.insert);
                return message;
            };
    
            /**
             * Creates a plain object from a OTRuneTransformOp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTRuneTransformOp
             * @static
             * @param {api.OTRuneTransformOp} message OTRuneTransformOp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTRuneTransformOp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.skip != null && message.hasOwnProperty("skip")) {
                    object.skip = message.skip;
                    if (options.oneofs)
                        object.op = "skip";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.op = "delete";
                }
                if (message.insert != null && message.hasOwnProperty("insert")) {
                    object.insert = message.insert;
                    if (options.oneofs)
                        object.op = "insert";
                }
                return object;
            };
    
            /**
             * Converts this OTRuneTransformOp to JSON.
             * @function toJSON
             * @memberof api.OTRuneTransformOp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTRuneTransformOp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTRuneTransformOp;
        })();
    
        api.OTStatus = (function() {
    
            /**
             * Properties of a OTStatus.
             * @memberof api
             * @interface IOTStatus
             * @property {string|null} [contents] OTStatus contents
             * @property {number|null} [version] OTStatus version
             * @property {api.File|api.IFile|null} [linkedFile] OTStatus linkedFile
             * @property {Array.<api.OTCursor|api.IOTCursor>|null} [cursors] OTStatus cursors
             */
    
            /**
             * Constructs a new OTStatus.
             * @memberof api
             * @classdesc Represents a OTStatus.
             * @constructor
             * @param {api.IOTStatus=} [properties] Properties to set
             */
            function OTStatus(properties) {
                this.cursors = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTStatus contents.
             * @member {string} contents
             * @memberof api.OTStatus
             * @instance
             */
            OTStatus.prototype.contents = "";
    
            /**
             * OTStatus version.
             * @member {number} version
             * @memberof api.OTStatus
             * @instance
             */
            OTStatus.prototype.version = 0;
    
            /**
             * OTStatus linkedFile.
             * @member {api.File|null|undefined} linkedFile
             * @memberof api.OTStatus
             * @instance
             */
            OTStatus.prototype.linkedFile = null;
    
            /**
             * OTStatus cursors.
             * @member {Array.<api.OTCursor>} cursors
             * @memberof api.OTStatus
             * @instance
             */
            OTStatus.prototype.cursors = $util.emptyArray;
    
            /**
             * Creates a new OTStatus instance using the specified properties.
             * @function create
             * @memberof api.OTStatus
             * @static
             * @param {api.IOTStatus=} [properties] Properties to set
             * @returns {api.OTStatus} OTStatus instance
             */
            OTStatus.create = function create(properties) {
                return OTStatus.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTStatus message. Does not implicitly {@link api.OTStatus.verify|verify} messages.
             * @function encode
             * @memberof api.OTStatus
             * @static
             * @param {api.OTStatus} message OTStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contents != null && Object.hasOwnProperty.call(message, "contents"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contents);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
                if (message.linkedFile != null && Object.hasOwnProperty.call(message, "linkedFile"))
                    $root.api.File.encode(message.linkedFile, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cursors != null && message.cursors.length)
                    for (var i = 0; i < message.cursors.length; ++i)
                        $root.api.OTCursor.encode(message.cursors[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified OTStatus message, length delimited. Does not implicitly {@link api.OTStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTStatus
             * @static
             * @param {api.OTStatus} message OTStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTStatus message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTStatus} OTStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contents = reader.string();
                        break;
                    case 2:
                        message.version = reader.uint32();
                        break;
                    case 3:
                        message.linkedFile = $root.api.File.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.cursors && message.cursors.length))
                            message.cursors = [];
                        message.cursors.push($root.api.OTCursor.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTStatus} OTStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTStatus message.
             * @function verify
             * @memberof api.OTStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contents != null && message.hasOwnProperty("contents"))
                    if (!$util.isString(message.contents))
                        return "contents: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.linkedFile != null && message.hasOwnProperty("linkedFile")) {
                    var error = $root.api.File.verify(message.linkedFile);
                    if (error)
                        return "linkedFile." + error;
                }
                if (message.cursors != null && message.hasOwnProperty("cursors")) {
                    if (!Array.isArray(message.cursors))
                        return "cursors: array expected";
                    for (var i = 0; i < message.cursors.length; ++i) {
                        var error = $root.api.OTCursor.verify(message.cursors[i]);
                        if (error)
                            return "cursors." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a OTStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTStatus} OTStatus
             */
            OTStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTStatus)
                    return object;
                var message = new $root.api.OTStatus();
                if (object.contents != null)
                    message.contents = String(object.contents);
                if (object.version != null)
                    message.version = object.version >>> 0;
                if (object.linkedFile != null) {
                    if (typeof object.linkedFile !== "object")
                        throw TypeError(".api.OTStatus.linkedFile: object expected");
                    message.linkedFile = $root.api.File.fromObject(object.linkedFile);
                }
                if (object.cursors) {
                    if (!Array.isArray(object.cursors))
                        throw TypeError(".api.OTStatus.cursors: array expected");
                    message.cursors = [];
                    for (var i = 0; i < object.cursors.length; ++i) {
                        if (typeof object.cursors[i] !== "object")
                            throw TypeError(".api.OTStatus.cursors: object expected");
                        message.cursors[i] = $root.api.OTCursor.fromObject(object.cursors[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a OTStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTStatus
             * @static
             * @param {api.OTStatus} message OTStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.cursors = [];
                if (options.defaults) {
                    object.contents = "";
                    object.version = 0;
                    object.linkedFile = null;
                }
                if (message.contents != null && message.hasOwnProperty("contents"))
                    object.contents = message.contents;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.linkedFile != null && message.hasOwnProperty("linkedFile"))
                    object.linkedFile = $root.api.File.toObject(message.linkedFile, options);
                if (message.cursors && message.cursors.length) {
                    object.cursors = [];
                    for (var j = 0; j < message.cursors.length; ++j)
                        object.cursors[j] = $root.api.OTCursor.toObject(message.cursors[j], options);
                }
                return object;
            };
    
            /**
             * Converts this OTStatus to JSON.
             * @function toJSON
             * @memberof api.OTStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTStatus;
        })();
    
        api.OTCursor = (function() {
    
            /**
             * Properties of a OTCursor.
             * @memberof api
             * @interface IOTCursor
             * @property {number|null} [position] OTCursor position
             * @property {number|null} [selectionStart] OTCursor selectionStart
             * @property {number|null} [selectionEnd] OTCursor selectionEnd
             * @property {api.User|api.IUser|null} [user] OTCursor user
             * @property {string|null} [id] OTCursor id
             */
    
            /**
             * Constructs a new OTCursor.
             * @memberof api
             * @classdesc Represents a OTCursor.
             * @constructor
             * @param {api.IOTCursor=} [properties] Properties to set
             */
            function OTCursor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OTCursor position.
             * @member {number} position
             * @memberof api.OTCursor
             * @instance
             */
            OTCursor.prototype.position = 0;
    
            /**
             * OTCursor selectionStart.
             * @member {number} selectionStart
             * @memberof api.OTCursor
             * @instance
             */
            OTCursor.prototype.selectionStart = 0;
    
            /**
             * OTCursor selectionEnd.
             * @member {number} selectionEnd
             * @memberof api.OTCursor
             * @instance
             */
            OTCursor.prototype.selectionEnd = 0;
    
            /**
             * OTCursor user.
             * @member {api.User|null|undefined} user
             * @memberof api.OTCursor
             * @instance
             */
            OTCursor.prototype.user = null;
    
            /**
             * OTCursor id.
             * @member {string} id
             * @memberof api.OTCursor
             * @instance
             */
            OTCursor.prototype.id = "";
    
            /**
             * Creates a new OTCursor instance using the specified properties.
             * @function create
             * @memberof api.OTCursor
             * @static
             * @param {api.IOTCursor=} [properties] Properties to set
             * @returns {api.OTCursor} OTCursor instance
             */
            OTCursor.create = function create(properties) {
                return OTCursor.fromObject(properties);
            };
    
            /**
             * Encodes the specified OTCursor message. Does not implicitly {@link api.OTCursor.verify|verify} messages.
             * @function encode
             * @memberof api.OTCursor
             * @static
             * @param {api.OTCursor} message OTCursor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTCursor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.position);
                if (message.selectionStart != null && Object.hasOwnProperty.call(message, "selectionStart"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.selectionStart);
                if (message.selectionEnd != null && Object.hasOwnProperty.call(message, "selectionEnd"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.selectionEnd);
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    $root.api.User.encode(message.user, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified OTCursor message, length delimited. Does not implicitly {@link api.OTCursor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OTCursor
             * @static
             * @param {api.OTCursor} message OTCursor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OTCursor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a OTCursor message from the specified reader or buffer.
             * @function decode
             * @memberof api.OTCursor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OTCursor} OTCursor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTCursor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OTCursor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = reader.uint32();
                        break;
                    case 2:
                        message.selectionStart = reader.uint32();
                        break;
                    case 3:
                        message.selectionEnd = reader.uint32();
                        break;
                    case 4:
                        message.user = $root.api.User.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a OTCursor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OTCursor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OTCursor} OTCursor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OTCursor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a OTCursor message.
             * @function verify
             * @memberof api.OTCursor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OTCursor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position"))
                    if (!$util.isInteger(message.position))
                        return "position: integer expected";
                if (message.selectionStart != null && message.hasOwnProperty("selectionStart"))
                    if (!$util.isInteger(message.selectionStart))
                        return "selectionStart: integer expected";
                if (message.selectionEnd != null && message.hasOwnProperty("selectionEnd"))
                    if (!$util.isInteger(message.selectionEnd))
                        return "selectionEnd: integer expected";
                if (message.user != null && message.hasOwnProperty("user")) {
                    var error = $root.api.User.verify(message.user);
                    if (error)
                        return "user." + error;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };
    
            /**
             * Creates a OTCursor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OTCursor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OTCursor} OTCursor
             */
            OTCursor.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OTCursor)
                    return object;
                var message = new $root.api.OTCursor();
                if (object.position != null)
                    message.position = object.position >>> 0;
                if (object.selectionStart != null)
                    message.selectionStart = object.selectionStart >>> 0;
                if (object.selectionEnd != null)
                    message.selectionEnd = object.selectionEnd >>> 0;
                if (object.user != null) {
                    if (typeof object.user !== "object")
                        throw TypeError(".api.OTCursor.user: object expected");
                    message.user = $root.api.User.fromObject(object.user);
                }
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };
    
            /**
             * Creates a plain object from a OTCursor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OTCursor
             * @static
             * @param {api.OTCursor} message OTCursor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OTCursor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = 0;
                    object.selectionStart = 0;
                    object.selectionEnd = 0;
                    object.user = null;
                    object.id = "";
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = message.position;
                if (message.selectionStart != null && message.hasOwnProperty("selectionStart"))
                    object.selectionStart = message.selectionStart;
                if (message.selectionEnd != null && message.hasOwnProperty("selectionEnd"))
                    object.selectionEnd = message.selectionEnd;
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = $root.api.User.toObject(message.user, options);
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };
    
            /**
             * Converts this OTCursor to JSON.
             * @function toJSON
             * @memberof api.OTCursor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OTCursor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OTCursor;
        })();
    
        api.ChatMessage = (function() {
    
            /**
             * Properties of a ChatMessage.
             * @memberof api
             * @interface IChatMessage
             * @property {string|null} [username] ChatMessage username
             * @property {string|null} [text] ChatMessage text
             */
    
            /**
             * Constructs a new ChatMessage.
             * @memberof api
             * @classdesc Represents a ChatMessage.
             * @constructor
             * @param {api.IChatMessage=} [properties] Properties to set
             */
            function ChatMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChatMessage username.
             * @member {string} username
             * @memberof api.ChatMessage
             * @instance
             */
            ChatMessage.prototype.username = "";
    
            /**
             * ChatMessage text.
             * @member {string} text
             * @memberof api.ChatMessage
             * @instance
             */
            ChatMessage.prototype.text = "";
    
            /**
             * Creates a new ChatMessage instance using the specified properties.
             * @function create
             * @memberof api.ChatMessage
             * @static
             * @param {api.IChatMessage=} [properties] Properties to set
             * @returns {api.ChatMessage} ChatMessage instance
             */
            ChatMessage.create = function create(properties) {
                return ChatMessage.fromObject(properties);
            };
    
            /**
             * Encodes the specified ChatMessage message. Does not implicitly {@link api.ChatMessage.verify|verify} messages.
             * @function encode
             * @memberof api.ChatMessage
             * @static
             * @param {api.ChatMessage} message ChatMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                return writer;
            };
    
            /**
             * Encodes the specified ChatMessage message, length delimited. Does not implicitly {@link api.ChatMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ChatMessage
             * @static
             * @param {api.ChatMessage} message ChatMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChatMessage message from the specified reader or buffer.
             * @function decode
             * @memberof api.ChatMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ChatMessage} ChatMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChatMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.username = reader.string();
                        break;
                    case 2:
                        message.text = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChatMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ChatMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ChatMessage} ChatMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChatMessage message.
             * @function verify
             * @memberof api.ChatMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChatMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };
    
            /**
             * Creates a ChatMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ChatMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ChatMessage} ChatMessage
             */
            ChatMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ChatMessage)
                    return object;
                var message = new $root.api.ChatMessage();
                if (object.username != null)
                    message.username = String(object.username);
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };
    
            /**
             * Creates a plain object from a ChatMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ChatMessage
             * @static
             * @param {api.ChatMessage} message ChatMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChatMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.username = "";
                    object.text = "";
                }
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };
    
            /**
             * Converts this ChatMessage to JSON.
             * @function toJSON
             * @memberof api.ChatMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChatMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChatMessage;
        })();
    
        api.ChatTyping = (function() {
    
            /**
             * Properties of a ChatTyping.
             * @memberof api
             * @interface IChatTyping
             * @property {string|null} [username] ChatTyping username
             * @property {boolean|null} [typing] ChatTyping typing
             */
    
            /**
             * Constructs a new ChatTyping.
             * @memberof api
             * @classdesc Represents a ChatTyping.
             * @constructor
             * @param {api.IChatTyping=} [properties] Properties to set
             */
            function ChatTyping(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChatTyping username.
             * @member {string} username
             * @memberof api.ChatTyping
             * @instance
             */
            ChatTyping.prototype.username = "";
    
            /**
             * ChatTyping typing.
             * @member {boolean} typing
             * @memberof api.ChatTyping
             * @instance
             */
            ChatTyping.prototype.typing = false;
    
            /**
             * Creates a new ChatTyping instance using the specified properties.
             * @function create
             * @memberof api.ChatTyping
             * @static
             * @param {api.IChatTyping=} [properties] Properties to set
             * @returns {api.ChatTyping} ChatTyping instance
             */
            ChatTyping.create = function create(properties) {
                return ChatTyping.fromObject(properties);
            };
    
            /**
             * Encodes the specified ChatTyping message. Does not implicitly {@link api.ChatTyping.verify|verify} messages.
             * @function encode
             * @memberof api.ChatTyping
             * @static
             * @param {api.ChatTyping} message ChatTyping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatTyping.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
                if (message.typing != null && Object.hasOwnProperty.call(message, "typing"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.typing);
                return writer;
            };
    
            /**
             * Encodes the specified ChatTyping message, length delimited. Does not implicitly {@link api.ChatTyping.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ChatTyping
             * @static
             * @param {api.ChatTyping} message ChatTyping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatTyping.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChatTyping message from the specified reader or buffer.
             * @function decode
             * @memberof api.ChatTyping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ChatTyping} ChatTyping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatTyping.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChatTyping();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.username = reader.string();
                        break;
                    case 2:
                        message.typing = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChatTyping message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ChatTyping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ChatTyping} ChatTyping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatTyping.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChatTyping message.
             * @function verify
             * @memberof api.ChatTyping
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChatTyping.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.typing != null && message.hasOwnProperty("typing"))
                    if (typeof message.typing !== "boolean")
                        return "typing: boolean expected";
                return null;
            };
    
            /**
             * Creates a ChatTyping message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ChatTyping
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ChatTyping} ChatTyping
             */
            ChatTyping.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ChatTyping)
                    return object;
                var message = new $root.api.ChatTyping();
                if (object.username != null)
                    message.username = String(object.username);
                if (object.typing != null)
                    message.typing = Boolean(object.typing);
                return message;
            };
    
            /**
             * Creates a plain object from a ChatTyping message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ChatTyping
             * @static
             * @param {api.ChatTyping} message ChatTyping
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChatTyping.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.username = "";
                    object.typing = false;
                }
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.typing != null && message.hasOwnProperty("typing"))
                    object.typing = message.typing;
                return object;
            };
    
            /**
             * Converts this ChatTyping to JSON.
             * @function toJSON
             * @memberof api.ChatTyping
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChatTyping.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChatTyping;
        })();
    
        api.User = (function() {
    
            /**
             * Properties of a User.
             * @memberof api
             * @interface IUser
             * @property {number|null} [id] User id
             * @property {string|null} [name] User name
             * @property {Array.<string>|null} [roles] User roles
             * @property {number|null} [session] User session
             */
    
            /**
             * Constructs a new User.
             * @memberof api
             * @classdesc Represents a User.
             * @constructor
             * @param {api.IUser=} [properties] Properties to set
             */
            function User(properties) {
                this.roles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * User id.
             * @member {number} id
             * @memberof api.User
             * @instance
             */
            User.prototype.id = 0;
    
            /**
             * User name.
             * @member {string} name
             * @memberof api.User
             * @instance
             */
            User.prototype.name = "";
    
            /**
             * User roles.
             * @member {Array.<string>} roles
             * @memberof api.User
             * @instance
             */
            User.prototype.roles = $util.emptyArray;
    
            /**
             * User session.
             * @member {number} session
             * @memberof api.User
             * @instance
             */
            User.prototype.session = 0;
    
            /**
             * Creates a new User instance using the specified properties.
             * @function create
             * @memberof api.User
             * @static
             * @param {api.IUser=} [properties] Properties to set
             * @returns {api.User} User instance
             */
            User.create = function create(properties) {
                return User.fromObject(properties);
            };
    
            /**
             * Encodes the specified User message. Does not implicitly {@link api.User.verify|verify} messages.
             * @function encode
             * @memberof api.User
             * @static
             * @param {api.User} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.roles != null && message.roles.length)
                    for (var i = 0; i < message.roles.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.roles[i]);
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.session);
                return writer;
            };
    
            /**
             * Encodes the specified User message, length delimited. Does not implicitly {@link api.User.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.User
             * @static
             * @param {api.User} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a User message from the specified reader or buffer.
             * @function decode
             * @memberof api.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.User();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push(reader.string());
                        break;
                    case 4:
                        message.session = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a User message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a User message.
             * @function verify
             * @memberof api.User
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            User.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.roles != null && message.hasOwnProperty("roles")) {
                    if (!Array.isArray(message.roles))
                        return "roles: array expected";
                    for (var i = 0; i < message.roles.length; ++i)
                        if (!$util.isString(message.roles[i]))
                            return "roles: string[] expected";
                }
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isInteger(message.session))
                        return "session: integer expected";
                return null;
            };
    
            /**
             * Creates a User message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.User
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.User} User
             */
            User.fromObject = function fromObject(object) {
                if (object instanceof $root.api.User)
                    return object;
                var message = new $root.api.User();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.roles) {
                    if (!Array.isArray(object.roles))
                        throw TypeError(".api.User.roles: array expected");
                    message.roles = [];
                    for (var i = 0; i < object.roles.length; ++i)
                        message.roles[i] = String(object.roles[i]);
                }
                if (object.session != null)
                    message.session = object.session | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a User message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.User
             * @static
             * @param {api.User} message User
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            User.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.roles = [];
                if (options.defaults) {
                    object.id = 0;
                    object.name = "";
                    object.session = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.roles && message.roles.length) {
                    object.roles = [];
                    for (var j = 0; j < message.roles.length; ++j)
                        object.roles[j] = message.roles[j];
                }
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                return object;
            };
    
            /**
             * Converts this User to JSON.
             * @function toJSON
             * @memberof api.User
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            User.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return User;
        })();
    
        api.Roster = (function() {
    
            /**
             * Properties of a Roster.
             * @memberof api
             * @interface IRoster
             * @property {Array.<api.User|api.IUser>|null} [user] Roster user
             * @property {Array.<api.FileOpened|api.IFileOpened>|null} [files] Roster files
             */
    
            /**
             * Constructs a new Roster.
             * @memberof api
             * @classdesc Represents a Roster.
             * @constructor
             * @param {api.IRoster=} [properties] Properties to set
             */
            function Roster(properties) {
                this.user = [];
                this.files = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Roster user.
             * @member {Array.<api.User>} user
             * @memberof api.Roster
             * @instance
             */
            Roster.prototype.user = $util.emptyArray;
    
            /**
             * Roster files.
             * @member {Array.<api.FileOpened>} files
             * @memberof api.Roster
             * @instance
             */
            Roster.prototype.files = $util.emptyArray;
    
            /**
             * Creates a new Roster instance using the specified properties.
             * @function create
             * @memberof api.Roster
             * @static
             * @param {api.IRoster=} [properties] Properties to set
             * @returns {api.Roster} Roster instance
             */
            Roster.create = function create(properties) {
                return Roster.fromObject(properties);
            };
    
            /**
             * Encodes the specified Roster message. Does not implicitly {@link api.Roster.verify|verify} messages.
             * @function encode
             * @memberof api.Roster
             * @static
             * @param {api.Roster} message Roster message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Roster.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && message.user.length)
                    for (var i = 0; i < message.user.length; ++i)
                        $root.api.User.encode(message.user[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        $root.api.FileOpened.encode(message.files[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Roster message, length delimited. Does not implicitly {@link api.Roster.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Roster
             * @static
             * @param {api.Roster} message Roster message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Roster.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Roster message from the specified reader or buffer.
             * @function decode
             * @memberof api.Roster
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Roster} Roster
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Roster.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Roster();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.user && message.user.length))
                            message.user = [];
                        message.user.push($root.api.User.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.files && message.files.length))
                            message.files = [];
                        message.files.push($root.api.FileOpened.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Roster message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Roster
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Roster} Roster
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Roster.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Roster message.
             * @function verify
             * @memberof api.Roster
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Roster.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user")) {
                    if (!Array.isArray(message.user))
                        return "user: array expected";
                    for (var i = 0; i < message.user.length; ++i) {
                        var error = $root.api.User.verify(message.user[i]);
                        if (error)
                            return "user." + error;
                    }
                }
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i) {
                        var error = $root.api.FileOpened.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Roster message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Roster
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Roster} Roster
             */
            Roster.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Roster)
                    return object;
                var message = new $root.api.Roster();
                if (object.user) {
                    if (!Array.isArray(object.user))
                        throw TypeError(".api.Roster.user: array expected");
                    message.user = [];
                    for (var i = 0; i < object.user.length; ++i) {
                        if (typeof object.user[i] !== "object")
                            throw TypeError(".api.Roster.user: object expected");
                        message.user[i] = $root.api.User.fromObject(object.user[i]);
                    }
                }
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".api.Roster.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".api.Roster.files: object expected");
                        message.files[i] = $root.api.FileOpened.fromObject(object.files[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Roster message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Roster
             * @static
             * @param {api.Roster} message Roster
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Roster.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.user = [];
                    object.files = [];
                }
                if (message.user && message.user.length) {
                    object.user = [];
                    for (var j = 0; j < message.user.length; ++j)
                        object.user[j] = $root.api.User.toObject(message.user[j], options);
                }
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.api.FileOpened.toObject(message.files[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Roster to JSON.
             * @function toJSON
             * @memberof api.Roster
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Roster.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Roster;
        })();
    
        api.OpenFile = (function() {
    
            /**
             * Properties of an OpenFile.
             * @memberof api
             * @interface IOpenFile
             * @property {string|null} [file] OpenFile file
             */
    
            /**
             * Constructs a new OpenFile.
             * @memberof api
             * @classdesc Represents an OpenFile.
             * @constructor
             * @param {api.IOpenFile=} [properties] Properties to set
             */
            function OpenFile(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OpenFile file.
             * @member {string} file
             * @memberof api.OpenFile
             * @instance
             */
            OpenFile.prototype.file = "";
    
            /**
             * Creates a new OpenFile instance using the specified properties.
             * @function create
             * @memberof api.OpenFile
             * @static
             * @param {api.IOpenFile=} [properties] Properties to set
             * @returns {api.OpenFile} OpenFile instance
             */
            OpenFile.create = function create(properties) {
                return OpenFile.fromObject(properties);
            };
    
            /**
             * Encodes the specified OpenFile message. Does not implicitly {@link api.OpenFile.verify|verify} messages.
             * @function encode
             * @memberof api.OpenFile
             * @static
             * @param {api.OpenFile} message OpenFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenFile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file);
                return writer;
            };
    
            /**
             * Encodes the specified OpenFile message, length delimited. Does not implicitly {@link api.OpenFile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.OpenFile
             * @static
             * @param {api.OpenFile} message OpenFile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenFile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OpenFile message from the specified reader or buffer.
             * @function decode
             * @memberof api.OpenFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.OpenFile} OpenFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenFile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.OpenFile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.file = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OpenFile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.OpenFile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.OpenFile} OpenFile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenFile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OpenFile message.
             * @function verify
             * @memberof api.OpenFile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OpenFile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                return null;
            };
    
            /**
             * Creates an OpenFile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.OpenFile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.OpenFile} OpenFile
             */
            OpenFile.fromObject = function fromObject(object) {
                if (object instanceof $root.api.OpenFile)
                    return object;
                var message = new $root.api.OpenFile();
                if (object.file != null)
                    message.file = String(object.file);
                return message;
            };
    
            /**
             * Creates a plain object from an OpenFile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.OpenFile
             * @static
             * @param {api.OpenFile} message OpenFile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OpenFile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.file = "";
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                return object;
            };
    
            /**
             * Converts this OpenFile to JSON.
             * @function toJSON
             * @memberof api.OpenFile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OpenFile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OpenFile;
        })();
    
        api.FileOpened = (function() {
    
            /**
             * Properties of a FileOpened.
             * @memberof api
             * @interface IFileOpened
             * @property {number|null} [userId] FileOpened userId
             * @property {string|null} [file] FileOpened file
             * @property {number|null} [session] FileOpened session
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [timestamp] FileOpened timestamp
             */
    
            /**
             * Constructs a new FileOpened.
             * @memberof api
             * @classdesc Represents a FileOpened.
             * @constructor
             * @param {api.IFileOpened=} [properties] Properties to set
             */
            function FileOpened(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FileOpened userId.
             * @member {number} userId
             * @memberof api.FileOpened
             * @instance
             */
            FileOpened.prototype.userId = 0;
    
            /**
             * FileOpened file.
             * @member {string} file
             * @memberof api.FileOpened
             * @instance
             */
            FileOpened.prototype.file = "";
    
            /**
             * FileOpened session.
             * @member {number} session
             * @memberof api.FileOpened
             * @instance
             */
            FileOpened.prototype.session = 0;
    
            /**
             * FileOpened timestamp.
             * @member {google.protobuf.Timestamp|null|undefined} timestamp
             * @memberof api.FileOpened
             * @instance
             */
            FileOpened.prototype.timestamp = null;
    
            /**
             * Creates a new FileOpened instance using the specified properties.
             * @function create
             * @memberof api.FileOpened
             * @static
             * @param {api.IFileOpened=} [properties] Properties to set
             * @returns {api.FileOpened} FileOpened instance
             */
            FileOpened.create = function create(properties) {
                return FileOpened.fromObject(properties);
            };
    
            /**
             * Encodes the specified FileOpened message. Does not implicitly {@link api.FileOpened.verify|verify} messages.
             * @function encode
             * @memberof api.FileOpened
             * @static
             * @param {api.FileOpened} message FileOpened message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOpened.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.userId);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file);
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.session);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FileOpened message, length delimited. Does not implicitly {@link api.FileOpened.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.FileOpened
             * @static
             * @param {api.FileOpened} message FileOpened message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOpened.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FileOpened message from the specified reader or buffer.
             * @function decode
             * @memberof api.FileOpened
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.FileOpened} FileOpened
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOpened.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.FileOpened();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.userId = reader.uint32();
                        break;
                    case 2:
                        message.file = reader.string();
                        break;
                    case 3:
                        message.session = reader.int32();
                        break;
                    case 4:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FileOpened message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.FileOpened
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.FileOpened} FileOpened
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOpened.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FileOpened message.
             * @function verify
             * @memberof api.FileOpened
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOpened.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isInteger(message.userId))
                        return "userId: integer expected";
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isInteger(message.session))
                        return "session: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                return null;
            };
    
            /**
             * Creates a FileOpened message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.FileOpened
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.FileOpened} FileOpened
             */
            FileOpened.fromObject = function fromObject(object) {
                if (object instanceof $root.api.FileOpened)
                    return object;
                var message = new $root.api.FileOpened();
                if (object.userId != null)
                    message.userId = object.userId >>> 0;
                if (object.file != null)
                    message.file = String(object.file);
                if (object.session != null)
                    message.session = object.session | 0;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".api.FileOpened.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FileOpened message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.FileOpened
             * @static
             * @param {api.FileOpened} message FileOpened
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOpened.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.userId = 0;
                    object.file = "";
                    object.session = 0;
                    object.timestamp = null;
                }
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                return object;
            };
    
            /**
             * Converts this FileOpened to JSON.
             * @function toJSON
             * @memberof api.FileOpened
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOpened.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FileOpened;
        })();
    
        api.UpdateSessionTimestamp = (function() {
    
            /**
             * Properties of an UpdateSessionTimestamp.
             * @memberof api
             * @interface IUpdateSessionTimestamp
             */
    
            /**
             * Constructs a new UpdateSessionTimestamp.
             * @memberof api
             * @classdesc Represents an UpdateSessionTimestamp.
             * @constructor
             * @param {api.IUpdateSessionTimestamp=} [properties] Properties to set
             */
            function UpdateSessionTimestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new UpdateSessionTimestamp instance using the specified properties.
             * @function create
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {api.IUpdateSessionTimestamp=} [properties] Properties to set
             * @returns {api.UpdateSessionTimestamp} UpdateSessionTimestamp instance
             */
            UpdateSessionTimestamp.create = function create(properties) {
                return UpdateSessionTimestamp.fromObject(properties);
            };
    
            /**
             * Encodes the specified UpdateSessionTimestamp message. Does not implicitly {@link api.UpdateSessionTimestamp.verify|verify} messages.
             * @function encode
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {api.UpdateSessionTimestamp} message UpdateSessionTimestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateSessionTimestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified UpdateSessionTimestamp message, length delimited. Does not implicitly {@link api.UpdateSessionTimestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {api.UpdateSessionTimestamp} message UpdateSessionTimestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateSessionTimestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UpdateSessionTimestamp message from the specified reader or buffer.
             * @function decode
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.UpdateSessionTimestamp} UpdateSessionTimestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateSessionTimestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.UpdateSessionTimestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UpdateSessionTimestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.UpdateSessionTimestamp} UpdateSessionTimestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateSessionTimestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UpdateSessionTimestamp message.
             * @function verify
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateSessionTimestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates an UpdateSessionTimestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.UpdateSessionTimestamp} UpdateSessionTimestamp
             */
            UpdateSessionTimestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.api.UpdateSessionTimestamp)
                    return object;
                return new $root.api.UpdateSessionTimestamp();
            };
    
            /**
             * Creates a plain object from an UpdateSessionTimestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.UpdateSessionTimestamp
             * @static
             * @param {api.UpdateSessionTimestamp} message UpdateSessionTimestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateSessionTimestamp.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this UpdateSessionTimestamp to JSON.
             * @function toJSON
             * @memberof api.UpdateSessionTimestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateSessionTimestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UpdateSessionTimestamp;
        })();
    
        api.SessionTimestampUpdated = (function() {
    
            /**
             * Properties of a SessionTimestampUpdated.
             * @memberof api
             * @interface ISessionTimestampUpdated
             * @property {number|null} [session] SessionTimestampUpdated session
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [timestamp] SessionTimestampUpdated timestamp
             */
    
            /**
             * Constructs a new SessionTimestampUpdated.
             * @memberof api
             * @classdesc Represents a SessionTimestampUpdated.
             * @constructor
             * @param {api.ISessionTimestampUpdated=} [properties] Properties to set
             */
            function SessionTimestampUpdated(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SessionTimestampUpdated session.
             * @member {number} session
             * @memberof api.SessionTimestampUpdated
             * @instance
             */
            SessionTimestampUpdated.prototype.session = 0;
    
            /**
             * SessionTimestampUpdated timestamp.
             * @member {google.protobuf.Timestamp|null|undefined} timestamp
             * @memberof api.SessionTimestampUpdated
             * @instance
             */
            SessionTimestampUpdated.prototype.timestamp = null;
    
            /**
             * Creates a new SessionTimestampUpdated instance using the specified properties.
             * @function create
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {api.ISessionTimestampUpdated=} [properties] Properties to set
             * @returns {api.SessionTimestampUpdated} SessionTimestampUpdated instance
             */
            SessionTimestampUpdated.create = function create(properties) {
                return SessionTimestampUpdated.fromObject(properties);
            };
    
            /**
             * Encodes the specified SessionTimestampUpdated message. Does not implicitly {@link api.SessionTimestampUpdated.verify|verify} messages.
             * @function encode
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {api.SessionTimestampUpdated} message SessionTimestampUpdated message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionTimestampUpdated.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.session);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SessionTimestampUpdated message, length delimited. Does not implicitly {@link api.SessionTimestampUpdated.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {api.SessionTimestampUpdated} message SessionTimestampUpdated message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionTimestampUpdated.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SessionTimestampUpdated message from the specified reader or buffer.
             * @function decode
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.SessionTimestampUpdated} SessionTimestampUpdated
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionTimestampUpdated.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SessionTimestampUpdated();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.int32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SessionTimestampUpdated message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.SessionTimestampUpdated} SessionTimestampUpdated
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionTimestampUpdated.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SessionTimestampUpdated message.
             * @function verify
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SessionTimestampUpdated.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isInteger(message.session))
                        return "session: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                return null;
            };
    
            /**
             * Creates a SessionTimestampUpdated message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.SessionTimestampUpdated} SessionTimestampUpdated
             */
            SessionTimestampUpdated.fromObject = function fromObject(object) {
                if (object instanceof $root.api.SessionTimestampUpdated)
                    return object;
                var message = new $root.api.SessionTimestampUpdated();
                if (object.session != null)
                    message.session = object.session | 0;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".api.SessionTimestampUpdated.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SessionTimestampUpdated message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.SessionTimestampUpdated
             * @static
             * @param {api.SessionTimestampUpdated} message SessionTimestampUpdated
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SessionTimestampUpdated.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.session = 0;
                    object.timestamp = null;
                }
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                return object;
            };
    
            /**
             * Converts this SessionTimestampUpdated to JSON.
             * @function toJSON
             * @memberof api.SessionTimestampUpdated
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SessionTimestampUpdated.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SessionTimestampUpdated;
        })();
    
        api.FollowUser = (function() {
    
            /**
             * Properties of a FollowUser.
             * @memberof api
             * @interface IFollowUser
             * @property {number|null} [session] FollowUser session
             */
    
            /**
             * Constructs a new FollowUser.
             * @memberof api
             * @classdesc Represents a FollowUser.
             * @constructor
             * @param {api.IFollowUser=} [properties] Properties to set
             */
            function FollowUser(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FollowUser session.
             * @member {number} session
             * @memberof api.FollowUser
             * @instance
             */
            FollowUser.prototype.session = 0;
    
            /**
             * Creates a new FollowUser instance using the specified properties.
             * @function create
             * @memberof api.FollowUser
             * @static
             * @param {api.IFollowUser=} [properties] Properties to set
             * @returns {api.FollowUser} FollowUser instance
             */
            FollowUser.create = function create(properties) {
                return FollowUser.fromObject(properties);
            };
    
            /**
             * Encodes the specified FollowUser message. Does not implicitly {@link api.FollowUser.verify|verify} messages.
             * @function encode
             * @memberof api.FollowUser
             * @static
             * @param {api.FollowUser} message FollowUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FollowUser.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.session);
                return writer;
            };
    
            /**
             * Encodes the specified FollowUser message, length delimited. Does not implicitly {@link api.FollowUser.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.FollowUser
             * @static
             * @param {api.FollowUser} message FollowUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FollowUser.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FollowUser message from the specified reader or buffer.
             * @function decode
             * @memberof api.FollowUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.FollowUser} FollowUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FollowUser.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.FollowUser();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FollowUser message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.FollowUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.FollowUser} FollowUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FollowUser.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FollowUser message.
             * @function verify
             * @memberof api.FollowUser
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FollowUser.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isInteger(message.session))
                        return "session: integer expected";
                return null;
            };
    
            /**
             * Creates a FollowUser message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.FollowUser
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.FollowUser} FollowUser
             */
            FollowUser.fromObject = function fromObject(object) {
                if (object instanceof $root.api.FollowUser)
                    return object;
                var message = new $root.api.FollowUser();
                if (object.session != null)
                    message.session = object.session | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a FollowUser message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.FollowUser
             * @static
             * @param {api.FollowUser} message FollowUser
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FollowUser.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.session = 0;
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                return object;
            };
    
            /**
             * Converts this FollowUser to JSON.
             * @function toJSON
             * @memberof api.FollowUser
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FollowUser.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FollowUser;
        })();
    
        api.UnfollowUser = (function() {
    
            /**
             * Properties of an UnfollowUser.
             * @memberof api
             * @interface IUnfollowUser
             * @property {number|null} [session] UnfollowUser session
             */
    
            /**
             * Constructs a new UnfollowUser.
             * @memberof api
             * @classdesc Represents an UnfollowUser.
             * @constructor
             * @param {api.IUnfollowUser=} [properties] Properties to set
             */
            function UnfollowUser(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UnfollowUser session.
             * @member {number} session
             * @memberof api.UnfollowUser
             * @instance
             */
            UnfollowUser.prototype.session = 0;
    
            /**
             * Creates a new UnfollowUser instance using the specified properties.
             * @function create
             * @memberof api.UnfollowUser
             * @static
             * @param {api.IUnfollowUser=} [properties] Properties to set
             * @returns {api.UnfollowUser} UnfollowUser instance
             */
            UnfollowUser.create = function create(properties) {
                return UnfollowUser.fromObject(properties);
            };
    
            /**
             * Encodes the specified UnfollowUser message. Does not implicitly {@link api.UnfollowUser.verify|verify} messages.
             * @function encode
             * @memberof api.UnfollowUser
             * @static
             * @param {api.UnfollowUser} message UnfollowUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnfollowUser.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.session);
                return writer;
            };
    
            /**
             * Encodes the specified UnfollowUser message, length delimited. Does not implicitly {@link api.UnfollowUser.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.UnfollowUser
             * @static
             * @param {api.UnfollowUser} message UnfollowUser message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnfollowUser.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an UnfollowUser message from the specified reader or buffer.
             * @function decode
             * @memberof api.UnfollowUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.UnfollowUser} UnfollowUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnfollowUser.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.UnfollowUser();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an UnfollowUser message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.UnfollowUser
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.UnfollowUser} UnfollowUser
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnfollowUser.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an UnfollowUser message.
             * @function verify
             * @memberof api.UnfollowUser
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnfollowUser.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isInteger(message.session))
                        return "session: integer expected";
                return null;
            };
    
            /**
             * Creates an UnfollowUser message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.UnfollowUser
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.UnfollowUser} UnfollowUser
             */
            UnfollowUser.fromObject = function fromObject(object) {
                if (object instanceof $root.api.UnfollowUser)
                    return object;
                var message = new $root.api.UnfollowUser();
                if (object.session != null)
                    message.session = object.session | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an UnfollowUser message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.UnfollowUser
             * @static
             * @param {api.UnfollowUser} message UnfollowUser
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnfollowUser.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.session = 0;
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                return object;
            };
    
            /**
             * Converts this UnfollowUser to JSON.
             * @function toJSON
             * @memberof api.UnfollowUser
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnfollowUser.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return UnfollowUser;
        })();
    
        api.Exec = (function() {
    
            /**
             * Properties of an Exec.
             * @memberof api
             * @interface IExec
             * @property {Array.<string>|null} [args] Exec args
             * @property {Object.<string,string>|null} [env] Exec env
             * @property {boolean|null} [blocking] Exec blocking
             */
    
            /**
             * Constructs a new Exec.
             * @memberof api
             * @classdesc Represents an Exec.
             * @constructor
             * @param {api.IExec=} [properties] Properties to set
             */
            function Exec(properties) {
                this.args = [];
                this.env = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Exec args.
             * @member {Array.<string>} args
             * @memberof api.Exec
             * @instance
             */
            Exec.prototype.args = $util.emptyArray;
    
            /**
             * Exec env.
             * @member {Object.<string,string>} env
             * @memberof api.Exec
             * @instance
             */
            Exec.prototype.env = $util.emptyObject;
    
            /**
             * Exec blocking.
             * @member {boolean} blocking
             * @memberof api.Exec
             * @instance
             */
            Exec.prototype.blocking = false;
    
            /**
             * Creates a new Exec instance using the specified properties.
             * @function create
             * @memberof api.Exec
             * @static
             * @param {api.IExec=} [properties] Properties to set
             * @returns {api.Exec} Exec instance
             */
            Exec.create = function create(properties) {
                return Exec.fromObject(properties);
            };
    
            /**
             * Encodes the specified Exec message. Does not implicitly {@link api.Exec.verify|verify} messages.
             * @function encode
             * @memberof api.Exec
             * @static
             * @param {api.Exec} message Exec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Exec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.args != null && message.args.length)
                    for (var i = 0; i < message.args.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.args[i]);
                if (message.env != null && Object.hasOwnProperty.call(message, "env"))
                    for (var keys = Object.keys(message.env), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.env[keys[i]]).ldelim();
                if (message.blocking != null && Object.hasOwnProperty.call(message, "blocking"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.blocking);
                return writer;
            };
    
            /**
             * Encodes the specified Exec message, length delimited. Does not implicitly {@link api.Exec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Exec
             * @static
             * @param {api.Exec} message Exec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Exec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Exec message from the specified reader or buffer.
             * @function decode
             * @memberof api.Exec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Exec} Exec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Exec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Exec(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.args && message.args.length))
                            message.args = [];
                        message.args.push(reader.string());
                        break;
                    case 2:
                        if (message.env === $util.emptyObject)
                            message.env = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.env[key] = value;
                        break;
                    case 3:
                        message.blocking = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Exec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Exec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Exec} Exec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Exec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Exec message.
             * @function verify
             * @memberof api.Exec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Exec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.args != null && message.hasOwnProperty("args")) {
                    if (!Array.isArray(message.args))
                        return "args: array expected";
                    for (var i = 0; i < message.args.length; ++i)
                        if (!$util.isString(message.args[i]))
                            return "args: string[] expected";
                }
                if (message.env != null && message.hasOwnProperty("env")) {
                    if (!$util.isObject(message.env))
                        return "env: object expected";
                    var key = Object.keys(message.env);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.env[key[i]]))
                            return "env: string{k:string} expected";
                }
                if (message.blocking != null && message.hasOwnProperty("blocking"))
                    if (typeof message.blocking !== "boolean")
                        return "blocking: boolean expected";
                return null;
            };
    
            /**
             * Creates an Exec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Exec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Exec} Exec
             */
            Exec.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Exec)
                    return object;
                var message = new $root.api.Exec();
                if (object.args) {
                    if (!Array.isArray(object.args))
                        throw TypeError(".api.Exec.args: array expected");
                    message.args = [];
                    for (var i = 0; i < object.args.length; ++i)
                        message.args[i] = String(object.args[i]);
                }
                if (object.env) {
                    if (typeof object.env !== "object")
                        throw TypeError(".api.Exec.env: object expected");
                    message.env = {};
                    for (var keys = Object.keys(object.env), i = 0; i < keys.length; ++i)
                        message.env[keys[i]] = String(object.env[keys[i]]);
                }
                if (object.blocking != null)
                    message.blocking = Boolean(object.blocking);
                return message;
            };
    
            /**
             * Creates a plain object from an Exec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Exec
             * @static
             * @param {api.Exec} message Exec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Exec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.args = [];
                if (options.objects || options.defaults)
                    object.env = {};
                if (options.defaults)
                    object.blocking = false;
                if (message.args && message.args.length) {
                    object.args = [];
                    for (var j = 0; j < message.args.length; ++j)
                        object.args[j] = message.args[j];
                }
                var keys2;
                if (message.env && (keys2 = Object.keys(message.env)).length) {
                    object.env = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.env[keys2[j]] = message.env[keys2[j]];
                }
                if (message.blocking != null && message.hasOwnProperty("blocking"))
                    object.blocking = message.blocking;
                return object;
            };
    
            /**
             * Converts this Exec to JSON.
             * @function toJSON
             * @memberof api.Exec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Exec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Exec;
        })();
    
        api.Package = (function() {
    
            /**
             * Properties of a Package.
             * @memberof api
             * @interface IPackage
             * @property {string|null} [name] Package name
             * @property {string|null} [spec] Package spec
             * @property {string|null} [description] Package description
             * @property {string|null} [version] Package version
             * @property {string|null} [homepageURL] Package homepageURL
             * @property {string|null} [documentationURL] Package documentationURL
             * @property {string|null} [sourceCodeURL] Package sourceCodeURL
             * @property {string|null} [bugTrackerURL] Package bugTrackerURL
             * @property {string|null} [author] Package author
             * @property {string|null} [license] Package license
             * @property {Array.<api.Package|api.IPackage>|null} [dependencies] Package dependencies
             */
    
            /**
             * Constructs a new Package.
             * @memberof api
             * @classdesc Represents a Package.
             * @constructor
             * @param {api.IPackage=} [properties] Properties to set
             */
            function Package(properties) {
                this.dependencies = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Package name.
             * @member {string} name
             * @memberof api.Package
             * @instance
             */
            Package.prototype.name = "";
    
            /**
             * Package spec.
             * @member {string} spec
             * @memberof api.Package
             * @instance
             */
            Package.prototype.spec = "";
    
            /**
             * Package description.
             * @member {string} description
             * @memberof api.Package
             * @instance
             */
            Package.prototype.description = "";
    
            /**
             * Package version.
             * @member {string} version
             * @memberof api.Package
             * @instance
             */
            Package.prototype.version = "";
    
            /**
             * Package homepageURL.
             * @member {string} homepageURL
             * @memberof api.Package
             * @instance
             */
            Package.prototype.homepageURL = "";
    
            /**
             * Package documentationURL.
             * @member {string} documentationURL
             * @memberof api.Package
             * @instance
             */
            Package.prototype.documentationURL = "";
    
            /**
             * Package sourceCodeURL.
             * @member {string} sourceCodeURL
             * @memberof api.Package
             * @instance
             */
            Package.prototype.sourceCodeURL = "";
    
            /**
             * Package bugTrackerURL.
             * @member {string} bugTrackerURL
             * @memberof api.Package
             * @instance
             */
            Package.prototype.bugTrackerURL = "";
    
            /**
             * Package author.
             * @member {string} author
             * @memberof api.Package
             * @instance
             */
            Package.prototype.author = "";
    
            /**
             * Package license.
             * @member {string} license
             * @memberof api.Package
             * @instance
             */
            Package.prototype.license = "";
    
            /**
             * Package dependencies.
             * @member {Array.<api.Package>} dependencies
             * @memberof api.Package
             * @instance
             */
            Package.prototype.dependencies = $util.emptyArray;
    
            /**
             * Creates a new Package instance using the specified properties.
             * @function create
             * @memberof api.Package
             * @static
             * @param {api.IPackage=} [properties] Properties to set
             * @returns {api.Package} Package instance
             */
            Package.create = function create(properties) {
                return Package.fromObject(properties);
            };
    
            /**
             * Encodes the specified Package message. Does not implicitly {@link api.Package.verify|verify} messages.
             * @function encode
             * @memberof api.Package
             * @static
             * @param {api.Package} message Package message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Package.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.spec != null && Object.hasOwnProperty.call(message, "spec"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.spec);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.description);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.version);
                if (message.homepageURL != null && Object.hasOwnProperty.call(message, "homepageURL"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.homepageURL);
                if (message.documentationURL != null && Object.hasOwnProperty.call(message, "documentationURL"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.documentationURL);
                if (message.sourceCodeURL != null && Object.hasOwnProperty.call(message, "sourceCodeURL"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.sourceCodeURL);
                if (message.bugTrackerURL != null && Object.hasOwnProperty.call(message, "bugTrackerURL"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.bugTrackerURL);
                if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.author);
                if (message.license != null && Object.hasOwnProperty.call(message, "license"))
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.license);
                if (message.dependencies != null && message.dependencies.length)
                    for (var i = 0; i < message.dependencies.length; ++i)
                        $root.api.Package.encode(message.dependencies[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Package message, length delimited. Does not implicitly {@link api.Package.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Package
             * @static
             * @param {api.Package} message Package message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Package.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Package message from the specified reader or buffer.
             * @function decode
             * @memberof api.Package
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Package} Package
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Package.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Package();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.spec = reader.string();
                        break;
                    case 10:
                        message.description = reader.string();
                        break;
                    case 11:
                        message.version = reader.string();
                        break;
                    case 12:
                        message.homepageURL = reader.string();
                        break;
                    case 13:
                        message.documentationURL = reader.string();
                        break;
                    case 14:
                        message.sourceCodeURL = reader.string();
                        break;
                    case 15:
                        message.bugTrackerURL = reader.string();
                        break;
                    case 16:
                        message.author = reader.string();
                        break;
                    case 17:
                        message.license = reader.string();
                        break;
                    case 18:
                        if (!(message.dependencies && message.dependencies.length))
                            message.dependencies = [];
                        message.dependencies.push($root.api.Package.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Package message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Package
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Package} Package
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Package.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Package message.
             * @function verify
             * @memberof api.Package
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Package.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.spec != null && message.hasOwnProperty("spec"))
                    if (!$util.isString(message.spec))
                        return "spec: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.homepageURL != null && message.hasOwnProperty("homepageURL"))
                    if (!$util.isString(message.homepageURL))
                        return "homepageURL: string expected";
                if (message.documentationURL != null && message.hasOwnProperty("documentationURL"))
                    if (!$util.isString(message.documentationURL))
                        return "documentationURL: string expected";
                if (message.sourceCodeURL != null && message.hasOwnProperty("sourceCodeURL"))
                    if (!$util.isString(message.sourceCodeURL))
                        return "sourceCodeURL: string expected";
                if (message.bugTrackerURL != null && message.hasOwnProperty("bugTrackerURL"))
                    if (!$util.isString(message.bugTrackerURL))
                        return "bugTrackerURL: string expected";
                if (message.author != null && message.hasOwnProperty("author"))
                    if (!$util.isString(message.author))
                        return "author: string expected";
                if (message.license != null && message.hasOwnProperty("license"))
                    if (!$util.isString(message.license))
                        return "license: string expected";
                if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                    if (!Array.isArray(message.dependencies))
                        return "dependencies: array expected";
                    for (var i = 0; i < message.dependencies.length; ++i) {
                        var error = $root.api.Package.verify(message.dependencies[i]);
                        if (error)
                            return "dependencies." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Package message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Package
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Package} Package
             */
            Package.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Package)
                    return object;
                var message = new $root.api.Package();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.spec != null)
                    message.spec = String(object.spec);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.homepageURL != null)
                    message.homepageURL = String(object.homepageURL);
                if (object.documentationURL != null)
                    message.documentationURL = String(object.documentationURL);
                if (object.sourceCodeURL != null)
                    message.sourceCodeURL = String(object.sourceCodeURL);
                if (object.bugTrackerURL != null)
                    message.bugTrackerURL = String(object.bugTrackerURL);
                if (object.author != null)
                    message.author = String(object.author);
                if (object.license != null)
                    message.license = String(object.license);
                if (object.dependencies) {
                    if (!Array.isArray(object.dependencies))
                        throw TypeError(".api.Package.dependencies: array expected");
                    message.dependencies = [];
                    for (var i = 0; i < object.dependencies.length; ++i) {
                        if (typeof object.dependencies[i] !== "object")
                            throw TypeError(".api.Package.dependencies: object expected");
                        message.dependencies[i] = $root.api.Package.fromObject(object.dependencies[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Package message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Package
             * @static
             * @param {api.Package} message Package
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Package.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.dependencies = [];
                if (options.defaults) {
                    object.name = "";
                    object.spec = "";
                    object.description = "";
                    object.version = "";
                    object.homepageURL = "";
                    object.documentationURL = "";
                    object.sourceCodeURL = "";
                    object.bugTrackerURL = "";
                    object.author = "";
                    object.license = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.spec != null && message.hasOwnProperty("spec"))
                    object.spec = message.spec;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.homepageURL != null && message.hasOwnProperty("homepageURL"))
                    object.homepageURL = message.homepageURL;
                if (message.documentationURL != null && message.hasOwnProperty("documentationURL"))
                    object.documentationURL = message.documentationURL;
                if (message.sourceCodeURL != null && message.hasOwnProperty("sourceCodeURL"))
                    object.sourceCodeURL = message.sourceCodeURL;
                if (message.bugTrackerURL != null && message.hasOwnProperty("bugTrackerURL"))
                    object.bugTrackerURL = message.bugTrackerURL;
                if (message.author != null && message.hasOwnProperty("author"))
                    object.author = message.author;
                if (message.license != null && message.hasOwnProperty("license"))
                    object.license = message.license;
                if (message.dependencies && message.dependencies.length) {
                    object.dependencies = [];
                    for (var j = 0; j < message.dependencies.length; ++j)
                        object.dependencies[j] = $root.api.Package.toObject(message.dependencies[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Package to JSON.
             * @function toJSON
             * @memberof api.Package
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Package.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Package;
        })();
    
        api.PackageSearch = (function() {
    
            /**
             * Properties of a PackageSearch.
             * @memberof api
             * @interface IPackageSearch
             * @property {string|null} [query] PackageSearch query
             */
    
            /**
             * Constructs a new PackageSearch.
             * @memberof api
             * @classdesc Represents a PackageSearch.
             * @constructor
             * @param {api.IPackageSearch=} [properties] Properties to set
             */
            function PackageSearch(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PackageSearch query.
             * @member {string} query
             * @memberof api.PackageSearch
             * @instance
             */
            PackageSearch.prototype.query = "";
    
            /**
             * Creates a new PackageSearch instance using the specified properties.
             * @function create
             * @memberof api.PackageSearch
             * @static
             * @param {api.IPackageSearch=} [properties] Properties to set
             * @returns {api.PackageSearch} PackageSearch instance
             */
            PackageSearch.create = function create(properties) {
                return PackageSearch.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageSearch message. Does not implicitly {@link api.PackageSearch.verify|verify} messages.
             * @function encode
             * @memberof api.PackageSearch
             * @static
             * @param {api.PackageSearch} message PackageSearch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageSearch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                return writer;
            };
    
            /**
             * Encodes the specified PackageSearch message, length delimited. Does not implicitly {@link api.PackageSearch.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageSearch
             * @static
             * @param {api.PackageSearch} message PackageSearch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageSearch.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageSearch message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageSearch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageSearch} PackageSearch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageSearch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageSearch();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageSearch message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageSearch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageSearch} PackageSearch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageSearch.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageSearch message.
             * @function verify
             * @memberof api.PackageSearch
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageSearch.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                return null;
            };
    
            /**
             * Creates a PackageSearch message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageSearch
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageSearch} PackageSearch
             */
            PackageSearch.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageSearch)
                    return object;
                var message = new $root.api.PackageSearch();
                if (object.query != null)
                    message.query = String(object.query);
                return message;
            };
    
            /**
             * Creates a plain object from a PackageSearch message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageSearch
             * @static
             * @param {api.PackageSearch} message PackageSearch
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageSearch.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.query = "";
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                return object;
            };
    
            /**
             * Converts this PackageSearch to JSON.
             * @function toJSON
             * @memberof api.PackageSearch
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageSearch.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageSearch;
        })();
    
        api.PackageSearchResp = (function() {
    
            /**
             * Properties of a PackageSearchResp.
             * @memberof api
             * @interface IPackageSearchResp
             * @property {Array.<api.Package|api.IPackage>|null} [results] PackageSearchResp results
             */
    
            /**
             * Constructs a new PackageSearchResp.
             * @memberof api
             * @classdesc Represents a PackageSearchResp.
             * @constructor
             * @param {api.IPackageSearchResp=} [properties] Properties to set
             */
            function PackageSearchResp(properties) {
                this.results = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PackageSearchResp results.
             * @member {Array.<api.Package>} results
             * @memberof api.PackageSearchResp
             * @instance
             */
            PackageSearchResp.prototype.results = $util.emptyArray;
    
            /**
             * Creates a new PackageSearchResp instance using the specified properties.
             * @function create
             * @memberof api.PackageSearchResp
             * @static
             * @param {api.IPackageSearchResp=} [properties] Properties to set
             * @returns {api.PackageSearchResp} PackageSearchResp instance
             */
            PackageSearchResp.create = function create(properties) {
                return PackageSearchResp.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageSearchResp message. Does not implicitly {@link api.PackageSearchResp.verify|verify} messages.
             * @function encode
             * @memberof api.PackageSearchResp
             * @static
             * @param {api.PackageSearchResp} message PackageSearchResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageSearchResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && message.results.length)
                    for (var i = 0; i < message.results.length; ++i)
                        $root.api.Package.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PackageSearchResp message, length delimited. Does not implicitly {@link api.PackageSearchResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageSearchResp
             * @static
             * @param {api.PackageSearchResp} message PackageSearchResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageSearchResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageSearchResp message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageSearchResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageSearchResp} PackageSearchResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageSearchResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageSearchResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.results && message.results.length))
                            message.results = [];
                        message.results.push($root.api.Package.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageSearchResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageSearchResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageSearchResp} PackageSearchResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageSearchResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageSearchResp message.
             * @function verify
             * @memberof api.PackageSearchResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageSearchResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results")) {
                    if (!Array.isArray(message.results))
                        return "results: array expected";
                    for (var i = 0; i < message.results.length; ++i) {
                        var error = $root.api.Package.verify(message.results[i]);
                        if (error)
                            return "results." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a PackageSearchResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageSearchResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageSearchResp} PackageSearchResp
             */
            PackageSearchResp.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageSearchResp)
                    return object;
                var message = new $root.api.PackageSearchResp();
                if (object.results) {
                    if (!Array.isArray(object.results))
                        throw TypeError(".api.PackageSearchResp.results: array expected");
                    message.results = [];
                    for (var i = 0; i < object.results.length; ++i) {
                        if (typeof object.results[i] !== "object")
                            throw TypeError(".api.PackageSearchResp.results: object expected");
                        message.results[i] = $root.api.Package.fromObject(object.results[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PackageSearchResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageSearchResp
             * @static
             * @param {api.PackageSearchResp} message PackageSearchResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageSearchResp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.results = [];
                if (message.results && message.results.length) {
                    object.results = [];
                    for (var j = 0; j < message.results.length; ++j)
                        object.results[j] = $root.api.Package.toObject(message.results[j], options);
                }
                return object;
            };
    
            /**
             * Converts this PackageSearchResp to JSON.
             * @function toJSON
             * @memberof api.PackageSearchResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageSearchResp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageSearchResp;
        })();
    
        api.PackageInfo = (function() {
    
            /**
             * Properties of a PackageInfo.
             * @memberof api
             * @interface IPackageInfo
             * @property {api.Package|api.IPackage|null} [pkg] PackageInfo pkg
             */
    
            /**
             * Constructs a new PackageInfo.
             * @memberof api
             * @classdesc Represents a PackageInfo.
             * @constructor
             * @param {api.IPackageInfo=} [properties] Properties to set
             */
            function PackageInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PackageInfo pkg.
             * @member {api.Package|null|undefined} pkg
             * @memberof api.PackageInfo
             * @instance
             */
            PackageInfo.prototype.pkg = null;
    
            /**
             * Creates a new PackageInfo instance using the specified properties.
             * @function create
             * @memberof api.PackageInfo
             * @static
             * @param {api.IPackageInfo=} [properties] Properties to set
             * @returns {api.PackageInfo} PackageInfo instance
             */
            PackageInfo.create = function create(properties) {
                return PackageInfo.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageInfo message. Does not implicitly {@link api.PackageInfo.verify|verify} messages.
             * @function encode
             * @memberof api.PackageInfo
             * @static
             * @param {api.PackageInfo} message PackageInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkg != null && Object.hasOwnProperty.call(message, "pkg"))
                    $root.api.Package.encode(message.pkg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PackageInfo message, length delimited. Does not implicitly {@link api.PackageInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageInfo
             * @static
             * @param {api.PackageInfo} message PackageInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageInfo message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageInfo} PackageInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pkg = $root.api.Package.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageInfo} PackageInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageInfo message.
             * @function verify
             * @memberof api.PackageInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkg != null && message.hasOwnProperty("pkg")) {
                    var error = $root.api.Package.verify(message.pkg);
                    if (error)
                        return "pkg." + error;
                }
                return null;
            };
    
            /**
             * Creates a PackageInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageInfo} PackageInfo
             */
            PackageInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageInfo)
                    return object;
                var message = new $root.api.PackageInfo();
                if (object.pkg != null) {
                    if (typeof object.pkg !== "object")
                        throw TypeError(".api.PackageInfo.pkg: object expected");
                    message.pkg = $root.api.Package.fromObject(object.pkg);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PackageInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageInfo
             * @static
             * @param {api.PackageInfo} message PackageInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.pkg = null;
                if (message.pkg != null && message.hasOwnProperty("pkg"))
                    object.pkg = $root.api.Package.toObject(message.pkg, options);
                return object;
            };
    
            /**
             * Converts this PackageInfo to JSON.
             * @function toJSON
             * @memberof api.PackageInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageInfo;
        })();
    
        api.PackageInfoResp = (function() {
    
            /**
             * Properties of a PackageInfoResp.
             * @memberof api
             * @interface IPackageInfoResp
             * @property {api.Package|api.IPackage|null} [pkg] PackageInfoResp pkg
             */
    
            /**
             * Constructs a new PackageInfoResp.
             * @memberof api
             * @classdesc Represents a PackageInfoResp.
             * @constructor
             * @param {api.IPackageInfoResp=} [properties] Properties to set
             */
            function PackageInfoResp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PackageInfoResp pkg.
             * @member {api.Package|null|undefined} pkg
             * @memberof api.PackageInfoResp
             * @instance
             */
            PackageInfoResp.prototype.pkg = null;
    
            /**
             * Creates a new PackageInfoResp instance using the specified properties.
             * @function create
             * @memberof api.PackageInfoResp
             * @static
             * @param {api.IPackageInfoResp=} [properties] Properties to set
             * @returns {api.PackageInfoResp} PackageInfoResp instance
             */
            PackageInfoResp.create = function create(properties) {
                return PackageInfoResp.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageInfoResp message. Does not implicitly {@link api.PackageInfoResp.verify|verify} messages.
             * @function encode
             * @memberof api.PackageInfoResp
             * @static
             * @param {api.PackageInfoResp} message PackageInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageInfoResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkg != null && Object.hasOwnProperty.call(message, "pkg"))
                    $root.api.Package.encode(message.pkg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PackageInfoResp message, length delimited. Does not implicitly {@link api.PackageInfoResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageInfoResp
             * @static
             * @param {api.PackageInfoResp} message PackageInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageInfoResp message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageInfoResp} PackageInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageInfoResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageInfoResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pkg = $root.api.Package.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageInfoResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageInfoResp} PackageInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageInfoResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageInfoResp message.
             * @function verify
             * @memberof api.PackageInfoResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageInfoResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkg != null && message.hasOwnProperty("pkg")) {
                    var error = $root.api.Package.verify(message.pkg);
                    if (error)
                        return "pkg." + error;
                }
                return null;
            };
    
            /**
             * Creates a PackageInfoResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageInfoResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageInfoResp} PackageInfoResp
             */
            PackageInfoResp.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageInfoResp)
                    return object;
                var message = new $root.api.PackageInfoResp();
                if (object.pkg != null) {
                    if (typeof object.pkg !== "object")
                        throw TypeError(".api.PackageInfoResp.pkg: object expected");
                    message.pkg = $root.api.Package.fromObject(object.pkg);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PackageInfoResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageInfoResp
             * @static
             * @param {api.PackageInfoResp} message PackageInfoResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageInfoResp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.pkg = null;
                if (message.pkg != null && message.hasOwnProperty("pkg"))
                    object.pkg = $root.api.Package.toObject(message.pkg, options);
                return object;
            };
    
            /**
             * Converts this PackageInfoResp to JSON.
             * @function toJSON
             * @memberof api.PackageInfoResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageInfoResp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageInfoResp;
        })();
    
        api.PackageAdd = (function() {
    
            /**
             * Properties of a PackageAdd.
             * @memberof api
             * @interface IPackageAdd
             * @property {Array.<api.Package|api.IPackage>|null} [pkgs] PackageAdd pkgs
             */
    
            /**
             * Constructs a new PackageAdd.
             * @memberof api
             * @classdesc Represents a PackageAdd.
             * @constructor
             * @param {api.IPackageAdd=} [properties] Properties to set
             */
            function PackageAdd(properties) {
                this.pkgs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PackageAdd pkgs.
             * @member {Array.<api.Package>} pkgs
             * @memberof api.PackageAdd
             * @instance
             */
            PackageAdd.prototype.pkgs = $util.emptyArray;
    
            /**
             * Creates a new PackageAdd instance using the specified properties.
             * @function create
             * @memberof api.PackageAdd
             * @static
             * @param {api.IPackageAdd=} [properties] Properties to set
             * @returns {api.PackageAdd} PackageAdd instance
             */
            PackageAdd.create = function create(properties) {
                return PackageAdd.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageAdd message. Does not implicitly {@link api.PackageAdd.verify|verify} messages.
             * @function encode
             * @memberof api.PackageAdd
             * @static
             * @param {api.PackageAdd} message PackageAdd message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageAdd.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkgs != null && message.pkgs.length)
                    for (var i = 0; i < message.pkgs.length; ++i)
                        $root.api.Package.encode(message.pkgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PackageAdd message, length delimited. Does not implicitly {@link api.PackageAdd.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageAdd
             * @static
             * @param {api.PackageAdd} message PackageAdd message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageAdd.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageAdd message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageAdd
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageAdd} PackageAdd
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageAdd.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageAdd();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.pkgs && message.pkgs.length))
                            message.pkgs = [];
                        message.pkgs.push($root.api.Package.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageAdd message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageAdd
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageAdd} PackageAdd
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageAdd.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageAdd message.
             * @function verify
             * @memberof api.PackageAdd
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageAdd.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkgs != null && message.hasOwnProperty("pkgs")) {
                    if (!Array.isArray(message.pkgs))
                        return "pkgs: array expected";
                    for (var i = 0; i < message.pkgs.length; ++i) {
                        var error = $root.api.Package.verify(message.pkgs[i]);
                        if (error)
                            return "pkgs." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a PackageAdd message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageAdd
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageAdd} PackageAdd
             */
            PackageAdd.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageAdd)
                    return object;
                var message = new $root.api.PackageAdd();
                if (object.pkgs) {
                    if (!Array.isArray(object.pkgs))
                        throw TypeError(".api.PackageAdd.pkgs: array expected");
                    message.pkgs = [];
                    for (var i = 0; i < object.pkgs.length; ++i) {
                        if (typeof object.pkgs[i] !== "object")
                            throw TypeError(".api.PackageAdd.pkgs: object expected");
                        message.pkgs[i] = $root.api.Package.fromObject(object.pkgs[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PackageAdd message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageAdd
             * @static
             * @param {api.PackageAdd} message PackageAdd
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageAdd.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pkgs = [];
                if (message.pkgs && message.pkgs.length) {
                    object.pkgs = [];
                    for (var j = 0; j < message.pkgs.length; ++j)
                        object.pkgs[j] = $root.api.Package.toObject(message.pkgs[j], options);
                }
                return object;
            };
    
            /**
             * Converts this PackageAdd to JSON.
             * @function toJSON
             * @memberof api.PackageAdd
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageAdd.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageAdd;
        })();
    
        api.PackageRemove = (function() {
    
            /**
             * Properties of a PackageRemove.
             * @memberof api
             * @interface IPackageRemove
             * @property {Array.<api.Package|api.IPackage>|null} [pkgs] PackageRemove pkgs
             */
    
            /**
             * Constructs a new PackageRemove.
             * @memberof api
             * @classdesc Represents a PackageRemove.
             * @constructor
             * @param {api.IPackageRemove=} [properties] Properties to set
             */
            function PackageRemove(properties) {
                this.pkgs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PackageRemove pkgs.
             * @member {Array.<api.Package>} pkgs
             * @memberof api.PackageRemove
             * @instance
             */
            PackageRemove.prototype.pkgs = $util.emptyArray;
    
            /**
             * Creates a new PackageRemove instance using the specified properties.
             * @function create
             * @memberof api.PackageRemove
             * @static
             * @param {api.IPackageRemove=} [properties] Properties to set
             * @returns {api.PackageRemove} PackageRemove instance
             */
            PackageRemove.create = function create(properties) {
                return PackageRemove.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageRemove message. Does not implicitly {@link api.PackageRemove.verify|verify} messages.
             * @function encode
             * @memberof api.PackageRemove
             * @static
             * @param {api.PackageRemove} message PackageRemove message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageRemove.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkgs != null && message.pkgs.length)
                    for (var i = 0; i < message.pkgs.length; ++i)
                        $root.api.Package.encode(message.pkgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PackageRemove message, length delimited. Does not implicitly {@link api.PackageRemove.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageRemove
             * @static
             * @param {api.PackageRemove} message PackageRemove message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageRemove.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageRemove message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageRemove
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageRemove} PackageRemove
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageRemove.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageRemove();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.pkgs && message.pkgs.length))
                            message.pkgs = [];
                        message.pkgs.push($root.api.Package.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageRemove message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageRemove
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageRemove} PackageRemove
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageRemove.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageRemove message.
             * @function verify
             * @memberof api.PackageRemove
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageRemove.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkgs != null && message.hasOwnProperty("pkgs")) {
                    if (!Array.isArray(message.pkgs))
                        return "pkgs: array expected";
                    for (var i = 0; i < message.pkgs.length; ++i) {
                        var error = $root.api.Package.verify(message.pkgs[i]);
                        if (error)
                            return "pkgs." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a PackageRemove message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageRemove
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageRemove} PackageRemove
             */
            PackageRemove.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageRemove)
                    return object;
                var message = new $root.api.PackageRemove();
                if (object.pkgs) {
                    if (!Array.isArray(object.pkgs))
                        throw TypeError(".api.PackageRemove.pkgs: array expected");
                    message.pkgs = [];
                    for (var i = 0; i < object.pkgs.length; ++i) {
                        if (typeof object.pkgs[i] !== "object")
                            throw TypeError(".api.PackageRemove.pkgs: object expected");
                        message.pkgs[i] = $root.api.Package.fromObject(object.pkgs[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PackageRemove message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageRemove
             * @static
             * @param {api.PackageRemove} message PackageRemove
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageRemove.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pkgs = [];
                if (message.pkgs && message.pkgs.length) {
                    object.pkgs = [];
                    for (var j = 0; j < message.pkgs.length; ++j)
                        object.pkgs[j] = $root.api.Package.toObject(message.pkgs[j], options);
                }
                return object;
            };
    
            /**
             * Converts this PackageRemove to JSON.
             * @function toJSON
             * @memberof api.PackageRemove
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageRemove.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageRemove;
        })();
    
        api.PackageInstall = (function() {
    
            /**
             * Properties of a PackageInstall.
             * @memberof api
             * @interface IPackageInstall
             */
    
            /**
             * Constructs a new PackageInstall.
             * @memberof api
             * @classdesc Represents a PackageInstall.
             * @constructor
             * @param {api.IPackageInstall=} [properties] Properties to set
             */
            function PackageInstall(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PackageInstall instance using the specified properties.
             * @function create
             * @memberof api.PackageInstall
             * @static
             * @param {api.IPackageInstall=} [properties] Properties to set
             * @returns {api.PackageInstall} PackageInstall instance
             */
            PackageInstall.create = function create(properties) {
                return PackageInstall.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageInstall message. Does not implicitly {@link api.PackageInstall.verify|verify} messages.
             * @function encode
             * @memberof api.PackageInstall
             * @static
             * @param {api.PackageInstall} message PackageInstall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageInstall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified PackageInstall message, length delimited. Does not implicitly {@link api.PackageInstall.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageInstall
             * @static
             * @param {api.PackageInstall} message PackageInstall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageInstall.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageInstall message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageInstall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageInstall} PackageInstall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageInstall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageInstall();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageInstall message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageInstall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageInstall} PackageInstall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageInstall.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageInstall message.
             * @function verify
             * @memberof api.PackageInstall
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageInstall.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a PackageInstall message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageInstall
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageInstall} PackageInstall
             */
            PackageInstall.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageInstall)
                    return object;
                return new $root.api.PackageInstall();
            };
    
            /**
             * Creates a plain object from a PackageInstall message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageInstall
             * @static
             * @param {api.PackageInstall} message PackageInstall
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageInstall.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this PackageInstall to JSON.
             * @function toJSON
             * @memberof api.PackageInstall
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageInstall.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageInstall;
        })();
    
        api.PackageListSpecfile = (function() {
    
            /**
             * Properties of a PackageListSpecfile.
             * @memberof api
             * @interface IPackageListSpecfile
             */
    
            /**
             * Constructs a new PackageListSpecfile.
             * @memberof api
             * @classdesc Represents a PackageListSpecfile.
             * @constructor
             * @param {api.IPackageListSpecfile=} [properties] Properties to set
             */
            function PackageListSpecfile(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PackageListSpecfile instance using the specified properties.
             * @function create
             * @memberof api.PackageListSpecfile
             * @static
             * @param {api.IPackageListSpecfile=} [properties] Properties to set
             * @returns {api.PackageListSpecfile} PackageListSpecfile instance
             */
            PackageListSpecfile.create = function create(properties) {
                return PackageListSpecfile.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageListSpecfile message. Does not implicitly {@link api.PackageListSpecfile.verify|verify} messages.
             * @function encode
             * @memberof api.PackageListSpecfile
             * @static
             * @param {api.PackageListSpecfile} message PackageListSpecfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageListSpecfile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified PackageListSpecfile message, length delimited. Does not implicitly {@link api.PackageListSpecfile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageListSpecfile
             * @static
             * @param {api.PackageListSpecfile} message PackageListSpecfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageListSpecfile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageListSpecfile message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageListSpecfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageListSpecfile} PackageListSpecfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageListSpecfile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageListSpecfile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageListSpecfile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageListSpecfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageListSpecfile} PackageListSpecfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageListSpecfile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageListSpecfile message.
             * @function verify
             * @memberof api.PackageListSpecfile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageListSpecfile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a PackageListSpecfile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageListSpecfile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageListSpecfile} PackageListSpecfile
             */
            PackageListSpecfile.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageListSpecfile)
                    return object;
                return new $root.api.PackageListSpecfile();
            };
    
            /**
             * Creates a plain object from a PackageListSpecfile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageListSpecfile
             * @static
             * @param {api.PackageListSpecfile} message PackageListSpecfile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageListSpecfile.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this PackageListSpecfile to JSON.
             * @function toJSON
             * @memberof api.PackageListSpecfile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageListSpecfile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageListSpecfile;
        })();
    
        api.PackageListSpecfileResp = (function() {
    
            /**
             * Properties of a PackageListSpecfileResp.
             * @memberof api
             * @interface IPackageListSpecfileResp
             * @property {Array.<api.Package|api.IPackage>|null} [pkgs] PackageListSpecfileResp pkgs
             */
    
            /**
             * Constructs a new PackageListSpecfileResp.
             * @memberof api
             * @classdesc Represents a PackageListSpecfileResp.
             * @constructor
             * @param {api.IPackageListSpecfileResp=} [properties] Properties to set
             */
            function PackageListSpecfileResp(properties) {
                this.pkgs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PackageListSpecfileResp pkgs.
             * @member {Array.<api.Package>} pkgs
             * @memberof api.PackageListSpecfileResp
             * @instance
             */
            PackageListSpecfileResp.prototype.pkgs = $util.emptyArray;
    
            /**
             * Creates a new PackageListSpecfileResp instance using the specified properties.
             * @function create
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {api.IPackageListSpecfileResp=} [properties] Properties to set
             * @returns {api.PackageListSpecfileResp} PackageListSpecfileResp instance
             */
            PackageListSpecfileResp.create = function create(properties) {
                return PackageListSpecfileResp.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageListSpecfileResp message. Does not implicitly {@link api.PackageListSpecfileResp.verify|verify} messages.
             * @function encode
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {api.PackageListSpecfileResp} message PackageListSpecfileResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageListSpecfileResp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkgs != null && message.pkgs.length)
                    for (var i = 0; i < message.pkgs.length; ++i)
                        $root.api.Package.encode(message.pkgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PackageListSpecfileResp message, length delimited. Does not implicitly {@link api.PackageListSpecfileResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {api.PackageListSpecfileResp} message PackageListSpecfileResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageListSpecfileResp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageListSpecfileResp message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageListSpecfileResp} PackageListSpecfileResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageListSpecfileResp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageListSpecfileResp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.pkgs && message.pkgs.length))
                            message.pkgs = [];
                        message.pkgs.push($root.api.Package.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageListSpecfileResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageListSpecfileResp} PackageListSpecfileResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageListSpecfileResp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageListSpecfileResp message.
             * @function verify
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageListSpecfileResp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkgs != null && message.hasOwnProperty("pkgs")) {
                    if (!Array.isArray(message.pkgs))
                        return "pkgs: array expected";
                    for (var i = 0; i < message.pkgs.length; ++i) {
                        var error = $root.api.Package.verify(message.pkgs[i]);
                        if (error)
                            return "pkgs." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a PackageListSpecfileResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageListSpecfileResp} PackageListSpecfileResp
             */
            PackageListSpecfileResp.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageListSpecfileResp)
                    return object;
                var message = new $root.api.PackageListSpecfileResp();
                if (object.pkgs) {
                    if (!Array.isArray(object.pkgs))
                        throw TypeError(".api.PackageListSpecfileResp.pkgs: array expected");
                    message.pkgs = [];
                    for (var i = 0; i < object.pkgs.length; ++i) {
                        if (typeof object.pkgs[i] !== "object")
                            throw TypeError(".api.PackageListSpecfileResp.pkgs: object expected");
                        message.pkgs[i] = $root.api.Package.fromObject(object.pkgs[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PackageListSpecfileResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageListSpecfileResp
             * @static
             * @param {api.PackageListSpecfileResp} message PackageListSpecfileResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageListSpecfileResp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pkgs = [];
                if (message.pkgs && message.pkgs.length) {
                    object.pkgs = [];
                    for (var j = 0; j < message.pkgs.length; ++j)
                        object.pkgs[j] = $root.api.Package.toObject(message.pkgs[j], options);
                }
                return object;
            };
    
            /**
             * Converts this PackageListSpecfileResp to JSON.
             * @function toJSON
             * @memberof api.PackageListSpecfileResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageListSpecfileResp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageListSpecfileResp;
        })();
    
        api.PackageCacheSave = (function() {
    
            /**
             * Properties of a PackageCacheSave.
             * @memberof api
             * @interface IPackageCacheSave
             */
    
            /**
             * Constructs a new PackageCacheSave.
             * @memberof api
             * @classdesc Represents a PackageCacheSave.
             * @constructor
             * @param {api.IPackageCacheSave=} [properties] Properties to set
             */
            function PackageCacheSave(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PackageCacheSave instance using the specified properties.
             * @function create
             * @memberof api.PackageCacheSave
             * @static
             * @param {api.IPackageCacheSave=} [properties] Properties to set
             * @returns {api.PackageCacheSave} PackageCacheSave instance
             */
            PackageCacheSave.create = function create(properties) {
                return PackageCacheSave.fromObject(properties);
            };
    
            /**
             * Encodes the specified PackageCacheSave message. Does not implicitly {@link api.PackageCacheSave.verify|verify} messages.
             * @function encode
             * @memberof api.PackageCacheSave
             * @static
             * @param {api.PackageCacheSave} message PackageCacheSave message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageCacheSave.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified PackageCacheSave message, length delimited. Does not implicitly {@link api.PackageCacheSave.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PackageCacheSave
             * @static
             * @param {api.PackageCacheSave} message PackageCacheSave message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PackageCacheSave.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PackageCacheSave message from the specified reader or buffer.
             * @function decode
             * @memberof api.PackageCacheSave
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PackageCacheSave} PackageCacheSave
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageCacheSave.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PackageCacheSave();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PackageCacheSave message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PackageCacheSave
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PackageCacheSave} PackageCacheSave
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PackageCacheSave.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PackageCacheSave message.
             * @function verify
             * @memberof api.PackageCacheSave
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PackageCacheSave.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a PackageCacheSave message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PackageCacheSave
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PackageCacheSave} PackageCacheSave
             */
            PackageCacheSave.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PackageCacheSave)
                    return object;
                return new $root.api.PackageCacheSave();
            };
    
            /**
             * Creates a plain object from a PackageCacheSave message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PackageCacheSave
             * @static
             * @param {api.PackageCacheSave} message PackageCacheSave
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PackageCacheSave.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this PackageCacheSave to JSON.
             * @function toJSON
             * @memberof api.PackageCacheSave
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PackageCacheSave.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PackageCacheSave;
        })();
    
        api.ChatScrollback = (function() {
    
            /**
             * Properties of a ChatScrollback.
             * @memberof api
             * @interface IChatScrollback
             * @property {Array.<api.ChatMessage|api.IChatMessage>|null} [scrollback] ChatScrollback scrollback
             */
    
            /**
             * Constructs a new ChatScrollback.
             * @memberof api
             * @classdesc Represents a ChatScrollback.
             * @constructor
             * @param {api.IChatScrollback=} [properties] Properties to set
             */
            function ChatScrollback(properties) {
                this.scrollback = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChatScrollback scrollback.
             * @member {Array.<api.ChatMessage>} scrollback
             * @memberof api.ChatScrollback
             * @instance
             */
            ChatScrollback.prototype.scrollback = $util.emptyArray;
    
            /**
             * Creates a new ChatScrollback instance using the specified properties.
             * @function create
             * @memberof api.ChatScrollback
             * @static
             * @param {api.IChatScrollback=} [properties] Properties to set
             * @returns {api.ChatScrollback} ChatScrollback instance
             */
            ChatScrollback.create = function create(properties) {
                return ChatScrollback.fromObject(properties);
            };
    
            /**
             * Encodes the specified ChatScrollback message. Does not implicitly {@link api.ChatScrollback.verify|verify} messages.
             * @function encode
             * @memberof api.ChatScrollback
             * @static
             * @param {api.ChatScrollback} message ChatScrollback message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatScrollback.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scrollback != null && message.scrollback.length)
                    for (var i = 0; i < message.scrollback.length; ++i)
                        $root.api.ChatMessage.encode(message.scrollback[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChatScrollback message, length delimited. Does not implicitly {@link api.ChatScrollback.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ChatScrollback
             * @static
             * @param {api.ChatScrollback} message ChatScrollback message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChatScrollback.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChatScrollback message from the specified reader or buffer.
             * @function decode
             * @memberof api.ChatScrollback
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ChatScrollback} ChatScrollback
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatScrollback.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ChatScrollback();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.scrollback && message.scrollback.length))
                            message.scrollback = [];
                        message.scrollback.push($root.api.ChatMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChatScrollback message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ChatScrollback
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ChatScrollback} ChatScrollback
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChatScrollback.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChatScrollback message.
             * @function verify
             * @memberof api.ChatScrollback
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChatScrollback.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scrollback != null && message.hasOwnProperty("scrollback")) {
                    if (!Array.isArray(message.scrollback))
                        return "scrollback: array expected";
                    for (var i = 0; i < message.scrollback.length; ++i) {
                        var error = $root.api.ChatMessage.verify(message.scrollback[i]);
                        if (error)
                            return "scrollback." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChatScrollback message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ChatScrollback
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ChatScrollback} ChatScrollback
             */
            ChatScrollback.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ChatScrollback)
                    return object;
                var message = new $root.api.ChatScrollback();
                if (object.scrollback) {
                    if (!Array.isArray(object.scrollback))
                        throw TypeError(".api.ChatScrollback.scrollback: array expected");
                    message.scrollback = [];
                    for (var i = 0; i < object.scrollback.length; ++i) {
                        if (typeof object.scrollback[i] !== "object")
                            throw TypeError(".api.ChatScrollback.scrollback: object expected");
                        message.scrollback[i] = $root.api.ChatMessage.fromObject(object.scrollback[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChatScrollback message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ChatScrollback
             * @static
             * @param {api.ChatScrollback} message ChatScrollback
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChatScrollback.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.scrollback = [];
                if (message.scrollback && message.scrollback.length) {
                    object.scrollback = [];
                    for (var j = 0; j < message.scrollback.length; ++j)
                        object.scrollback[j] = $root.api.ChatMessage.toObject(message.scrollback[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChatScrollback to JSON.
             * @function toJSON
             * @memberof api.ChatScrollback
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChatScrollback.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChatScrollback;
        })();
    
        api.Metrics = (function() {
    
            /**
             * Properties of a Metrics.
             * @memberof api
             * @interface IMetrics
             * @property {Array.<Uint8Array>|null} [prometheusMetricFamilies] Metrics prometheusMetricFamilies
             */
    
            /**
             * Constructs a new Metrics.
             * @memberof api
             * @classdesc Represents a Metrics.
             * @constructor
             * @param {api.IMetrics=} [properties] Properties to set
             */
            function Metrics(properties) {
                this.prometheusMetricFamilies = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Metrics prometheusMetricFamilies.
             * @member {Array.<Uint8Array>} prometheusMetricFamilies
             * @memberof api.Metrics
             * @instance
             */
            Metrics.prototype.prometheusMetricFamilies = $util.emptyArray;
    
            /**
             * Creates a new Metrics instance using the specified properties.
             * @function create
             * @memberof api.Metrics
             * @static
             * @param {api.IMetrics=} [properties] Properties to set
             * @returns {api.Metrics} Metrics instance
             */
            Metrics.create = function create(properties) {
                return Metrics.fromObject(properties);
            };
    
            /**
             * Encodes the specified Metrics message. Does not implicitly {@link api.Metrics.verify|verify} messages.
             * @function encode
             * @memberof api.Metrics
             * @static
             * @param {api.Metrics} message Metrics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Metrics.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prometheusMetricFamilies != null && message.prometheusMetricFamilies.length)
                    for (var i = 0; i < message.prometheusMetricFamilies.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.prometheusMetricFamilies[i]);
                return writer;
            };
    
            /**
             * Encodes the specified Metrics message, length delimited. Does not implicitly {@link api.Metrics.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Metrics
             * @static
             * @param {api.Metrics} message Metrics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Metrics.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Metrics message from the specified reader or buffer.
             * @function decode
             * @memberof api.Metrics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Metrics} Metrics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Metrics.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Metrics();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.prometheusMetricFamilies && message.prometheusMetricFamilies.length))
                            message.prometheusMetricFamilies = [];
                        message.prometheusMetricFamilies.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Metrics message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Metrics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Metrics} Metrics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Metrics.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Metrics message.
             * @function verify
             * @memberof api.Metrics
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Metrics.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prometheusMetricFamilies != null && message.hasOwnProperty("prometheusMetricFamilies")) {
                    if (!Array.isArray(message.prometheusMetricFamilies))
                        return "prometheusMetricFamilies: array expected";
                    for (var i = 0; i < message.prometheusMetricFamilies.length; ++i)
                        if (!(message.prometheusMetricFamilies[i] && typeof message.prometheusMetricFamilies[i].length === "number" || $util.isString(message.prometheusMetricFamilies[i])))
                            return "prometheusMetricFamilies: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Metrics
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Metrics} Metrics
             */
            Metrics.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Metrics)
                    return object;
                var message = new $root.api.Metrics();
                if (object.prometheusMetricFamilies) {
                    if (!Array.isArray(object.prometheusMetricFamilies))
                        throw TypeError(".api.Metrics.prometheusMetricFamilies: array expected");
                    message.prometheusMetricFamilies = [];
                    for (var i = 0; i < object.prometheusMetricFamilies.length; ++i)
                        if (typeof object.prometheusMetricFamilies[i] === "string")
                            $util.base64.decode(object.prometheusMetricFamilies[i], message.prometheusMetricFamilies[i] = $util.newBuffer($util.base64.length(object.prometheusMetricFamilies[i])), 0);
                        else if (object.prometheusMetricFamilies[i].length)
                            message.prometheusMetricFamilies[i] = object.prometheusMetricFamilies[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Metrics message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Metrics
             * @static
             * @param {api.Metrics} message Metrics
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Metrics.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.prometheusMetricFamilies = [];
                if (message.prometheusMetricFamilies && message.prometheusMetricFamilies.length) {
                    object.prometheusMetricFamilies = [];
                    for (var j = 0; j < message.prometheusMetricFamilies.length; ++j)
                        object.prometheusMetricFamilies[j] = options.bytes === String ? $util.base64.encode(message.prometheusMetricFamilies[j], 0, message.prometheusMetricFamilies[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.prometheusMetricFamilies[j]) : message.prometheusMetricFamilies[j];
                }
                return object;
            };
    
            /**
             * Converts this Metrics to JSON.
             * @function toJSON
             * @memberof api.Metrics
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Metrics.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Metrics;
        })();
    
        api.PprofRequest = (function() {
    
            /**
             * Properties of a PprofRequest.
             * @memberof api
             * @interface IPprofRequest
             * @property {string|null} [id] PprofRequest id
             * @property {api.PprofCpuProfileRequest|api.IPprofCpuProfileRequest|null} [pprofCpuProfileRequest] PprofRequest pprofCpuProfileRequest
             * @property {api.PprofHeapProfileRequest|api.IPprofHeapProfileRequest|null} [pprofHeapProfileRequest] PprofRequest pprofHeapProfileRequest
             * @property {api.PprofAllocsProfileRequest|api.IPprofAllocsProfileRequest|null} [pprofAllocsProfileRequest] PprofRequest pprofAllocsProfileRequest
             * @property {api.PprofBlockProfileRequest|api.IPprofBlockProfileRequest|null} [pprofBlockProfileRequest] PprofRequest pprofBlockProfileRequest
             * @property {api.PprofMutexProfileRequest|api.IPprofMutexProfileRequest|null} [pprofMutexProfileRequest] PprofRequest pprofMutexProfileRequest
             */
    
            /**
             * Constructs a new PprofRequest.
             * @memberof api
             * @classdesc Represents a PprofRequest.
             * @constructor
             * @param {api.IPprofRequest=} [properties] Properties to set
             */
            function PprofRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PprofRequest id.
             * @member {string} id
             * @memberof api.PprofRequest
             * @instance
             */
            PprofRequest.prototype.id = "";
    
            /**
             * PprofRequest pprofCpuProfileRequest.
             * @member {api.PprofCpuProfileRequest|null|undefined} pprofCpuProfileRequest
             * @memberof api.PprofRequest
             * @instance
             */
            PprofRequest.prototype.pprofCpuProfileRequest = null;
    
            /**
             * PprofRequest pprofHeapProfileRequest.
             * @member {api.PprofHeapProfileRequest|null|undefined} pprofHeapProfileRequest
             * @memberof api.PprofRequest
             * @instance
             */
            PprofRequest.prototype.pprofHeapProfileRequest = null;
    
            /**
             * PprofRequest pprofAllocsProfileRequest.
             * @member {api.PprofAllocsProfileRequest|null|undefined} pprofAllocsProfileRequest
             * @memberof api.PprofRequest
             * @instance
             */
            PprofRequest.prototype.pprofAllocsProfileRequest = null;
    
            /**
             * PprofRequest pprofBlockProfileRequest.
             * @member {api.PprofBlockProfileRequest|null|undefined} pprofBlockProfileRequest
             * @memberof api.PprofRequest
             * @instance
             */
            PprofRequest.prototype.pprofBlockProfileRequest = null;
    
            /**
             * PprofRequest pprofMutexProfileRequest.
             * @member {api.PprofMutexProfileRequest|null|undefined} pprofMutexProfileRequest
             * @memberof api.PprofRequest
             * @instance
             */
            PprofRequest.prototype.pprofMutexProfileRequest = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * PprofRequest body.
             * @member {"pprofCpuProfileRequest"|"pprofHeapProfileRequest"|"pprofAllocsProfileRequest"|"pprofBlockProfileRequest"|"pprofMutexProfileRequest"|undefined} body
             * @memberof api.PprofRequest
             * @instance
             */
            Object.defineProperty(PprofRequest.prototype, "body", {
                get: $util.oneOfGetter($oneOfFields = ["pprofCpuProfileRequest", "pprofHeapProfileRequest", "pprofAllocsProfileRequest", "pprofBlockProfileRequest", "pprofMutexProfileRequest"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new PprofRequest instance using the specified properties.
             * @function create
             * @memberof api.PprofRequest
             * @static
             * @param {api.IPprofRequest=} [properties] Properties to set
             * @returns {api.PprofRequest} PprofRequest instance
             */
            PprofRequest.create = function create(properties) {
                return PprofRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified PprofRequest message. Does not implicitly {@link api.PprofRequest.verify|verify} messages.
             * @function encode
             * @memberof api.PprofRequest
             * @static
             * @param {api.PprofRequest} message PprofRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.pprofCpuProfileRequest != null && Object.hasOwnProperty.call(message, "pprofCpuProfileRequest"))
                    $root.api.PprofCpuProfileRequest.encode(message.pprofCpuProfileRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.pprofHeapProfileRequest != null && Object.hasOwnProperty.call(message, "pprofHeapProfileRequest"))
                    $root.api.PprofHeapProfileRequest.encode(message.pprofHeapProfileRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.pprofAllocsProfileRequest != null && Object.hasOwnProperty.call(message, "pprofAllocsProfileRequest"))
                    $root.api.PprofAllocsProfileRequest.encode(message.pprofAllocsProfileRequest, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.pprofBlockProfileRequest != null && Object.hasOwnProperty.call(message, "pprofBlockProfileRequest"))
                    $root.api.PprofBlockProfileRequest.encode(message.pprofBlockProfileRequest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.pprofMutexProfileRequest != null && Object.hasOwnProperty.call(message, "pprofMutexProfileRequest"))
                    $root.api.PprofMutexProfileRequest.encode(message.pprofMutexProfileRequest, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PprofRequest message, length delimited. Does not implicitly {@link api.PprofRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PprofRequest
             * @static
             * @param {api.PprofRequest} message PprofRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PprofRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.PprofRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PprofRequest} PprofRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PprofRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.pprofCpuProfileRequest = $root.api.PprofCpuProfileRequest.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.pprofHeapProfileRequest = $root.api.PprofHeapProfileRequest.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.pprofAllocsProfileRequest = $root.api.PprofAllocsProfileRequest.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.pprofBlockProfileRequest = $root.api.PprofBlockProfileRequest.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.pprofMutexProfileRequest = $root.api.PprofMutexProfileRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PprofRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PprofRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PprofRequest} PprofRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PprofRequest message.
             * @function verify
             * @memberof api.PprofRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PprofRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.pprofCpuProfileRequest != null && message.hasOwnProperty("pprofCpuProfileRequest")) {
                    properties.body = 1;
                    {
                        var error = $root.api.PprofCpuProfileRequest.verify(message.pprofCpuProfileRequest);
                        if (error)
                            return "pprofCpuProfileRequest." + error;
                    }
                }
                if (message.pprofHeapProfileRequest != null && message.hasOwnProperty("pprofHeapProfileRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PprofHeapProfileRequest.verify(message.pprofHeapProfileRequest);
                        if (error)
                            return "pprofHeapProfileRequest." + error;
                    }
                }
                if (message.pprofAllocsProfileRequest != null && message.hasOwnProperty("pprofAllocsProfileRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PprofAllocsProfileRequest.verify(message.pprofAllocsProfileRequest);
                        if (error)
                            return "pprofAllocsProfileRequest." + error;
                    }
                }
                if (message.pprofBlockProfileRequest != null && message.hasOwnProperty("pprofBlockProfileRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PprofBlockProfileRequest.verify(message.pprofBlockProfileRequest);
                        if (error)
                            return "pprofBlockProfileRequest." + error;
                    }
                }
                if (message.pprofMutexProfileRequest != null && message.hasOwnProperty("pprofMutexProfileRequest")) {
                    if (properties.body === 1)
                        return "body: multiple values";
                    properties.body = 1;
                    {
                        var error = $root.api.PprofMutexProfileRequest.verify(message.pprofMutexProfileRequest);
                        if (error)
                            return "pprofMutexProfileRequest." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a PprofRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PprofRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PprofRequest} PprofRequest
             */
            PprofRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PprofRequest)
                    return object;
                var message = new $root.api.PprofRequest();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.pprofCpuProfileRequest != null) {
                    if (typeof object.pprofCpuProfileRequest !== "object")
                        throw TypeError(".api.PprofRequest.pprofCpuProfileRequest: object expected");
                    message.pprofCpuProfileRequest = $root.api.PprofCpuProfileRequest.fromObject(object.pprofCpuProfileRequest);
                }
                if (object.pprofHeapProfileRequest != null) {
                    if (typeof object.pprofHeapProfileRequest !== "object")
                        throw TypeError(".api.PprofRequest.pprofHeapProfileRequest: object expected");
                    message.pprofHeapProfileRequest = $root.api.PprofHeapProfileRequest.fromObject(object.pprofHeapProfileRequest);
                }
                if (object.pprofAllocsProfileRequest != null) {
                    if (typeof object.pprofAllocsProfileRequest !== "object")
                        throw TypeError(".api.PprofRequest.pprofAllocsProfileRequest: object expected");
                    message.pprofAllocsProfileRequest = $root.api.PprofAllocsProfileRequest.fromObject(object.pprofAllocsProfileRequest);
                }
                if (object.pprofBlockProfileRequest != null) {
                    if (typeof object.pprofBlockProfileRequest !== "object")
                        throw TypeError(".api.PprofRequest.pprofBlockProfileRequest: object expected");
                    message.pprofBlockProfileRequest = $root.api.PprofBlockProfileRequest.fromObject(object.pprofBlockProfileRequest);
                }
                if (object.pprofMutexProfileRequest != null) {
                    if (typeof object.pprofMutexProfileRequest !== "object")
                        throw TypeError(".api.PprofRequest.pprofMutexProfileRequest: object expected");
                    message.pprofMutexProfileRequest = $root.api.PprofMutexProfileRequest.fromObject(object.pprofMutexProfileRequest);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PprofRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PprofRequest
             * @static
             * @param {api.PprofRequest} message PprofRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PprofRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.pprofCpuProfileRequest != null && message.hasOwnProperty("pprofCpuProfileRequest")) {
                    object.pprofCpuProfileRequest = $root.api.PprofCpuProfileRequest.toObject(message.pprofCpuProfileRequest, options);
                    if (options.oneofs)
                        object.body = "pprofCpuProfileRequest";
                }
                if (message.pprofHeapProfileRequest != null && message.hasOwnProperty("pprofHeapProfileRequest")) {
                    object.pprofHeapProfileRequest = $root.api.PprofHeapProfileRequest.toObject(message.pprofHeapProfileRequest, options);
                    if (options.oneofs)
                        object.body = "pprofHeapProfileRequest";
                }
                if (message.pprofAllocsProfileRequest != null && message.hasOwnProperty("pprofAllocsProfileRequest")) {
                    object.pprofAllocsProfileRequest = $root.api.PprofAllocsProfileRequest.toObject(message.pprofAllocsProfileRequest, options);
                    if (options.oneofs)
                        object.body = "pprofAllocsProfileRequest";
                }
                if (message.pprofBlockProfileRequest != null && message.hasOwnProperty("pprofBlockProfileRequest")) {
                    object.pprofBlockProfileRequest = $root.api.PprofBlockProfileRequest.toObject(message.pprofBlockProfileRequest, options);
                    if (options.oneofs)
                        object.body = "pprofBlockProfileRequest";
                }
                if (message.pprofMutexProfileRequest != null && message.hasOwnProperty("pprofMutexProfileRequest")) {
                    object.pprofMutexProfileRequest = $root.api.PprofMutexProfileRequest.toObject(message.pprofMutexProfileRequest, options);
                    if (options.oneofs)
                        object.body = "pprofMutexProfileRequest";
                }
                return object;
            };
    
            /**
             * Converts this PprofRequest to JSON.
             * @function toJSON
             * @memberof api.PprofRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PprofRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PprofRequest;
        })();
    
        api.PprofAllocsProfileRequest = (function() {
    
            /**
             * Properties of a PprofAllocsProfileRequest.
             * @memberof api
             * @interface IPprofAllocsProfileRequest
             * @property {boolean|null} [debug] PprofAllocsProfileRequest debug
             */
    
            /**
             * Constructs a new PprofAllocsProfileRequest.
             * @memberof api
             * @classdesc Represents a PprofAllocsProfileRequest.
             * @constructor
             * @param {api.IPprofAllocsProfileRequest=} [properties] Properties to set
             */
            function PprofAllocsProfileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PprofAllocsProfileRequest debug.
             * @member {boolean} debug
             * @memberof api.PprofAllocsProfileRequest
             * @instance
             */
            PprofAllocsProfileRequest.prototype.debug = false;
    
            /**
             * Creates a new PprofAllocsProfileRequest instance using the specified properties.
             * @function create
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {api.IPprofAllocsProfileRequest=} [properties] Properties to set
             * @returns {api.PprofAllocsProfileRequest} PprofAllocsProfileRequest instance
             */
            PprofAllocsProfileRequest.create = function create(properties) {
                return PprofAllocsProfileRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified PprofAllocsProfileRequest message. Does not implicitly {@link api.PprofAllocsProfileRequest.verify|verify} messages.
             * @function encode
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {api.PprofAllocsProfileRequest} message PprofAllocsProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofAllocsProfileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.debug);
                return writer;
            };
    
            /**
             * Encodes the specified PprofAllocsProfileRequest message, length delimited. Does not implicitly {@link api.PprofAllocsProfileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {api.PprofAllocsProfileRequest} message PprofAllocsProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofAllocsProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PprofAllocsProfileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PprofAllocsProfileRequest} PprofAllocsProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofAllocsProfileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PprofAllocsProfileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.debug = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PprofAllocsProfileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PprofAllocsProfileRequest} PprofAllocsProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofAllocsProfileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PprofAllocsProfileRequest message.
             * @function verify
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PprofAllocsProfileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                return null;
            };
    
            /**
             * Creates a PprofAllocsProfileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PprofAllocsProfileRequest} PprofAllocsProfileRequest
             */
            PprofAllocsProfileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PprofAllocsProfileRequest)
                    return object;
                var message = new $root.api.PprofAllocsProfileRequest();
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                return message;
            };
    
            /**
             * Creates a plain object from a PprofAllocsProfileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PprofAllocsProfileRequest
             * @static
             * @param {api.PprofAllocsProfileRequest} message PprofAllocsProfileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PprofAllocsProfileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.debug = false;
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                return object;
            };
    
            /**
             * Converts this PprofAllocsProfileRequest to JSON.
             * @function toJSON
             * @memberof api.PprofAllocsProfileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PprofAllocsProfileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PprofAllocsProfileRequest;
        })();
    
        api.PprofBlockProfileRequest = (function() {
    
            /**
             * Properties of a PprofBlockProfileRequest.
             * @memberof api
             * @interface IPprofBlockProfileRequest
             * @property {boolean|null} [debug] PprofBlockProfileRequest debug
             */
    
            /**
             * Constructs a new PprofBlockProfileRequest.
             * @memberof api
             * @classdesc Represents a PprofBlockProfileRequest.
             * @constructor
             * @param {api.IPprofBlockProfileRequest=} [properties] Properties to set
             */
            function PprofBlockProfileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PprofBlockProfileRequest debug.
             * @member {boolean} debug
             * @memberof api.PprofBlockProfileRequest
             * @instance
             */
            PprofBlockProfileRequest.prototype.debug = false;
    
            /**
             * Creates a new PprofBlockProfileRequest instance using the specified properties.
             * @function create
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {api.IPprofBlockProfileRequest=} [properties] Properties to set
             * @returns {api.PprofBlockProfileRequest} PprofBlockProfileRequest instance
             */
            PprofBlockProfileRequest.create = function create(properties) {
                return PprofBlockProfileRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified PprofBlockProfileRequest message. Does not implicitly {@link api.PprofBlockProfileRequest.verify|verify} messages.
             * @function encode
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {api.PprofBlockProfileRequest} message PprofBlockProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofBlockProfileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.debug);
                return writer;
            };
    
            /**
             * Encodes the specified PprofBlockProfileRequest message, length delimited. Does not implicitly {@link api.PprofBlockProfileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {api.PprofBlockProfileRequest} message PprofBlockProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofBlockProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PprofBlockProfileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PprofBlockProfileRequest} PprofBlockProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofBlockProfileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PprofBlockProfileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.debug = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PprofBlockProfileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PprofBlockProfileRequest} PprofBlockProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofBlockProfileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PprofBlockProfileRequest message.
             * @function verify
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PprofBlockProfileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                return null;
            };
    
            /**
             * Creates a PprofBlockProfileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PprofBlockProfileRequest} PprofBlockProfileRequest
             */
            PprofBlockProfileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PprofBlockProfileRequest)
                    return object;
                var message = new $root.api.PprofBlockProfileRequest();
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                return message;
            };
    
            /**
             * Creates a plain object from a PprofBlockProfileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PprofBlockProfileRequest
             * @static
             * @param {api.PprofBlockProfileRequest} message PprofBlockProfileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PprofBlockProfileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.debug = false;
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                return object;
            };
    
            /**
             * Converts this PprofBlockProfileRequest to JSON.
             * @function toJSON
             * @memberof api.PprofBlockProfileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PprofBlockProfileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PprofBlockProfileRequest;
        })();
    
        api.PprofCpuProfileRequest = (function() {
    
            /**
             * Properties of a PprofCpuProfileRequest.
             * @memberof api
             * @interface IPprofCpuProfileRequest
             * @property {number|null} [seconds] PprofCpuProfileRequest seconds
             */
    
            /**
             * Constructs a new PprofCpuProfileRequest.
             * @memberof api
             * @classdesc Represents a PprofCpuProfileRequest.
             * @constructor
             * @param {api.IPprofCpuProfileRequest=} [properties] Properties to set
             */
            function PprofCpuProfileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PprofCpuProfileRequest seconds.
             * @member {number} seconds
             * @memberof api.PprofCpuProfileRequest
             * @instance
             */
            PprofCpuProfileRequest.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new PprofCpuProfileRequest instance using the specified properties.
             * @function create
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {api.IPprofCpuProfileRequest=} [properties] Properties to set
             * @returns {api.PprofCpuProfileRequest} PprofCpuProfileRequest instance
             */
            PprofCpuProfileRequest.create = function create(properties) {
                return PprofCpuProfileRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified PprofCpuProfileRequest message. Does not implicitly {@link api.PprofCpuProfileRequest.verify|verify} messages.
             * @function encode
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {api.PprofCpuProfileRequest} message PprofCpuProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofCpuProfileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                return writer;
            };
    
            /**
             * Encodes the specified PprofCpuProfileRequest message, length delimited. Does not implicitly {@link api.PprofCpuProfileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {api.PprofCpuProfileRequest} message PprofCpuProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofCpuProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PprofCpuProfileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PprofCpuProfileRequest} PprofCpuProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofCpuProfileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PprofCpuProfileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PprofCpuProfileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PprofCpuProfileRequest} PprofCpuProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofCpuProfileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PprofCpuProfileRequest message.
             * @function verify
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PprofCpuProfileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a PprofCpuProfileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PprofCpuProfileRequest} PprofCpuProfileRequest
             */
            PprofCpuProfileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PprofCpuProfileRequest)
                    return object;
                var message = new $root.api.PprofCpuProfileRequest();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a PprofCpuProfileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PprofCpuProfileRequest
             * @static
             * @param {api.PprofCpuProfileRequest} message PprofCpuProfileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PprofCpuProfileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                return object;
            };
    
            /**
             * Converts this PprofCpuProfileRequest to JSON.
             * @function toJSON
             * @memberof api.PprofCpuProfileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PprofCpuProfileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PprofCpuProfileRequest;
        })();
    
        api.PprofHeapProfileRequest = (function() {
    
            /**
             * Properties of a PprofHeapProfileRequest.
             * @memberof api
             * @interface IPprofHeapProfileRequest
             * @property {boolean|null} [gc] PprofHeapProfileRequest gc
             * @property {boolean|null} [debug] PprofHeapProfileRequest debug
             */
    
            /**
             * Constructs a new PprofHeapProfileRequest.
             * @memberof api
             * @classdesc Represents a PprofHeapProfileRequest.
             * @constructor
             * @param {api.IPprofHeapProfileRequest=} [properties] Properties to set
             */
            function PprofHeapProfileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PprofHeapProfileRequest gc.
             * @member {boolean} gc
             * @memberof api.PprofHeapProfileRequest
             * @instance
             */
            PprofHeapProfileRequest.prototype.gc = false;
    
            /**
             * PprofHeapProfileRequest debug.
             * @member {boolean} debug
             * @memberof api.PprofHeapProfileRequest
             * @instance
             */
            PprofHeapProfileRequest.prototype.debug = false;
    
            /**
             * Creates a new PprofHeapProfileRequest instance using the specified properties.
             * @function create
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {api.IPprofHeapProfileRequest=} [properties] Properties to set
             * @returns {api.PprofHeapProfileRequest} PprofHeapProfileRequest instance
             */
            PprofHeapProfileRequest.create = function create(properties) {
                return PprofHeapProfileRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified PprofHeapProfileRequest message. Does not implicitly {@link api.PprofHeapProfileRequest.verify|verify} messages.
             * @function encode
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {api.PprofHeapProfileRequest} message PprofHeapProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofHeapProfileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.gc != null && Object.hasOwnProperty.call(message, "gc"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.gc);
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.debug);
                return writer;
            };
    
            /**
             * Encodes the specified PprofHeapProfileRequest message, length delimited. Does not implicitly {@link api.PprofHeapProfileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {api.PprofHeapProfileRequest} message PprofHeapProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofHeapProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PprofHeapProfileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PprofHeapProfileRequest} PprofHeapProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofHeapProfileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PprofHeapProfileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gc = reader.bool();
                        break;
                    case 2:
                        message.debug = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PprofHeapProfileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PprofHeapProfileRequest} PprofHeapProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofHeapProfileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PprofHeapProfileRequest message.
             * @function verify
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PprofHeapProfileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.gc != null && message.hasOwnProperty("gc"))
                    if (typeof message.gc !== "boolean")
                        return "gc: boolean expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                return null;
            };
    
            /**
             * Creates a PprofHeapProfileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PprofHeapProfileRequest} PprofHeapProfileRequest
             */
            PprofHeapProfileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PprofHeapProfileRequest)
                    return object;
                var message = new $root.api.PprofHeapProfileRequest();
                if (object.gc != null)
                    message.gc = Boolean(object.gc);
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                return message;
            };
    
            /**
             * Creates a plain object from a PprofHeapProfileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PprofHeapProfileRequest
             * @static
             * @param {api.PprofHeapProfileRequest} message PprofHeapProfileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PprofHeapProfileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.gc = false;
                    object.debug = false;
                }
                if (message.gc != null && message.hasOwnProperty("gc"))
                    object.gc = message.gc;
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                return object;
            };
    
            /**
             * Converts this PprofHeapProfileRequest to JSON.
             * @function toJSON
             * @memberof api.PprofHeapProfileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PprofHeapProfileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PprofHeapProfileRequest;
        })();
    
        api.PprofMutexProfileRequest = (function() {
    
            /**
             * Properties of a PprofMutexProfileRequest.
             * @memberof api
             * @interface IPprofMutexProfileRequest
             * @property {boolean|null} [debug] PprofMutexProfileRequest debug
             */
    
            /**
             * Constructs a new PprofMutexProfileRequest.
             * @memberof api
             * @classdesc Represents a PprofMutexProfileRequest.
             * @constructor
             * @param {api.IPprofMutexProfileRequest=} [properties] Properties to set
             */
            function PprofMutexProfileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PprofMutexProfileRequest debug.
             * @member {boolean} debug
             * @memberof api.PprofMutexProfileRequest
             * @instance
             */
            PprofMutexProfileRequest.prototype.debug = false;
    
            /**
             * Creates a new PprofMutexProfileRequest instance using the specified properties.
             * @function create
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {api.IPprofMutexProfileRequest=} [properties] Properties to set
             * @returns {api.PprofMutexProfileRequest} PprofMutexProfileRequest instance
             */
            PprofMutexProfileRequest.create = function create(properties) {
                return PprofMutexProfileRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified PprofMutexProfileRequest message. Does not implicitly {@link api.PprofMutexProfileRequest.verify|verify} messages.
             * @function encode
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {api.PprofMutexProfileRequest} message PprofMutexProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofMutexProfileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.debug);
                return writer;
            };
    
            /**
             * Encodes the specified PprofMutexProfileRequest message, length delimited. Does not implicitly {@link api.PprofMutexProfileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {api.PprofMutexProfileRequest} message PprofMutexProfileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofMutexProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PprofMutexProfileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PprofMutexProfileRequest} PprofMutexProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofMutexProfileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PprofMutexProfileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.debug = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PprofMutexProfileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PprofMutexProfileRequest} PprofMutexProfileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofMutexProfileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PprofMutexProfileRequest message.
             * @function verify
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PprofMutexProfileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                return null;
            };
    
            /**
             * Creates a PprofMutexProfileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PprofMutexProfileRequest} PprofMutexProfileRequest
             */
            PprofMutexProfileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PprofMutexProfileRequest)
                    return object;
                var message = new $root.api.PprofMutexProfileRequest();
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                return message;
            };
    
            /**
             * Creates a plain object from a PprofMutexProfileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PprofMutexProfileRequest
             * @static
             * @param {api.PprofMutexProfileRequest} message PprofMutexProfileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PprofMutexProfileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.debug = false;
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                return object;
            };
    
            /**
             * Converts this PprofMutexProfileRequest to JSON.
             * @function toJSON
             * @memberof api.PprofMutexProfileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PprofMutexProfileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PprofMutexProfileRequest;
        })();
    
        api.PprofResponse = (function() {
    
            /**
             * Properties of a PprofResponse.
             * @memberof api
             * @interface IPprofResponse
             * @property {string|null} [id] PprofResponse id
             * @property {Uint8Array|null} [profile] PprofResponse profile
             */
    
            /**
             * Constructs a new PprofResponse.
             * @memberof api
             * @classdesc Represents a PprofResponse.
             * @constructor
             * @param {api.IPprofResponse=} [properties] Properties to set
             */
            function PprofResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PprofResponse id.
             * @member {string} id
             * @memberof api.PprofResponse
             * @instance
             */
            PprofResponse.prototype.id = "";
    
            /**
             * PprofResponse profile.
             * @member {Uint8Array} profile
             * @memberof api.PprofResponse
             * @instance
             */
            PprofResponse.prototype.profile = $util.newBuffer([]);
    
            /**
             * Creates a new PprofResponse instance using the specified properties.
             * @function create
             * @memberof api.PprofResponse
             * @static
             * @param {api.IPprofResponse=} [properties] Properties to set
             * @returns {api.PprofResponse} PprofResponse instance
             */
            PprofResponse.create = function create(properties) {
                return PprofResponse.fromObject(properties);
            };
    
            /**
             * Encodes the specified PprofResponse message. Does not implicitly {@link api.PprofResponse.verify|verify} messages.
             * @function encode
             * @memberof api.PprofResponse
             * @static
             * @param {api.PprofResponse} message PprofResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.profile);
                return writer;
            };
    
            /**
             * Encodes the specified PprofResponse message, length delimited. Does not implicitly {@link api.PprofResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PprofResponse
             * @static
             * @param {api.PprofResponse} message PprofResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PprofResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PprofResponse message from the specified reader or buffer.
             * @function decode
             * @memberof api.PprofResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PprofResponse} PprofResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PprofResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.profile = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PprofResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PprofResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PprofResponse} PprofResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PprofResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PprofResponse message.
             * @function verify
             * @memberof api.PprofResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PprofResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.profile != null && message.hasOwnProperty("profile"))
                    if (!(message.profile && typeof message.profile.length === "number" || $util.isString(message.profile)))
                        return "profile: buffer expected";
                return null;
            };
    
            /**
             * Creates a PprofResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PprofResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PprofResponse} PprofResponse
             */
            PprofResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PprofResponse)
                    return object;
                var message = new $root.api.PprofResponse();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.profile != null)
                    if (typeof object.profile === "string")
                        $util.base64.decode(object.profile, message.profile = $util.newBuffer($util.base64.length(object.profile)), 0);
                    else if (object.profile.length)
                        message.profile = object.profile;
                return message;
            };
    
            /**
             * Creates a plain object from a PprofResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PprofResponse
             * @static
             * @param {api.PprofResponse} message PprofResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PprofResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    if (options.bytes === String)
                        object.profile = "";
                    else {
                        object.profile = [];
                        if (options.bytes !== Array)
                            object.profile = $util.newBuffer(object.profile);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.profile != null && message.hasOwnProperty("profile"))
                    object.profile = options.bytes === String ? $util.base64.encode(message.profile, 0, message.profile.length) : options.bytes === Array ? Array.prototype.slice.call(message.profile) : message.profile;
                return object;
            };
    
            /**
             * Converts this PprofResponse to JSON.
             * @function toJSON
             * @memberof api.PprofResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PprofResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PprofResponse;
        })();
    
        api.PTYConfig = (function() {
    
            /**
             * Properties of a PTYConfig.
             * @memberof api
             * @interface IPTYConfig
             * @property {boolean|null} [pipeMode] PTYConfig pipeMode
             */
    
            /**
             * Constructs a new PTYConfig.
             * @memberof api
             * @classdesc Represents a PTYConfig.
             * @constructor
             * @param {api.IPTYConfig=} [properties] Properties to set
             */
            function PTYConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PTYConfig pipeMode.
             * @member {boolean} pipeMode
             * @memberof api.PTYConfig
             * @instance
             */
            PTYConfig.prototype.pipeMode = false;
    
            /**
             * Creates a new PTYConfig instance using the specified properties.
             * @function create
             * @memberof api.PTYConfig
             * @static
             * @param {api.IPTYConfig=} [properties] Properties to set
             * @returns {api.PTYConfig} PTYConfig instance
             */
            PTYConfig.create = function create(properties) {
                return PTYConfig.fromObject(properties);
            };
    
            /**
             * Encodes the specified PTYConfig message. Does not implicitly {@link api.PTYConfig.verify|verify} messages.
             * @function encode
             * @memberof api.PTYConfig
             * @static
             * @param {api.PTYConfig} message PTYConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PTYConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pipeMode != null && Object.hasOwnProperty.call(message, "pipeMode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.pipeMode);
                return writer;
            };
    
            /**
             * Encodes the specified PTYConfig message, length delimited. Does not implicitly {@link api.PTYConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.PTYConfig
             * @static
             * @param {api.PTYConfig} message PTYConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PTYConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PTYConfig message from the specified reader or buffer.
             * @function decode
             * @memberof api.PTYConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.PTYConfig} PTYConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PTYConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PTYConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pipeMode = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PTYConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.PTYConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.PTYConfig} PTYConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PTYConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PTYConfig message.
             * @function verify
             * @memberof api.PTYConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PTYConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pipeMode != null && message.hasOwnProperty("pipeMode"))
                    if (typeof message.pipeMode !== "boolean")
                        return "pipeMode: boolean expected";
                return null;
            };
    
            /**
             * Creates a PTYConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.PTYConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.PTYConfig} PTYConfig
             */
            PTYConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.api.PTYConfig)
                    return object;
                var message = new $root.api.PTYConfig();
                if (object.pipeMode != null)
                    message.pipeMode = Boolean(object.pipeMode);
                return message;
            };
    
            /**
             * Creates a plain object from a PTYConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.PTYConfig
             * @static
             * @param {api.PTYConfig} message PTYConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PTYConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.pipeMode = false;
                if (message.pipeMode != null && message.hasOwnProperty("pipeMode"))
                    object.pipeMode = message.pipeMode;
                return object;
            };
    
            /**
             * Converts this PTYConfig to JSON.
             * @function toJSON
             * @memberof api.PTYConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PTYConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PTYConfig;
        })();
    
        api.DebugMain = (function() {
    
            /**
             * Properties of a DebugMain.
             * @memberof api
             * @interface IDebugMain
             * @property {string|null} [session] DebugMain session
             * @property {boolean|null} [readOnly] DebugMain readOnly
             */
    
            /**
             * Constructs a new DebugMain.
             * @memberof api
             * @classdesc Represents a DebugMain.
             * @constructor
             * @param {api.IDebugMain=} [properties] Properties to set
             */
            function DebugMain(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugMain session.
             * @member {string} session
             * @memberof api.DebugMain
             * @instance
             */
            DebugMain.prototype.session = "";
    
            /**
             * DebugMain readOnly.
             * @member {boolean} readOnly
             * @memberof api.DebugMain
             * @instance
             */
            DebugMain.prototype.readOnly = false;
    
            /**
             * Creates a new DebugMain instance using the specified properties.
             * @function create
             * @memberof api.DebugMain
             * @static
             * @param {api.IDebugMain=} [properties] Properties to set
             * @returns {api.DebugMain} DebugMain instance
             */
            DebugMain.create = function create(properties) {
                return DebugMain.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugMain message. Does not implicitly {@link api.DebugMain.verify|verify} messages.
             * @function encode
             * @memberof api.DebugMain
             * @static
             * @param {api.DebugMain} message DebugMain message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugMain.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.session);
                if (message.readOnly != null && Object.hasOwnProperty.call(message, "readOnly"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.readOnly);
                return writer;
            };
    
            /**
             * Encodes the specified DebugMain message, length delimited. Does not implicitly {@link api.DebugMain.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugMain
             * @static
             * @param {api.DebugMain} message DebugMain message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugMain.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugMain message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugMain
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugMain} DebugMain
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugMain.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugMain();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.string();
                        break;
                    case 2:
                        message.readOnly = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugMain message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugMain
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugMain} DebugMain
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugMain.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugMain message.
             * @function verify
             * @memberof api.DebugMain
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugMain.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isString(message.session))
                        return "session: string expected";
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    if (typeof message.readOnly !== "boolean")
                        return "readOnly: boolean expected";
                return null;
            };
    
            /**
             * Creates a DebugMain message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugMain
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugMain} DebugMain
             */
            DebugMain.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugMain)
                    return object;
                var message = new $root.api.DebugMain();
                if (object.session != null)
                    message.session = String(object.session);
                if (object.readOnly != null)
                    message.readOnly = Boolean(object.readOnly);
                return message;
            };
    
            /**
             * Creates a plain object from a DebugMain message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugMain
             * @static
             * @param {api.DebugMain} message DebugMain
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugMain.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.session = "";
                    object.readOnly = false;
                }
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                if (message.readOnly != null && message.hasOwnProperty("readOnly"))
                    object.readOnly = message.readOnly;
                return object;
            };
    
            /**
             * Converts this DebugMain to JSON.
             * @function toJSON
             * @memberof api.DebugMain
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugMain.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugMain;
        })();
    
        api.DebugMainReply = (function() {
    
            /**
             * Properties of a DebugMainReply.
             * @memberof api
             * @interface IDebugMainReply
             * @property {boolean|null} [joined] DebugMainReply joined
             * @property {api.DebugMainReply.Protocol|null} [protocol] DebugMainReply protocol
             */
    
            /**
             * Constructs a new DebugMainReply.
             * @memberof api
             * @classdesc Represents a DebugMainReply.
             * @constructor
             * @param {api.IDebugMainReply=} [properties] Properties to set
             */
            function DebugMainReply(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugMainReply joined.
             * @member {boolean} joined
             * @memberof api.DebugMainReply
             * @instance
             */
            DebugMainReply.prototype.joined = false;
    
            /**
             * DebugMainReply protocol.
             * @member {api.DebugMainReply.Protocol} protocol
             * @memberof api.DebugMainReply
             * @instance
             */
            DebugMainReply.prototype.protocol = 0;
    
            /**
             * Creates a new DebugMainReply instance using the specified properties.
             * @function create
             * @memberof api.DebugMainReply
             * @static
             * @param {api.IDebugMainReply=} [properties] Properties to set
             * @returns {api.DebugMainReply} DebugMainReply instance
             */
            DebugMainReply.create = function create(properties) {
                return DebugMainReply.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugMainReply message. Does not implicitly {@link api.DebugMainReply.verify|verify} messages.
             * @function encode
             * @memberof api.DebugMainReply
             * @static
             * @param {api.DebugMainReply} message DebugMainReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugMainReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.joined != null && Object.hasOwnProperty.call(message, "joined"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.joined);
                if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.protocol);
                return writer;
            };
    
            /**
             * Encodes the specified DebugMainReply message, length delimited. Does not implicitly {@link api.DebugMainReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugMainReply
             * @static
             * @param {api.DebugMainReply} message DebugMainReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugMainReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugMainReply message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugMainReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugMainReply} DebugMainReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugMainReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugMainReply();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.joined = reader.bool();
                        break;
                    case 2:
                        message.protocol = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugMainReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugMainReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugMainReply} DebugMainReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugMainReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugMainReply message.
             * @function verify
             * @memberof api.DebugMainReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugMainReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.joined != null && message.hasOwnProperty("joined"))
                    if (typeof message.joined !== "boolean")
                        return "joined: boolean expected";
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    switch (message.protocol) {
                    default:
                        return "protocol: enum value expected";
                    case 0:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DebugMainReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugMainReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugMainReply} DebugMainReply
             */
            DebugMainReply.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugMainReply)
                    return object;
                var message = new $root.api.DebugMainReply();
                if (object.joined != null)
                    message.joined = Boolean(object.joined);
                switch (object.protocol) {
                case "DAP":
                case 0:
                    message.protocol = 0;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DebugMainReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugMainReply
             * @static
             * @param {api.DebugMainReply} message DebugMainReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugMainReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.joined = false;
                    object.protocol = options.enums === String ? "DAP" : 0;
                }
                if (message.joined != null && message.hasOwnProperty("joined"))
                    object.joined = message.joined;
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    object.protocol = options.enums === String ? $root.api.DebugMainReply.Protocol[message.protocol] : message.protocol;
                return object;
            };
    
            /**
             * Converts this DebugMainReply to JSON.
             * @function toJSON
             * @memberof api.DebugMainReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugMainReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Protocol enum.
             * @name api.DebugMainReply.Protocol
             * @enum {number}
             * @property {number} DAP=0 DAP value
             */
            DebugMainReply.Protocol = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DAP"] = 0;
                return values;
            })();
    
            return DebugMainReply;
        })();
    
        api.DebugState = (function() {
    
            /**
             * Properties of a DebugState.
             * @memberof api
             * @interface IDebugState
             * @property {string|null} [session] DebugState session
             * @property {api.State|null} [state] DebugState state
             */
    
            /**
             * Constructs a new DebugState.
             * @memberof api
             * @classdesc Represents a DebugState.
             * @constructor
             * @param {api.IDebugState=} [properties] Properties to set
             */
            function DebugState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugState session.
             * @member {string} session
             * @memberof api.DebugState
             * @instance
             */
            DebugState.prototype.session = "";
    
            /**
             * DebugState state.
             * @member {api.State} state
             * @memberof api.DebugState
             * @instance
             */
            DebugState.prototype.state = 0;
    
            /**
             * Creates a new DebugState instance using the specified properties.
             * @function create
             * @memberof api.DebugState
             * @static
             * @param {api.IDebugState=} [properties] Properties to set
             * @returns {api.DebugState} DebugState instance
             */
            DebugState.create = function create(properties) {
                return DebugState.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugState message. Does not implicitly {@link api.DebugState.verify|verify} messages.
             * @function encode
             * @memberof api.DebugState
             * @static
             * @param {api.DebugState} message DebugState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.session);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                return writer;
            };
    
            /**
             * Encodes the specified DebugState message, length delimited. Does not implicitly {@link api.DebugState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugState
             * @static
             * @param {api.DebugState} message DebugState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugState message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugState} DebugState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.string();
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugState} DebugState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugState message.
             * @function verify
             * @memberof api.DebugState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isString(message.session))
                        return "session: string expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DebugState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugState} DebugState
             */
            DebugState.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugState)
                    return object;
                var message = new $root.api.DebugState();
                if (object.session != null)
                    message.session = String(object.session);
                switch (object.state) {
                case "Stopped":
                case 0:
                    message.state = 0;
                    break;
                case "Running":
                case 1:
                    message.state = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DebugState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugState
             * @static
             * @param {api.DebugState} message DebugState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.session = "";
                    object.state = options.enums === String ? "Stopped" : 0;
                }
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.api.State[message.state] : message.state;
                return object;
            };
    
            /**
             * Converts this DebugState to JSON.
             * @function toJSON
             * @memberof api.DebugState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugState;
        })();
    
        api.DebugInput = (function() {
    
            /**
             * Properties of a DebugInput.
             * @memberof api
             * @interface IDebugInput
             * @property {string|null} [session] DebugInput session
             * @property {string|null} [input] DebugInput input
             * @property {string|null} [adapterInput] DebugInput adapterInput
             */
    
            /**
             * Constructs a new DebugInput.
             * @memberof api
             * @classdesc Represents a DebugInput.
             * @constructor
             * @param {api.IDebugInput=} [properties] Properties to set
             */
            function DebugInput(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugInput session.
             * @member {string} session
             * @memberof api.DebugInput
             * @instance
             */
            DebugInput.prototype.session = "";
    
            /**
             * DebugInput input.
             * @member {string} input
             * @memberof api.DebugInput
             * @instance
             */
            DebugInput.prototype.input = "";
    
            /**
             * DebugInput adapterInput.
             * @member {string} adapterInput
             * @memberof api.DebugInput
             * @instance
             */
            DebugInput.prototype.adapterInput = "";
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * DebugInput stream.
             * @member {"input"|"adapterInput"|undefined} stream
             * @memberof api.DebugInput
             * @instance
             */
            Object.defineProperty(DebugInput.prototype, "stream", {
                get: $util.oneOfGetter($oneOfFields = ["input", "adapterInput"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new DebugInput instance using the specified properties.
             * @function create
             * @memberof api.DebugInput
             * @static
             * @param {api.IDebugInput=} [properties] Properties to set
             * @returns {api.DebugInput} DebugInput instance
             */
            DebugInput.create = function create(properties) {
                return DebugInput.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugInput message. Does not implicitly {@link api.DebugInput.verify|verify} messages.
             * @function encode
             * @memberof api.DebugInput
             * @static
             * @param {api.DebugInput} message DebugInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugInput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.session);
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.input);
                if (message.adapterInput != null && Object.hasOwnProperty.call(message, "adapterInput"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.adapterInput);
                return writer;
            };
    
            /**
             * Encodes the specified DebugInput message, length delimited. Does not implicitly {@link api.DebugInput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugInput
             * @static
             * @param {api.DebugInput} message DebugInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugInput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugInput message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugInput} DebugInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugInput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugInput();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.string();
                        break;
                    case 2:
                        message.input = reader.string();
                        break;
                    case 3:
                        message.adapterInput = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugInput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugInput} DebugInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugInput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugInput message.
             * @function verify
             * @memberof api.DebugInput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugInput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isString(message.session))
                        return "session: string expected";
                if (message.input != null && message.hasOwnProperty("input")) {
                    properties.stream = 1;
                    if (!$util.isString(message.input))
                        return "input: string expected";
                }
                if (message.adapterInput != null && message.hasOwnProperty("adapterInput")) {
                    if (properties.stream === 1)
                        return "stream: multiple values";
                    properties.stream = 1;
                    if (!$util.isString(message.adapterInput))
                        return "adapterInput: string expected";
                }
                return null;
            };
    
            /**
             * Creates a DebugInput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugInput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugInput} DebugInput
             */
            DebugInput.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugInput)
                    return object;
                var message = new $root.api.DebugInput();
                if (object.session != null)
                    message.session = String(object.session);
                if (object.input != null)
                    message.input = String(object.input);
                if (object.adapterInput != null)
                    message.adapterInput = String(object.adapterInput);
                return message;
            };
    
            /**
             * Creates a plain object from a DebugInput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugInput
             * @static
             * @param {api.DebugInput} message DebugInput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugInput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.session = "";
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                if (message.input != null && message.hasOwnProperty("input")) {
                    object.input = message.input;
                    if (options.oneofs)
                        object.stream = "input";
                }
                if (message.adapterInput != null && message.hasOwnProperty("adapterInput")) {
                    object.adapterInput = message.adapterInput;
                    if (options.oneofs)
                        object.stream = "adapterInput";
                }
                return object;
            };
    
            /**
             * Converts this DebugInput to JSON.
             * @function toJSON
             * @memberof api.DebugInput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugInput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugInput;
        })();
    
        api.DebugOutput = (function() {
    
            /**
             * Properties of a DebugOutput.
             * @memberof api
             * @interface IDebugOutput
             * @property {string|null} [session] DebugOutput session
             * @property {string|null} [output] DebugOutput output
             * @property {string|null} [adapterOutput] DebugOutput adapterOutput
             */
    
            /**
             * Constructs a new DebugOutput.
             * @memberof api
             * @classdesc Represents a DebugOutput.
             * @constructor
             * @param {api.IDebugOutput=} [properties] Properties to set
             */
            function DebugOutput(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugOutput session.
             * @member {string} session
             * @memberof api.DebugOutput
             * @instance
             */
            DebugOutput.prototype.session = "";
    
            /**
             * DebugOutput output.
             * @member {string} output
             * @memberof api.DebugOutput
             * @instance
             */
            DebugOutput.prototype.output = "";
    
            /**
             * DebugOutput adapterOutput.
             * @member {string} adapterOutput
             * @memberof api.DebugOutput
             * @instance
             */
            DebugOutput.prototype.adapterOutput = "";
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * DebugOutput stream.
             * @member {"output"|"adapterOutput"|undefined} stream
             * @memberof api.DebugOutput
             * @instance
             */
            Object.defineProperty(DebugOutput.prototype, "stream", {
                get: $util.oneOfGetter($oneOfFields = ["output", "adapterOutput"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new DebugOutput instance using the specified properties.
             * @function create
             * @memberof api.DebugOutput
             * @static
             * @param {api.IDebugOutput=} [properties] Properties to set
             * @returns {api.DebugOutput} DebugOutput instance
             */
            DebugOutput.create = function create(properties) {
                return DebugOutput.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugOutput message. Does not implicitly {@link api.DebugOutput.verify|verify} messages.
             * @function encode
             * @memberof api.DebugOutput
             * @static
             * @param {api.DebugOutput} message DebugOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugOutput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.session);
                if (message.output != null && Object.hasOwnProperty.call(message, "output"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.output);
                if (message.adapterOutput != null && Object.hasOwnProperty.call(message, "adapterOutput"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.adapterOutput);
                return writer;
            };
    
            /**
             * Encodes the specified DebugOutput message, length delimited. Does not implicitly {@link api.DebugOutput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugOutput
             * @static
             * @param {api.DebugOutput} message DebugOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugOutput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugOutput message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugOutput} DebugOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugOutput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugOutput();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.string();
                        break;
                    case 2:
                        message.output = reader.string();
                        break;
                    case 3:
                        message.adapterOutput = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugOutput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugOutput} DebugOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugOutput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugOutput message.
             * @function verify
             * @memberof api.DebugOutput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugOutput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isString(message.session))
                        return "session: string expected";
                if (message.output != null && message.hasOwnProperty("output")) {
                    properties.stream = 1;
                    if (!$util.isString(message.output))
                        return "output: string expected";
                }
                if (message.adapterOutput != null && message.hasOwnProperty("adapterOutput")) {
                    if (properties.stream === 1)
                        return "stream: multiple values";
                    properties.stream = 1;
                    if (!$util.isString(message.adapterOutput))
                        return "adapterOutput: string expected";
                }
                return null;
            };
    
            /**
             * Creates a DebugOutput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugOutput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugOutput} DebugOutput
             */
            DebugOutput.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugOutput)
                    return object;
                var message = new $root.api.DebugOutput();
                if (object.session != null)
                    message.session = String(object.session);
                if (object.output != null)
                    message.output = String(object.output);
                if (object.adapterOutput != null)
                    message.adapterOutput = String(object.adapterOutput);
                return message;
            };
    
            /**
             * Creates a plain object from a DebugOutput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugOutput
             * @static
             * @param {api.DebugOutput} message DebugOutput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugOutput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.session = "";
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                if (message.output != null && message.hasOwnProperty("output")) {
                    object.output = message.output;
                    if (options.oneofs)
                        object.stream = "output";
                }
                if (message.adapterOutput != null && message.hasOwnProperty("adapterOutput")) {
                    object.adapterOutput = message.adapterOutput;
                    if (options.oneofs)
                        object.stream = "adapterOutput";
                }
                return object;
            };
    
            /**
             * Converts this DebugOutput to JSON.
             * @function toJSON
             * @memberof api.DebugOutput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugOutput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugOutput;
        })();
    
        api.DebugStop = (function() {
    
            /**
             * Properties of a DebugStop.
             * @memberof api
             * @interface IDebugStop
             * @property {string|null} [session] DebugStop session
             */
    
            /**
             * Constructs a new DebugStop.
             * @memberof api
             * @classdesc Represents a DebugStop.
             * @constructor
             * @param {api.IDebugStop=} [properties] Properties to set
             */
            function DebugStop(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugStop session.
             * @member {string} session
             * @memberof api.DebugStop
             * @instance
             */
            DebugStop.prototype.session = "";
    
            /**
             * Creates a new DebugStop instance using the specified properties.
             * @function create
             * @memberof api.DebugStop
             * @static
             * @param {api.IDebugStop=} [properties] Properties to set
             * @returns {api.DebugStop} DebugStop instance
             */
            DebugStop.create = function create(properties) {
                return DebugStop.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugStop message. Does not implicitly {@link api.DebugStop.verify|verify} messages.
             * @function encode
             * @memberof api.DebugStop
             * @static
             * @param {api.DebugStop} message DebugStop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugStop.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.session);
                return writer;
            };
    
            /**
             * Encodes the specified DebugStop message, length delimited. Does not implicitly {@link api.DebugStop.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugStop
             * @static
             * @param {api.DebugStop} message DebugStop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugStop.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugStop message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugStop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugStop} DebugStop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugStop.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugStop();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugStop message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugStop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugStop} DebugStop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugStop.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugStop message.
             * @function verify
             * @memberof api.DebugStop
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugStop.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isString(message.session))
                        return "session: string expected";
                return null;
            };
    
            /**
             * Creates a DebugStop message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugStop
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugStop} DebugStop
             */
            DebugStop.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugStop)
                    return object;
                var message = new $root.api.DebugStop();
                if (object.session != null)
                    message.session = String(object.session);
                return message;
            };
    
            /**
             * Creates a plain object from a DebugStop message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugStop
             * @static
             * @param {api.DebugStop} message DebugStop
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugStop.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.session = "";
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                return object;
            };
    
            /**
             * Converts this DebugStop to JSON.
             * @function toJSON
             * @memberof api.DebugStop
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugStop.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugStop;
        })();
    
        api.DebugLeave = (function() {
    
            /**
             * Properties of a DebugLeave.
             * @memberof api
             * @interface IDebugLeave
             * @property {string|null} [session] DebugLeave session
             */
    
            /**
             * Constructs a new DebugLeave.
             * @memberof api
             * @classdesc Represents a DebugLeave.
             * @constructor
             * @param {api.IDebugLeave=} [properties] Properties to set
             */
            function DebugLeave(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugLeave session.
             * @member {string} session
             * @memberof api.DebugLeave
             * @instance
             */
            DebugLeave.prototype.session = "";
    
            /**
             * Creates a new DebugLeave instance using the specified properties.
             * @function create
             * @memberof api.DebugLeave
             * @static
             * @param {api.IDebugLeave=} [properties] Properties to set
             * @returns {api.DebugLeave} DebugLeave instance
             */
            DebugLeave.create = function create(properties) {
                return DebugLeave.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugLeave message. Does not implicitly {@link api.DebugLeave.verify|verify} messages.
             * @function encode
             * @memberof api.DebugLeave
             * @static
             * @param {api.DebugLeave} message DebugLeave message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugLeave.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.session);
                return writer;
            };
    
            /**
             * Encodes the specified DebugLeave message, length delimited. Does not implicitly {@link api.DebugLeave.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugLeave
             * @static
             * @param {api.DebugLeave} message DebugLeave message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugLeave.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugLeave message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugLeave
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugLeave} DebugLeave
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugLeave.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugLeave();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.session = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugLeave message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugLeave
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugLeave} DebugLeave
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugLeave.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugLeave message.
             * @function verify
             * @memberof api.DebugLeave
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugLeave.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.session != null && message.hasOwnProperty("session"))
                    if (!$util.isString(message.session))
                        return "session: string expected";
                return null;
            };
    
            /**
             * Creates a DebugLeave message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugLeave
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugLeave} DebugLeave
             */
            DebugLeave.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugLeave)
                    return object;
                var message = new $root.api.DebugLeave();
                if (object.session != null)
                    message.session = String(object.session);
                return message;
            };
    
            /**
             * Creates a plain object from a DebugLeave message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugLeave
             * @static
             * @param {api.DebugLeave} message DebugLeave
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugLeave.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.session = "";
                if (message.session != null && message.hasOwnProperty("session"))
                    object.session = message.session;
                return object;
            };
    
            /**
             * Converts this DebugLeave to JSON.
             * @function toJSON
             * @memberof api.DebugLeave
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugLeave.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugLeave;
        })();
    
        api.DebugSessions = (function() {
    
            /**
             * Properties of a DebugSessions.
             * @memberof api
             * @interface IDebugSessions
             * @property {Object.<string,api.State>|null} [sessions] DebugSessions sessions
             */
    
            /**
             * Constructs a new DebugSessions.
             * @memberof api
             * @classdesc Represents a DebugSessions.
             * @constructor
             * @param {api.IDebugSessions=} [properties] Properties to set
             */
            function DebugSessions(properties) {
                this.sessions = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugSessions sessions.
             * @member {Object.<string,api.State>} sessions
             * @memberof api.DebugSessions
             * @instance
             */
            DebugSessions.prototype.sessions = $util.emptyObject;
    
            /**
             * Creates a new DebugSessions instance using the specified properties.
             * @function create
             * @memberof api.DebugSessions
             * @static
             * @param {api.IDebugSessions=} [properties] Properties to set
             * @returns {api.DebugSessions} DebugSessions instance
             */
            DebugSessions.create = function create(properties) {
                return DebugSessions.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugSessions message. Does not implicitly {@link api.DebugSessions.verify|verify} messages.
             * @function encode
             * @memberof api.DebugSessions
             * @static
             * @param {api.DebugSessions} message DebugSessions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugSessions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessions != null && Object.hasOwnProperty.call(message, "sessions"))
                    for (var keys = Object.keys(message.sessions), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.sessions[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DebugSessions message, length delimited. Does not implicitly {@link api.DebugSessions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugSessions
             * @static
             * @param {api.DebugSessions} message DebugSessions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugSessions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugSessions message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugSessions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugSessions} DebugSessions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugSessions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugSessions(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.sessions === $util.emptyObject)
                            message.sessions = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.int32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.sessions[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugSessions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugSessions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugSessions} DebugSessions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugSessions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugSessions message.
             * @function verify
             * @memberof api.DebugSessions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugSessions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessions != null && message.hasOwnProperty("sessions")) {
                    if (!$util.isObject(message.sessions))
                        return "sessions: object expected";
                    var key = Object.keys(message.sessions);
                    for (var i = 0; i < key.length; ++i)
                        switch (message.sessions[key[i]]) {
                        default:
                            return "sessions: enum value{k:string} expected";
                        case 0:
                        case 1:
                            break;
                        }
                }
                return null;
            };
    
            /**
             * Creates a DebugSessions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugSessions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugSessions} DebugSessions
             */
            DebugSessions.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugSessions)
                    return object;
                var message = new $root.api.DebugSessions();
                if (object.sessions) {
                    if (typeof object.sessions !== "object")
                        throw TypeError(".api.DebugSessions.sessions: object expected");
                    message.sessions = {};
                    for (var keys = Object.keys(object.sessions), i = 0; i < keys.length; ++i)
                        switch (object.sessions[keys[i]]) {
                        case "Stopped":
                        case 0:
                            message.sessions[keys[i]] = 0;
                            break;
                        case "Running":
                        case 1:
                            message.sessions[keys[i]] = 1;
                            break;
                        }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DebugSessions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugSessions
             * @static
             * @param {api.DebugSessions} message DebugSessions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugSessions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.sessions = {};
                var keys2;
                if (message.sessions && (keys2 = Object.keys(message.sessions)).length) {
                    object.sessions = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.sessions[keys2[j]] = options.enums === String ? $root.api.State[message.sessions[keys2[j]]] : message.sessions[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this DebugSessions to JSON.
             * @function toJSON
             * @memberof api.DebugSessions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugSessions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugSessions;
        })();
    
        api.DotReplitGetRequest = (function() {
    
            /**
             * Properties of a DotReplitGetRequest.
             * @memberof api
             * @interface IDotReplitGetRequest
             */
    
            /**
             * Constructs a new DotReplitGetRequest.
             * @memberof api
             * @classdesc Represents a DotReplitGetRequest.
             * @constructor
             * @param {api.IDotReplitGetRequest=} [properties] Properties to set
             */
            function DotReplitGetRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new DotReplitGetRequest instance using the specified properties.
             * @function create
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {api.IDotReplitGetRequest=} [properties] Properties to set
             * @returns {api.DotReplitGetRequest} DotReplitGetRequest instance
             */
            DotReplitGetRequest.create = function create(properties) {
                return DotReplitGetRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified DotReplitGetRequest message. Does not implicitly {@link api.DotReplitGetRequest.verify|verify} messages.
             * @function encode
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {api.DotReplitGetRequest} message DotReplitGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified DotReplitGetRequest message, length delimited. Does not implicitly {@link api.DotReplitGetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {api.DotReplitGetRequest} message DotReplitGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DotReplitGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DotReplitGetRequest} DotReplitGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DotReplitGetRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DotReplitGetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DotReplitGetRequest} DotReplitGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitGetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DotReplitGetRequest message.
             * @function verify
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DotReplitGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a DotReplitGetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DotReplitGetRequest} DotReplitGetRequest
             */
            DotReplitGetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DotReplitGetRequest)
                    return object;
                return new $root.api.DotReplitGetRequest();
            };
    
            /**
             * Creates a plain object from a DotReplitGetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DotReplitGetRequest
             * @static
             * @param {api.DotReplitGetRequest} message DotReplitGetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DotReplitGetRequest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this DotReplitGetRequest to JSON.
             * @function toJSON
             * @memberof api.DotReplitGetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DotReplitGetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DotReplitGetRequest;
        })();
    
        api.DotReplitGetResponse = (function() {
    
            /**
             * Properties of a DotReplitGetResponse.
             * @memberof api
             * @interface IDotReplitGetResponse
             * @property {api.DotReplit|api.IDotReplit|null} [dotReplit] DotReplitGetResponse dotReplit
             */
    
            /**
             * Constructs a new DotReplitGetResponse.
             * @memberof api
             * @classdesc Represents a DotReplitGetResponse.
             * @constructor
             * @param {api.IDotReplitGetResponse=} [properties] Properties to set
             */
            function DotReplitGetResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DotReplitGetResponse dotReplit.
             * @member {api.DotReplit|null|undefined} dotReplit
             * @memberof api.DotReplitGetResponse
             * @instance
             */
            DotReplitGetResponse.prototype.dotReplit = null;
    
            /**
             * Creates a new DotReplitGetResponse instance using the specified properties.
             * @function create
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {api.IDotReplitGetResponse=} [properties] Properties to set
             * @returns {api.DotReplitGetResponse} DotReplitGetResponse instance
             */
            DotReplitGetResponse.create = function create(properties) {
                return DotReplitGetResponse.fromObject(properties);
            };
    
            /**
             * Encodes the specified DotReplitGetResponse message. Does not implicitly {@link api.DotReplitGetResponse.verify|verify} messages.
             * @function encode
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {api.DotReplitGetResponse} message DotReplitGetResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitGetResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dotReplit != null && Object.hasOwnProperty.call(message, "dotReplit"))
                    $root.api.DotReplit.encode(message.dotReplit, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DotReplitGetResponse message, length delimited. Does not implicitly {@link api.DotReplitGetResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {api.DotReplitGetResponse} message DotReplitGetResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DotReplitGetResponse message from the specified reader or buffer.
             * @function decode
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DotReplitGetResponse} DotReplitGetResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitGetResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DotReplitGetResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dotReplit = $root.api.DotReplit.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DotReplitGetResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DotReplitGetResponse} DotReplitGetResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitGetResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DotReplitGetResponse message.
             * @function verify
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DotReplitGetResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dotReplit != null && message.hasOwnProperty("dotReplit")) {
                    var error = $root.api.DotReplit.verify(message.dotReplit);
                    if (error)
                        return "dotReplit." + error;
                }
                return null;
            };
    
            /**
             * Creates a DotReplitGetResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DotReplitGetResponse} DotReplitGetResponse
             */
            DotReplitGetResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DotReplitGetResponse)
                    return object;
                var message = new $root.api.DotReplitGetResponse();
                if (object.dotReplit != null) {
                    if (typeof object.dotReplit !== "object")
                        throw TypeError(".api.DotReplitGetResponse.dotReplit: object expected");
                    message.dotReplit = $root.api.DotReplit.fromObject(object.dotReplit);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DotReplitGetResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DotReplitGetResponse
             * @static
             * @param {api.DotReplitGetResponse} message DotReplitGetResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DotReplitGetResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.dotReplit = null;
                if (message.dotReplit != null && message.hasOwnProperty("dotReplit"))
                    object.dotReplit = $root.api.DotReplit.toObject(message.dotReplit, options);
                return object;
            };
    
            /**
             * Converts this DotReplitGetResponse to JSON.
             * @function toJSON
             * @memberof api.DotReplitGetResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DotReplitGetResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DotReplitGetResponse;
        })();
    
        api.DebugAddBreakpointRequest = (function() {
    
            /**
             * Properties of a DebugAddBreakpointRequest.
             * @memberof api
             * @interface IDebugAddBreakpointRequest
             * @property {string|null} [path] DebugAddBreakpointRequest path
             * @property {number|null} [otVersion] DebugAddBreakpointRequest otVersion
             * @property {number|null} [otIndex] DebugAddBreakpointRequest otIndex
             * @property {number|null} [line] DebugAddBreakpointRequest line
             */
    
            /**
             * Constructs a new DebugAddBreakpointRequest.
             * @memberof api
             * @classdesc Represents a DebugAddBreakpointRequest.
             * @constructor
             * @param {api.IDebugAddBreakpointRequest=} [properties] Properties to set
             */
            function DebugAddBreakpointRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugAddBreakpointRequest path.
             * @member {string} path
             * @memberof api.DebugAddBreakpointRequest
             * @instance
             */
            DebugAddBreakpointRequest.prototype.path = "";
    
            /**
             * DebugAddBreakpointRequest otVersion.
             * @member {number} otVersion
             * @memberof api.DebugAddBreakpointRequest
             * @instance
             */
            DebugAddBreakpointRequest.prototype.otVersion = 0;
    
            /**
             * DebugAddBreakpointRequest otIndex.
             * @member {number} otIndex
             * @memberof api.DebugAddBreakpointRequest
             * @instance
             */
            DebugAddBreakpointRequest.prototype.otIndex = 0;
    
            /**
             * DebugAddBreakpointRequest line.
             * @member {number} line
             * @memberof api.DebugAddBreakpointRequest
             * @instance
             */
            DebugAddBreakpointRequest.prototype.line = 0;
    
            /**
             * Creates a new DebugAddBreakpointRequest instance using the specified properties.
             * @function create
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {api.IDebugAddBreakpointRequest=} [properties] Properties to set
             * @returns {api.DebugAddBreakpointRequest} DebugAddBreakpointRequest instance
             */
            DebugAddBreakpointRequest.create = function create(properties) {
                return DebugAddBreakpointRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugAddBreakpointRequest message. Does not implicitly {@link api.DebugAddBreakpointRequest.verify|verify} messages.
             * @function encode
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {api.DebugAddBreakpointRequest} message DebugAddBreakpointRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugAddBreakpointRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.otVersion != null && Object.hasOwnProperty.call(message, "otVersion"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.otVersion);
                if (message.otIndex != null && Object.hasOwnProperty.call(message, "otIndex"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.otIndex);
                if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.line);
                return writer;
            };
    
            /**
             * Encodes the specified DebugAddBreakpointRequest message, length delimited. Does not implicitly {@link api.DebugAddBreakpointRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {api.DebugAddBreakpointRequest} message DebugAddBreakpointRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugAddBreakpointRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugAddBreakpointRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugAddBreakpointRequest} DebugAddBreakpointRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugAddBreakpointRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugAddBreakpointRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.otVersion = reader.uint32();
                        break;
                    case 3:
                        message.otIndex = reader.uint32();
                        break;
                    case 4:
                        message.line = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugAddBreakpointRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugAddBreakpointRequest} DebugAddBreakpointRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugAddBreakpointRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugAddBreakpointRequest message.
             * @function verify
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugAddBreakpointRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.otVersion != null && message.hasOwnProperty("otVersion"))
                    if (!$util.isInteger(message.otVersion))
                        return "otVersion: integer expected";
                if (message.otIndex != null && message.hasOwnProperty("otIndex"))
                    if (!$util.isInteger(message.otIndex))
                        return "otIndex: integer expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                return null;
            };
    
            /**
             * Creates a DebugAddBreakpointRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugAddBreakpointRequest} DebugAddBreakpointRequest
             */
            DebugAddBreakpointRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugAddBreakpointRequest)
                    return object;
                var message = new $root.api.DebugAddBreakpointRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.otVersion != null)
                    message.otVersion = object.otVersion >>> 0;
                if (object.otIndex != null)
                    message.otIndex = object.otIndex >>> 0;
                if (object.line != null)
                    message.line = object.line | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a DebugAddBreakpointRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugAddBreakpointRequest
             * @static
             * @param {api.DebugAddBreakpointRequest} message DebugAddBreakpointRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugAddBreakpointRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.otVersion = 0;
                    object.otIndex = 0;
                    object.line = 0;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.otVersion != null && message.hasOwnProperty("otVersion"))
                    object.otVersion = message.otVersion;
                if (message.otIndex != null && message.hasOwnProperty("otIndex"))
                    object.otIndex = message.otIndex;
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                return object;
            };
    
            /**
             * Converts this DebugAddBreakpointRequest to JSON.
             * @function toJSON
             * @memberof api.DebugAddBreakpointRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugAddBreakpointRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugAddBreakpointRequest;
        })();
    
        api.DebugRemoveBreakpointRequest = (function() {
    
            /**
             * Properties of a DebugRemoveBreakpointRequest.
             * @memberof api
             * @interface IDebugRemoveBreakpointRequest
             * @property {string|null} [breakpointId] DebugRemoveBreakpointRequest breakpointId
             */
    
            /**
             * Constructs a new DebugRemoveBreakpointRequest.
             * @memberof api
             * @classdesc Represents a DebugRemoveBreakpointRequest.
             * @constructor
             * @param {api.IDebugRemoveBreakpointRequest=} [properties] Properties to set
             */
            function DebugRemoveBreakpointRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugRemoveBreakpointRequest breakpointId.
             * @member {string} breakpointId
             * @memberof api.DebugRemoveBreakpointRequest
             * @instance
             */
            DebugRemoveBreakpointRequest.prototype.breakpointId = "";
    
            /**
             * Creates a new DebugRemoveBreakpointRequest instance using the specified properties.
             * @function create
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {api.IDebugRemoveBreakpointRequest=} [properties] Properties to set
             * @returns {api.DebugRemoveBreakpointRequest} DebugRemoveBreakpointRequest instance
             */
            DebugRemoveBreakpointRequest.create = function create(properties) {
                return DebugRemoveBreakpointRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugRemoveBreakpointRequest message. Does not implicitly {@link api.DebugRemoveBreakpointRequest.verify|verify} messages.
             * @function encode
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {api.DebugRemoveBreakpointRequest} message DebugRemoveBreakpointRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugRemoveBreakpointRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.breakpointId != null && Object.hasOwnProperty.call(message, "breakpointId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.breakpointId);
                return writer;
            };
    
            /**
             * Encodes the specified DebugRemoveBreakpointRequest message, length delimited. Does not implicitly {@link api.DebugRemoveBreakpointRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {api.DebugRemoveBreakpointRequest} message DebugRemoveBreakpointRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugRemoveBreakpointRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugRemoveBreakpointRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugRemoveBreakpointRequest} DebugRemoveBreakpointRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugRemoveBreakpointRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugRemoveBreakpointRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.breakpointId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugRemoveBreakpointRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugRemoveBreakpointRequest} DebugRemoveBreakpointRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugRemoveBreakpointRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugRemoveBreakpointRequest message.
             * @function verify
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugRemoveBreakpointRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.breakpointId != null && message.hasOwnProperty("breakpointId"))
                    if (!$util.isString(message.breakpointId))
                        return "breakpointId: string expected";
                return null;
            };
    
            /**
             * Creates a DebugRemoveBreakpointRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugRemoveBreakpointRequest} DebugRemoveBreakpointRequest
             */
            DebugRemoveBreakpointRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugRemoveBreakpointRequest)
                    return object;
                var message = new $root.api.DebugRemoveBreakpointRequest();
                if (object.breakpointId != null)
                    message.breakpointId = String(object.breakpointId);
                return message;
            };
    
            /**
             * Creates a plain object from a DebugRemoveBreakpointRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugRemoveBreakpointRequest
             * @static
             * @param {api.DebugRemoveBreakpointRequest} message DebugRemoveBreakpointRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugRemoveBreakpointRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.breakpointId = "";
                if (message.breakpointId != null && message.hasOwnProperty("breakpointId"))
                    object.breakpointId = message.breakpointId;
                return object;
            };
    
            /**
             * Converts this DebugRemoveBreakpointRequest to JSON.
             * @function toJSON
             * @memberof api.DebugRemoveBreakpointRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugRemoveBreakpointRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugRemoveBreakpointRequest;
        })();
    
        api.DebugBreakpointEvent = (function() {
    
            /**
             * Properties of a DebugBreakpointEvent.
             * @memberof api
             * @interface IDebugBreakpointEvent
             * @property {string|null} [path] DebugBreakpointEvent path
             * @property {string|null} [absolutePath] DebugBreakpointEvent absolutePath
             * @property {Array.<api.DebugBreakpoint|api.IDebugBreakpoint>|null} [breakpoints] DebugBreakpointEvent breakpoints
             */
    
            /**
             * Constructs a new DebugBreakpointEvent.
             * @memberof api
             * @classdesc Represents a DebugBreakpointEvent.
             * @constructor
             * @param {api.IDebugBreakpointEvent=} [properties] Properties to set
             */
            function DebugBreakpointEvent(properties) {
                this.breakpoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugBreakpointEvent path.
             * @member {string} path
             * @memberof api.DebugBreakpointEvent
             * @instance
             */
            DebugBreakpointEvent.prototype.path = "";
    
            /**
             * DebugBreakpointEvent absolutePath.
             * @member {string} absolutePath
             * @memberof api.DebugBreakpointEvent
             * @instance
             */
            DebugBreakpointEvent.prototype.absolutePath = "";
    
            /**
             * DebugBreakpointEvent breakpoints.
             * @member {Array.<api.DebugBreakpoint>} breakpoints
             * @memberof api.DebugBreakpointEvent
             * @instance
             */
            DebugBreakpointEvent.prototype.breakpoints = $util.emptyArray;
    
            /**
             * Creates a new DebugBreakpointEvent instance using the specified properties.
             * @function create
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {api.IDebugBreakpointEvent=} [properties] Properties to set
             * @returns {api.DebugBreakpointEvent} DebugBreakpointEvent instance
             */
            DebugBreakpointEvent.create = function create(properties) {
                return DebugBreakpointEvent.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugBreakpointEvent message. Does not implicitly {@link api.DebugBreakpointEvent.verify|verify} messages.
             * @function encode
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {api.DebugBreakpointEvent} message DebugBreakpointEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugBreakpointEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.breakpoints != null && message.breakpoints.length)
                    for (var i = 0; i < message.breakpoints.length; ++i)
                        $root.api.DebugBreakpoint.encode(message.breakpoints[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.absolutePath != null && Object.hasOwnProperty.call(message, "absolutePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.absolutePath);
                return writer;
            };
    
            /**
             * Encodes the specified DebugBreakpointEvent message, length delimited. Does not implicitly {@link api.DebugBreakpointEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {api.DebugBreakpointEvent} message DebugBreakpointEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugBreakpointEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugBreakpointEvent message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugBreakpointEvent} DebugBreakpointEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugBreakpointEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugBreakpointEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 3:
                        message.absolutePath = reader.string();
                        break;
                    case 2:
                        if (!(message.breakpoints && message.breakpoints.length))
                            message.breakpoints = [];
                        message.breakpoints.push($root.api.DebugBreakpoint.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugBreakpointEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugBreakpointEvent} DebugBreakpointEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugBreakpointEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugBreakpointEvent message.
             * @function verify
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugBreakpointEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.absolutePath != null && message.hasOwnProperty("absolutePath"))
                    if (!$util.isString(message.absolutePath))
                        return "absolutePath: string expected";
                if (message.breakpoints != null && message.hasOwnProperty("breakpoints")) {
                    if (!Array.isArray(message.breakpoints))
                        return "breakpoints: array expected";
                    for (var i = 0; i < message.breakpoints.length; ++i) {
                        var error = $root.api.DebugBreakpoint.verify(message.breakpoints[i]);
                        if (error)
                            return "breakpoints." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DebugBreakpointEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugBreakpointEvent} DebugBreakpointEvent
             */
            DebugBreakpointEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugBreakpointEvent)
                    return object;
                var message = new $root.api.DebugBreakpointEvent();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.absolutePath != null)
                    message.absolutePath = String(object.absolutePath);
                if (object.breakpoints) {
                    if (!Array.isArray(object.breakpoints))
                        throw TypeError(".api.DebugBreakpointEvent.breakpoints: array expected");
                    message.breakpoints = [];
                    for (var i = 0; i < object.breakpoints.length; ++i) {
                        if (typeof object.breakpoints[i] !== "object")
                            throw TypeError(".api.DebugBreakpointEvent.breakpoints: object expected");
                        message.breakpoints[i] = $root.api.DebugBreakpoint.fromObject(object.breakpoints[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DebugBreakpointEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugBreakpointEvent
             * @static
             * @param {api.DebugBreakpointEvent} message DebugBreakpointEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugBreakpointEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.breakpoints = [];
                if (options.defaults) {
                    object.path = "";
                    object.absolutePath = "";
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.breakpoints && message.breakpoints.length) {
                    object.breakpoints = [];
                    for (var j = 0; j < message.breakpoints.length; ++j)
                        object.breakpoints[j] = $root.api.DebugBreakpoint.toObject(message.breakpoints[j], options);
                }
                if (message.absolutePath != null && message.hasOwnProperty("absolutePath"))
                    object.absolutePath = message.absolutePath;
                return object;
            };
    
            /**
             * Converts this DebugBreakpointEvent to JSON.
             * @function toJSON
             * @memberof api.DebugBreakpointEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugBreakpointEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugBreakpointEvent;
        })();
    
        api.DebugBreakpoint = (function() {
    
            /**
             * Properties of a DebugBreakpoint.
             * @memberof api
             * @interface IDebugBreakpoint
             * @property {string|null} [breakpointId] DebugBreakpoint breakpointId
             * @property {number|null} [line] DebugBreakpoint line
             * @property {number|null} [otVersion] DebugBreakpoint otVersion
             * @property {number|null} [otIndex] DebugBreakpoint otIndex
             */
    
            /**
             * Constructs a new DebugBreakpoint.
             * @memberof api
             * @classdesc Represents a DebugBreakpoint.
             * @constructor
             * @param {api.IDebugBreakpoint=} [properties] Properties to set
             */
            function DebugBreakpoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebugBreakpoint breakpointId.
             * @member {string} breakpointId
             * @memberof api.DebugBreakpoint
             * @instance
             */
            DebugBreakpoint.prototype.breakpointId = "";
    
            /**
             * DebugBreakpoint line.
             * @member {number} line
             * @memberof api.DebugBreakpoint
             * @instance
             */
            DebugBreakpoint.prototype.line = 0;
    
            /**
             * DebugBreakpoint otVersion.
             * @member {number} otVersion
             * @memberof api.DebugBreakpoint
             * @instance
             */
            DebugBreakpoint.prototype.otVersion = 0;
    
            /**
             * DebugBreakpoint otIndex.
             * @member {number} otIndex
             * @memberof api.DebugBreakpoint
             * @instance
             */
            DebugBreakpoint.prototype.otIndex = 0;
    
            /**
             * Creates a new DebugBreakpoint instance using the specified properties.
             * @function create
             * @memberof api.DebugBreakpoint
             * @static
             * @param {api.IDebugBreakpoint=} [properties] Properties to set
             * @returns {api.DebugBreakpoint} DebugBreakpoint instance
             */
            DebugBreakpoint.create = function create(properties) {
                return DebugBreakpoint.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebugBreakpoint message. Does not implicitly {@link api.DebugBreakpoint.verify|verify} messages.
             * @function encode
             * @memberof api.DebugBreakpoint
             * @static
             * @param {api.DebugBreakpoint} message DebugBreakpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugBreakpoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.breakpointId != null && Object.hasOwnProperty.call(message, "breakpointId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.breakpointId);
                if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.line);
                if (message.otVersion != null && Object.hasOwnProperty.call(message, "otVersion"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.otVersion);
                if (message.otIndex != null && Object.hasOwnProperty.call(message, "otIndex"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.otIndex);
                return writer;
            };
    
            /**
             * Encodes the specified DebugBreakpoint message, length delimited. Does not implicitly {@link api.DebugBreakpoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebugBreakpoint
             * @static
             * @param {api.DebugBreakpoint} message DebugBreakpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugBreakpoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebugBreakpoint message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebugBreakpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebugBreakpoint} DebugBreakpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugBreakpoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebugBreakpoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.breakpointId = reader.string();
                        break;
                    case 2:
                        message.line = reader.int32();
                        break;
                    case 3:
                        message.otVersion = reader.uint32();
                        break;
                    case 4:
                        message.otIndex = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebugBreakpoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebugBreakpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebugBreakpoint} DebugBreakpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugBreakpoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebugBreakpoint message.
             * @function verify
             * @memberof api.DebugBreakpoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugBreakpoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.breakpointId != null && message.hasOwnProperty("breakpointId"))
                    if (!$util.isString(message.breakpointId))
                        return "breakpointId: string expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                if (message.otVersion != null && message.hasOwnProperty("otVersion"))
                    if (!$util.isInteger(message.otVersion))
                        return "otVersion: integer expected";
                if (message.otIndex != null && message.hasOwnProperty("otIndex"))
                    if (!$util.isInteger(message.otIndex))
                        return "otIndex: integer expected";
                return null;
            };
    
            /**
             * Creates a DebugBreakpoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebugBreakpoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebugBreakpoint} DebugBreakpoint
             */
            DebugBreakpoint.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebugBreakpoint)
                    return object;
                var message = new $root.api.DebugBreakpoint();
                if (object.breakpointId != null)
                    message.breakpointId = String(object.breakpointId);
                if (object.line != null)
                    message.line = object.line | 0;
                if (object.otVersion != null)
                    message.otVersion = object.otVersion >>> 0;
                if (object.otIndex != null)
                    message.otIndex = object.otIndex >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a DebugBreakpoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebugBreakpoint
             * @static
             * @param {api.DebugBreakpoint} message DebugBreakpoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugBreakpoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.breakpointId = "";
                    object.line = 0;
                    object.otVersion = 0;
                    object.otIndex = 0;
                }
                if (message.breakpointId != null && message.hasOwnProperty("breakpointId"))
                    object.breakpointId = message.breakpointId;
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                if (message.otVersion != null && message.hasOwnProperty("otVersion"))
                    object.otVersion = message.otVersion;
                if (message.otIndex != null && message.hasOwnProperty("otIndex"))
                    object.otIndex = message.otIndex;
                return object;
            };
    
            /**
             * Converts this DebugBreakpoint to JSON.
             * @function toJSON
             * @memberof api.DebugBreakpoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugBreakpoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebugBreakpoint;
        })();
    
        api.DotReplit = (function() {
    
            /**
             * Properties of a DotReplit.
             * @memberof api
             * @interface IDotReplit
             * @property {api.Exec|api.IExec|null} [run] DotReplit run
             * @property {api.Exec|api.IExec|null} [compile] DotReplit compile
             * @property {api.DebuggerConfig|api.IDebuggerConfig|null} ["debugger"] DotReplit debugger
             * @property {string|null} [language] DotReplit language
             * @property {api.Exec|api.IExec|null} [onBoot] DotReplit onBoot
             * @property {api.DotReplitPackager|api.IDotReplitPackager|null} [packager] DotReplit packager
             * @property {api.DotReplitInterp|api.IDotReplitInterp|null} [interpreter] DotReplit interpreter
             * @property {string|null} [entrypoint] DotReplit entrypoint
             */
    
            /**
             * Constructs a new DotReplit.
             * @memberof api
             * @classdesc Represents a DotReplit.
             * @constructor
             * @param {api.IDotReplit=} [properties] Properties to set
             */
            function DotReplit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DotReplit run.
             * @member {api.Exec|null|undefined} run
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype.run = null;
    
            /**
             * DotReplit compile.
             * @member {api.Exec|null|undefined} compile
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype.compile = null;
    
            /**
             * DotReplit debugger.
             * @member {api.DebuggerConfig|null|undefined} debugger
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype["debugger"] = null;
    
            /**
             * DotReplit language.
             * @member {string} language
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype.language = "";
    
            /**
             * DotReplit onBoot.
             * @member {api.Exec|null|undefined} onBoot
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype.onBoot = null;
    
            /**
             * DotReplit packager.
             * @member {api.DotReplitPackager|null|undefined} packager
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype.packager = null;
    
            /**
             * DotReplit interpreter.
             * @member {api.DotReplitInterp|null|undefined} interpreter
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype.interpreter = null;
    
            /**
             * DotReplit entrypoint.
             * @member {string} entrypoint
             * @memberof api.DotReplit
             * @instance
             */
            DotReplit.prototype.entrypoint = "";
    
            /**
             * Creates a new DotReplit instance using the specified properties.
             * @function create
             * @memberof api.DotReplit
             * @static
             * @param {api.IDotReplit=} [properties] Properties to set
             * @returns {api.DotReplit} DotReplit instance
             */
            DotReplit.create = function create(properties) {
                return DotReplit.fromObject(properties);
            };
    
            /**
             * Encodes the specified DotReplit message. Does not implicitly {@link api.DotReplit.verify|verify} messages.
             * @function encode
             * @memberof api.DotReplit
             * @static
             * @param {api.DotReplit} message DotReplit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.run != null && Object.hasOwnProperty.call(message, "run"))
                    $root.api.Exec.encode(message.run, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.compile != null && Object.hasOwnProperty.call(message, "compile"))
                    $root.api.Exec.encode(message.compile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message["debugger"] != null && Object.hasOwnProperty.call(message, "debugger"))
                    $root.api.DebuggerConfig.encode(message["debugger"], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.language);
                if (message.onBoot != null && Object.hasOwnProperty.call(message, "onBoot"))
                    $root.api.Exec.encode(message.onBoot, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.packager != null && Object.hasOwnProperty.call(message, "packager"))
                    $root.api.DotReplitPackager.encode(message.packager, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.interpreter != null && Object.hasOwnProperty.call(message, "interpreter"))
                    $root.api.DotReplitInterp.encode(message.interpreter, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.entrypoint != null && Object.hasOwnProperty.call(message, "entrypoint"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.entrypoint);
                return writer;
            };
    
            /**
             * Encodes the specified DotReplit message, length delimited. Does not implicitly {@link api.DotReplit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DotReplit
             * @static
             * @param {api.DotReplit} message DotReplit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DotReplit message from the specified reader or buffer.
             * @function decode
             * @memberof api.DotReplit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DotReplit} DotReplit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DotReplit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.run = $root.api.Exec.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.compile = $root.api.Exec.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message["debugger"] = $root.api.DebuggerConfig.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.language = reader.string();
                        break;
                    case 5:
                        message.onBoot = $root.api.Exec.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.packager = $root.api.DotReplitPackager.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.interpreter = $root.api.DotReplitInterp.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.entrypoint = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DotReplit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DotReplit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DotReplit} DotReplit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DotReplit message.
             * @function verify
             * @memberof api.DotReplit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DotReplit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.run != null && message.hasOwnProperty("run")) {
                    var error = $root.api.Exec.verify(message.run);
                    if (error)
                        return "run." + error;
                }
                if (message.compile != null && message.hasOwnProperty("compile")) {
                    var error = $root.api.Exec.verify(message.compile);
                    if (error)
                        return "compile." + error;
                }
                if (message["debugger"] != null && message.hasOwnProperty("debugger")) {
                    var error = $root.api.DebuggerConfig.verify(message["debugger"]);
                    if (error)
                        return "debugger." + error;
                }
                if (message.language != null && message.hasOwnProperty("language"))
                    if (!$util.isString(message.language))
                        return "language: string expected";
                if (message.onBoot != null && message.hasOwnProperty("onBoot")) {
                    var error = $root.api.Exec.verify(message.onBoot);
                    if (error)
                        return "onBoot." + error;
                }
                if (message.packager != null && message.hasOwnProperty("packager")) {
                    var error = $root.api.DotReplitPackager.verify(message.packager);
                    if (error)
                        return "packager." + error;
                }
                if (message.interpreter != null && message.hasOwnProperty("interpreter")) {
                    var error = $root.api.DotReplitInterp.verify(message.interpreter);
                    if (error)
                        return "interpreter." + error;
                }
                if (message.entrypoint != null && message.hasOwnProperty("entrypoint"))
                    if (!$util.isString(message.entrypoint))
                        return "entrypoint: string expected";
                return null;
            };
    
            /**
             * Creates a DotReplit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DotReplit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DotReplit} DotReplit
             */
            DotReplit.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DotReplit)
                    return object;
                var message = new $root.api.DotReplit();
                if (object.run != null) {
                    if (typeof object.run !== "object")
                        throw TypeError(".api.DotReplit.run: object expected");
                    message.run = $root.api.Exec.fromObject(object.run);
                }
                if (object.compile != null) {
                    if (typeof object.compile !== "object")
                        throw TypeError(".api.DotReplit.compile: object expected");
                    message.compile = $root.api.Exec.fromObject(object.compile);
                }
                if (object["debugger"] != null) {
                    if (typeof object["debugger"] !== "object")
                        throw TypeError(".api.DotReplit.debugger: object expected");
                    message["debugger"] = $root.api.DebuggerConfig.fromObject(object["debugger"]);
                }
                if (object.language != null)
                    message.language = String(object.language);
                if (object.onBoot != null) {
                    if (typeof object.onBoot !== "object")
                        throw TypeError(".api.DotReplit.onBoot: object expected");
                    message.onBoot = $root.api.Exec.fromObject(object.onBoot);
                }
                if (object.packager != null) {
                    if (typeof object.packager !== "object")
                        throw TypeError(".api.DotReplit.packager: object expected");
                    message.packager = $root.api.DotReplitPackager.fromObject(object.packager);
                }
                if (object.interpreter != null) {
                    if (typeof object.interpreter !== "object")
                        throw TypeError(".api.DotReplit.interpreter: object expected");
                    message.interpreter = $root.api.DotReplitInterp.fromObject(object.interpreter);
                }
                if (object.entrypoint != null)
                    message.entrypoint = String(object.entrypoint);
                return message;
            };
    
            /**
             * Creates a plain object from a DotReplit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DotReplit
             * @static
             * @param {api.DotReplit} message DotReplit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DotReplit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.run = null;
                    object.compile = null;
                    object["debugger"] = null;
                    object.language = "";
                    object.onBoot = null;
                    object.packager = null;
                    object.interpreter = null;
                    object.entrypoint = "";
                }
                if (message.run != null && message.hasOwnProperty("run"))
                    object.run = $root.api.Exec.toObject(message.run, options);
                if (message.compile != null && message.hasOwnProperty("compile"))
                    object.compile = $root.api.Exec.toObject(message.compile, options);
                if (message["debugger"] != null && message.hasOwnProperty("debugger"))
                    object["debugger"] = $root.api.DebuggerConfig.toObject(message["debugger"], options);
                if (message.language != null && message.hasOwnProperty("language"))
                    object.language = message.language;
                if (message.onBoot != null && message.hasOwnProperty("onBoot"))
                    object.onBoot = $root.api.Exec.toObject(message.onBoot, options);
                if (message.packager != null && message.hasOwnProperty("packager"))
                    object.packager = $root.api.DotReplitPackager.toObject(message.packager, options);
                if (message.interpreter != null && message.hasOwnProperty("interpreter"))
                    object.interpreter = $root.api.DotReplitInterp.toObject(message.interpreter, options);
                if (message.entrypoint != null && message.hasOwnProperty("entrypoint"))
                    object.entrypoint = message.entrypoint;
                return object;
            };
    
            /**
             * Converts this DotReplit to JSON.
             * @function toJSON
             * @memberof api.DotReplit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DotReplit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DotReplit;
        })();
    
        api.DotReplitInterp = (function() {
    
            /**
             * Properties of a DotReplitInterp.
             * @memberof api
             * @interface IDotReplitInterp
             * @property {api.Exec|api.IExec|null} [command] DotReplitInterp command
             * @property {Uint8Array|null} [prompt] DotReplitInterp prompt
             */
    
            /**
             * Constructs a new DotReplitInterp.
             * @memberof api
             * @classdesc Represents a DotReplitInterp.
             * @constructor
             * @param {api.IDotReplitInterp=} [properties] Properties to set
             */
            function DotReplitInterp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DotReplitInterp command.
             * @member {api.Exec|null|undefined} command
             * @memberof api.DotReplitInterp
             * @instance
             */
            DotReplitInterp.prototype.command = null;
    
            /**
             * DotReplitInterp prompt.
             * @member {Uint8Array} prompt
             * @memberof api.DotReplitInterp
             * @instance
             */
            DotReplitInterp.prototype.prompt = $util.newBuffer([]);
    
            /**
             * Creates a new DotReplitInterp instance using the specified properties.
             * @function create
             * @memberof api.DotReplitInterp
             * @static
             * @param {api.IDotReplitInterp=} [properties] Properties to set
             * @returns {api.DotReplitInterp} DotReplitInterp instance
             */
            DotReplitInterp.create = function create(properties) {
                return DotReplitInterp.fromObject(properties);
            };
    
            /**
             * Encodes the specified DotReplitInterp message. Does not implicitly {@link api.DotReplitInterp.verify|verify} messages.
             * @function encode
             * @memberof api.DotReplitInterp
             * @static
             * @param {api.DotReplitInterp} message DotReplitInterp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitInterp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.api.Exec.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.prompt != null && Object.hasOwnProperty.call(message, "prompt"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prompt);
                return writer;
            };
    
            /**
             * Encodes the specified DotReplitInterp message, length delimited. Does not implicitly {@link api.DotReplitInterp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DotReplitInterp
             * @static
             * @param {api.DotReplitInterp} message DotReplitInterp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitInterp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DotReplitInterp message from the specified reader or buffer.
             * @function decode
             * @memberof api.DotReplitInterp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DotReplitInterp} DotReplitInterp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitInterp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DotReplitInterp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.api.Exec.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.prompt = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DotReplitInterp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DotReplitInterp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DotReplitInterp} DotReplitInterp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitInterp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DotReplitInterp message.
             * @function verify
             * @memberof api.DotReplitInterp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DotReplitInterp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.command != null && message.hasOwnProperty("command")) {
                    var error = $root.api.Exec.verify(message.command);
                    if (error)
                        return "command." + error;
                }
                if (message.prompt != null && message.hasOwnProperty("prompt"))
                    if (!(message.prompt && typeof message.prompt.length === "number" || $util.isString(message.prompt)))
                        return "prompt: buffer expected";
                return null;
            };
    
            /**
             * Creates a DotReplitInterp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DotReplitInterp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DotReplitInterp} DotReplitInterp
             */
            DotReplitInterp.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DotReplitInterp)
                    return object;
                var message = new $root.api.DotReplitInterp();
                if (object.command != null) {
                    if (typeof object.command !== "object")
                        throw TypeError(".api.DotReplitInterp.command: object expected");
                    message.command = $root.api.Exec.fromObject(object.command);
                }
                if (object.prompt != null)
                    if (typeof object.prompt === "string")
                        $util.base64.decode(object.prompt, message.prompt = $util.newBuffer($util.base64.length(object.prompt)), 0);
                    else if (object.prompt.length)
                        message.prompt = object.prompt;
                return message;
            };
    
            /**
             * Creates a plain object from a DotReplitInterp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DotReplitInterp
             * @static
             * @param {api.DotReplitInterp} message DotReplitInterp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DotReplitInterp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.command = null;
                    if (options.bytes === String)
                        object.prompt = "";
                    else {
                        object.prompt = [];
                        if (options.bytes !== Array)
                            object.prompt = $util.newBuffer(object.prompt);
                    }
                }
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = $root.api.Exec.toObject(message.command, options);
                if (message.prompt != null && message.hasOwnProperty("prompt"))
                    object.prompt = options.bytes === String ? $util.base64.encode(message.prompt, 0, message.prompt.length) : options.bytes === Array ? Array.prototype.slice.call(message.prompt) : message.prompt;
                return object;
            };
    
            /**
             * Converts this DotReplitInterp to JSON.
             * @function toJSON
             * @memberof api.DotReplitInterp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DotReplitInterp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DotReplitInterp;
        })();
    
        api.DotReplitPackager = (function() {
    
            /**
             * Properties of a DotReplitPackager.
             * @memberof api
             * @interface IDotReplitPackager
             * @property {api.Exec|api.IExec|null} [afterInstall] DotReplitPackager afterInstall
             * @property {string|null} [language] DotReplitPackager language
             * @property {api.DotReplitPackagerFeatures|api.IDotReplitPackagerFeatures|null} [features] DotReplitPackager features
             * @property {Object.<string,string>|null} [env] DotReplitPackager env
             * @property {Array.<string>|null} [ignoredPaths] DotReplitPackager ignoredPaths
             * @property {Array.<string>|null} [ignoredPackages] DotReplitPackager ignoredPackages
             */
    
            /**
             * Constructs a new DotReplitPackager.
             * @memberof api
             * @classdesc Represents a DotReplitPackager.
             * @constructor
             * @param {api.IDotReplitPackager=} [properties] Properties to set
             */
            function DotReplitPackager(properties) {
                this.env = {};
                this.ignoredPaths = [];
                this.ignoredPackages = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DotReplitPackager afterInstall.
             * @member {api.Exec|null|undefined} afterInstall
             * @memberof api.DotReplitPackager
             * @instance
             */
            DotReplitPackager.prototype.afterInstall = null;
    
            /**
             * DotReplitPackager language.
             * @member {string} language
             * @memberof api.DotReplitPackager
             * @instance
             */
            DotReplitPackager.prototype.language = "";
    
            /**
             * DotReplitPackager features.
             * @member {api.DotReplitPackagerFeatures|null|undefined} features
             * @memberof api.DotReplitPackager
             * @instance
             */
            DotReplitPackager.prototype.features = null;
    
            /**
             * DotReplitPackager env.
             * @member {Object.<string,string>} env
             * @memberof api.DotReplitPackager
             * @instance
             */
            DotReplitPackager.prototype.env = $util.emptyObject;
    
            /**
             * DotReplitPackager ignoredPaths.
             * @member {Array.<string>} ignoredPaths
             * @memberof api.DotReplitPackager
             * @instance
             */
            DotReplitPackager.prototype.ignoredPaths = $util.emptyArray;
    
            /**
             * DotReplitPackager ignoredPackages.
             * @member {Array.<string>} ignoredPackages
             * @memberof api.DotReplitPackager
             * @instance
             */
            DotReplitPackager.prototype.ignoredPackages = $util.emptyArray;
    
            /**
             * Creates a new DotReplitPackager instance using the specified properties.
             * @function create
             * @memberof api.DotReplitPackager
             * @static
             * @param {api.IDotReplitPackager=} [properties] Properties to set
             * @returns {api.DotReplitPackager} DotReplitPackager instance
             */
            DotReplitPackager.create = function create(properties) {
                return DotReplitPackager.fromObject(properties);
            };
    
            /**
             * Encodes the specified DotReplitPackager message. Does not implicitly {@link api.DotReplitPackager.verify|verify} messages.
             * @function encode
             * @memberof api.DotReplitPackager
             * @static
             * @param {api.DotReplitPackager} message DotReplitPackager message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitPackager.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.afterInstall != null && Object.hasOwnProperty.call(message, "afterInstall"))
                    $root.api.Exec.encode(message.afterInstall, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.ignoredPaths != null && message.ignoredPaths.length)
                    for (var i = 0; i < message.ignoredPaths.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ignoredPaths[i]);
                if (message.ignoredPackages != null && message.ignoredPackages.length)
                    for (var i = 0; i < message.ignoredPackages.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.ignoredPackages[i]);
                if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.language);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.api.DotReplitPackagerFeatures.encode(message.features, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.env != null && Object.hasOwnProperty.call(message, "env"))
                    for (var keys = Object.keys(message.env), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.env[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DotReplitPackager message, length delimited. Does not implicitly {@link api.DotReplitPackager.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DotReplitPackager
             * @static
             * @param {api.DotReplitPackager} message DotReplitPackager message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitPackager.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DotReplitPackager message from the specified reader or buffer.
             * @function decode
             * @memberof api.DotReplitPackager
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DotReplitPackager} DotReplitPackager
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitPackager.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DotReplitPackager(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.afterInstall = $root.api.Exec.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.language = reader.string();
                        break;
                    case 5:
                        message.features = $root.api.DotReplitPackagerFeatures.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (message.env === $util.emptyObject)
                            message.env = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.env[key] = value;
                        break;
                    case 2:
                        if (!(message.ignoredPaths && message.ignoredPaths.length))
                            message.ignoredPaths = [];
                        message.ignoredPaths.push(reader.string());
                        break;
                    case 3:
                        if (!(message.ignoredPackages && message.ignoredPackages.length))
                            message.ignoredPackages = [];
                        message.ignoredPackages.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DotReplitPackager message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DotReplitPackager
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DotReplitPackager} DotReplitPackager
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitPackager.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DotReplitPackager message.
             * @function verify
             * @memberof api.DotReplitPackager
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DotReplitPackager.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.afterInstall != null && message.hasOwnProperty("afterInstall")) {
                    var error = $root.api.Exec.verify(message.afterInstall);
                    if (error)
                        return "afterInstall." + error;
                }
                if (message.language != null && message.hasOwnProperty("language"))
                    if (!$util.isString(message.language))
                        return "language: string expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    var error = $root.api.DotReplitPackagerFeatures.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.env != null && message.hasOwnProperty("env")) {
                    if (!$util.isObject(message.env))
                        return "env: object expected";
                    var key = Object.keys(message.env);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.env[key[i]]))
                            return "env: string{k:string} expected";
                }
                if (message.ignoredPaths != null && message.hasOwnProperty("ignoredPaths")) {
                    if (!Array.isArray(message.ignoredPaths))
                        return "ignoredPaths: array expected";
                    for (var i = 0; i < message.ignoredPaths.length; ++i)
                        if (!$util.isString(message.ignoredPaths[i]))
                            return "ignoredPaths: string[] expected";
                }
                if (message.ignoredPackages != null && message.hasOwnProperty("ignoredPackages")) {
                    if (!Array.isArray(message.ignoredPackages))
                        return "ignoredPackages: array expected";
                    for (var i = 0; i < message.ignoredPackages.length; ++i)
                        if (!$util.isString(message.ignoredPackages[i]))
                            return "ignoredPackages: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a DotReplitPackager message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DotReplitPackager
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DotReplitPackager} DotReplitPackager
             */
            DotReplitPackager.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DotReplitPackager)
                    return object;
                var message = new $root.api.DotReplitPackager();
                if (object.afterInstall != null) {
                    if (typeof object.afterInstall !== "object")
                        throw TypeError(".api.DotReplitPackager.afterInstall: object expected");
                    message.afterInstall = $root.api.Exec.fromObject(object.afterInstall);
                }
                if (object.language != null)
                    message.language = String(object.language);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".api.DotReplitPackager.features: object expected");
                    message.features = $root.api.DotReplitPackagerFeatures.fromObject(object.features);
                }
                if (object.env) {
                    if (typeof object.env !== "object")
                        throw TypeError(".api.DotReplitPackager.env: object expected");
                    message.env = {};
                    for (var keys = Object.keys(object.env), i = 0; i < keys.length; ++i)
                        message.env[keys[i]] = String(object.env[keys[i]]);
                }
                if (object.ignoredPaths) {
                    if (!Array.isArray(object.ignoredPaths))
                        throw TypeError(".api.DotReplitPackager.ignoredPaths: array expected");
                    message.ignoredPaths = [];
                    for (var i = 0; i < object.ignoredPaths.length; ++i)
                        message.ignoredPaths[i] = String(object.ignoredPaths[i]);
                }
                if (object.ignoredPackages) {
                    if (!Array.isArray(object.ignoredPackages))
                        throw TypeError(".api.DotReplitPackager.ignoredPackages: array expected");
                    message.ignoredPackages = [];
                    for (var i = 0; i < object.ignoredPackages.length; ++i)
                        message.ignoredPackages[i] = String(object.ignoredPackages[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DotReplitPackager message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DotReplitPackager
             * @static
             * @param {api.DotReplitPackager} message DotReplitPackager
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DotReplitPackager.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.ignoredPaths = [];
                    object.ignoredPackages = [];
                }
                if (options.objects || options.defaults)
                    object.env = {};
                if (options.defaults) {
                    object.afterInstall = null;
                    object.language = "";
                    object.features = null;
                }
                if (message.afterInstall != null && message.hasOwnProperty("afterInstall"))
                    object.afterInstall = $root.api.Exec.toObject(message.afterInstall, options);
                if (message.ignoredPaths && message.ignoredPaths.length) {
                    object.ignoredPaths = [];
                    for (var j = 0; j < message.ignoredPaths.length; ++j)
                        object.ignoredPaths[j] = message.ignoredPaths[j];
                }
                if (message.ignoredPackages && message.ignoredPackages.length) {
                    object.ignoredPackages = [];
                    for (var j = 0; j < message.ignoredPackages.length; ++j)
                        object.ignoredPackages[j] = message.ignoredPackages[j];
                }
                if (message.language != null && message.hasOwnProperty("language"))
                    object.language = message.language;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.api.DotReplitPackagerFeatures.toObject(message.features, options);
                var keys2;
                if (message.env && (keys2 = Object.keys(message.env)).length) {
                    object.env = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.env[keys2[j]] = message.env[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this DotReplitPackager to JSON.
             * @function toJSON
             * @memberof api.DotReplitPackager
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DotReplitPackager.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DotReplitPackager;
        })();
    
        api.DotReplitPackagerFeatures = (function() {
    
            /**
             * Properties of a DotReplitPackagerFeatures.
             * @memberof api
             * @interface IDotReplitPackagerFeatures
             * @property {boolean|null} [packageSearch] DotReplitPackagerFeatures packageSearch
             * @property {boolean|null} [guessImports] DotReplitPackagerFeatures guessImports
             */
    
            /**
             * Constructs a new DotReplitPackagerFeatures.
             * @memberof api
             * @classdesc Represents a DotReplitPackagerFeatures.
             * @constructor
             * @param {api.IDotReplitPackagerFeatures=} [properties] Properties to set
             */
            function DotReplitPackagerFeatures(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DotReplitPackagerFeatures packageSearch.
             * @member {boolean} packageSearch
             * @memberof api.DotReplitPackagerFeatures
             * @instance
             */
            DotReplitPackagerFeatures.prototype.packageSearch = false;
    
            /**
             * DotReplitPackagerFeatures guessImports.
             * @member {boolean} guessImports
             * @memberof api.DotReplitPackagerFeatures
             * @instance
             */
            DotReplitPackagerFeatures.prototype.guessImports = false;
    
            /**
             * Creates a new DotReplitPackagerFeatures instance using the specified properties.
             * @function create
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {api.IDotReplitPackagerFeatures=} [properties] Properties to set
             * @returns {api.DotReplitPackagerFeatures} DotReplitPackagerFeatures instance
             */
            DotReplitPackagerFeatures.create = function create(properties) {
                return DotReplitPackagerFeatures.fromObject(properties);
            };
    
            /**
             * Encodes the specified DotReplitPackagerFeatures message. Does not implicitly {@link api.DotReplitPackagerFeatures.verify|verify} messages.
             * @function encode
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {api.DotReplitPackagerFeatures} message DotReplitPackagerFeatures message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitPackagerFeatures.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packageSearch != null && Object.hasOwnProperty.call(message, "packageSearch"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.packageSearch);
                if (message.guessImports != null && Object.hasOwnProperty.call(message, "guessImports"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.guessImports);
                return writer;
            };
    
            /**
             * Encodes the specified DotReplitPackagerFeatures message, length delimited. Does not implicitly {@link api.DotReplitPackagerFeatures.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {api.DotReplitPackagerFeatures} message DotReplitPackagerFeatures message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotReplitPackagerFeatures.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DotReplitPackagerFeatures message from the specified reader or buffer.
             * @function decode
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DotReplitPackagerFeatures} DotReplitPackagerFeatures
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitPackagerFeatures.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DotReplitPackagerFeatures();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.packageSearch = reader.bool();
                        break;
                    case 2:
                        message.guessImports = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DotReplitPackagerFeatures message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DotReplitPackagerFeatures} DotReplitPackagerFeatures
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotReplitPackagerFeatures.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DotReplitPackagerFeatures message.
             * @function verify
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DotReplitPackagerFeatures.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packageSearch != null && message.hasOwnProperty("packageSearch"))
                    if (typeof message.packageSearch !== "boolean")
                        return "packageSearch: boolean expected";
                if (message.guessImports != null && message.hasOwnProperty("guessImports"))
                    if (typeof message.guessImports !== "boolean")
                        return "guessImports: boolean expected";
                return null;
            };
    
            /**
             * Creates a DotReplitPackagerFeatures message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DotReplitPackagerFeatures} DotReplitPackagerFeatures
             */
            DotReplitPackagerFeatures.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DotReplitPackagerFeatures)
                    return object;
                var message = new $root.api.DotReplitPackagerFeatures();
                if (object.packageSearch != null)
                    message.packageSearch = Boolean(object.packageSearch);
                if (object.guessImports != null)
                    message.guessImports = Boolean(object.guessImports);
                return message;
            };
    
            /**
             * Creates a plain object from a DotReplitPackagerFeatures message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DotReplitPackagerFeatures
             * @static
             * @param {api.DotReplitPackagerFeatures} message DotReplitPackagerFeatures
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DotReplitPackagerFeatures.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.packageSearch = false;
                    object.guessImports = false;
                }
                if (message.packageSearch != null && message.hasOwnProperty("packageSearch"))
                    object.packageSearch = message.packageSearch;
                if (message.guessImports != null && message.hasOwnProperty("guessImports"))
                    object.guessImports = message.guessImports;
                return object;
            };
    
            /**
             * Converts this DotReplitPackagerFeatures to JSON.
             * @function toJSON
             * @memberof api.DotReplitPackagerFeatures
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DotReplitPackagerFeatures.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DotReplitPackagerFeatures;
        })();
    
        api.DebuggerConfig = (function() {
    
            /**
             * Properties of a DebuggerConfig.
             * @memberof api
             * @interface IDebuggerConfig
             * @property {boolean|null} [support] DebuggerConfig support
             */
    
            /**
             * Constructs a new DebuggerConfig.
             * @memberof api
             * @classdesc Represents a DebuggerConfig.
             * @constructor
             * @param {api.IDebuggerConfig=} [properties] Properties to set
             */
            function DebuggerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DebuggerConfig support.
             * @member {boolean} support
             * @memberof api.DebuggerConfig
             * @instance
             */
            DebuggerConfig.prototype.support = false;
    
            /**
             * Creates a new DebuggerConfig instance using the specified properties.
             * @function create
             * @memberof api.DebuggerConfig
             * @static
             * @param {api.IDebuggerConfig=} [properties] Properties to set
             * @returns {api.DebuggerConfig} DebuggerConfig instance
             */
            DebuggerConfig.create = function create(properties) {
                return DebuggerConfig.fromObject(properties);
            };
    
            /**
             * Encodes the specified DebuggerConfig message. Does not implicitly {@link api.DebuggerConfig.verify|verify} messages.
             * @function encode
             * @memberof api.DebuggerConfig
             * @static
             * @param {api.DebuggerConfig} message DebuggerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebuggerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.support);
                return writer;
            };
    
            /**
             * Encodes the specified DebuggerConfig message, length delimited. Does not implicitly {@link api.DebuggerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.DebuggerConfig
             * @static
             * @param {api.DebuggerConfig} message DebuggerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebuggerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DebuggerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof api.DebuggerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.DebuggerConfig} DebuggerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebuggerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.DebuggerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.support = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DebuggerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.DebuggerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.DebuggerConfig} DebuggerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebuggerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DebuggerConfig message.
             * @function verify
             * @memberof api.DebuggerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebuggerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.support != null && message.hasOwnProperty("support"))
                    if (typeof message.support !== "boolean")
                        return "support: boolean expected";
                return null;
            };
    
            /**
             * Creates a DebuggerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.DebuggerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.DebuggerConfig} DebuggerConfig
             */
            DebuggerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.api.DebuggerConfig)
                    return object;
                var message = new $root.api.DebuggerConfig();
                if (object.support != null)
                    message.support = Boolean(object.support);
                return message;
            };
    
            /**
             * Creates a plain object from a DebuggerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.DebuggerConfig
             * @static
             * @param {api.DebuggerConfig} message DebuggerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebuggerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.support = false;
                if (message.support != null && message.hasOwnProperty("support"))
                    object.support = message.support;
                return object;
            };
    
            /**
             * Converts this DebuggerConfig to JSON.
             * @function toJSON
             * @memberof api.DebuggerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebuggerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DebuggerConfig;
        })();
    
        api.Repl = (function() {
    
            /**
             * Properties of a Repl.
             * @memberof api
             * @interface IRepl
             * @property {string|null} [id] Repl id
             * @property {string|null} [language] Repl language
             * @property {string|null} [bucket] Repl bucket
             * @property {string|null} [slug] Repl slug
             * @property {string|null} [user] Repl user
             * @property {string|null} [sourceRepl] Repl sourceRepl
             */
    
            /**
             * Constructs a new Repl.
             * @memberof api
             * @classdesc Represents a Repl.
             * @constructor
             * @param {api.IRepl=} [properties] Properties to set
             */
            function Repl(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Repl id.
             * @member {string} id
             * @memberof api.Repl
             * @instance
             */
            Repl.prototype.id = "";
    
            /**
             * Repl language.
             * @member {string} language
             * @memberof api.Repl
             * @instance
             */
            Repl.prototype.language = "";
    
            /**
             * Repl bucket.
             * @member {string} bucket
             * @memberof api.Repl
             * @instance
             */
            Repl.prototype.bucket = "";
    
            /**
             * Repl slug.
             * @member {string} slug
             * @memberof api.Repl
             * @instance
             */
            Repl.prototype.slug = "";
    
            /**
             * Repl user.
             * @member {string} user
             * @memberof api.Repl
             * @instance
             */
            Repl.prototype.user = "";
    
            /**
             * Repl sourceRepl.
             * @member {string} sourceRepl
             * @memberof api.Repl
             * @instance
             */
            Repl.prototype.sourceRepl = "";
    
            /**
             * Creates a new Repl instance using the specified properties.
             * @function create
             * @memberof api.Repl
             * @static
             * @param {api.IRepl=} [properties] Properties to set
             * @returns {api.Repl} Repl instance
             */
            Repl.create = function create(properties) {
                return Repl.fromObject(properties);
            };
    
            /**
             * Encodes the specified Repl message. Does not implicitly {@link api.Repl.verify|verify} messages.
             * @function encode
             * @memberof api.Repl
             * @static
             * @param {api.Repl} message Repl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Repl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.language);
                if (message.bucket != null && Object.hasOwnProperty.call(message, "bucket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.bucket);
                if (message.slug != null && Object.hasOwnProperty.call(message, "slug"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.slug);
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.user);
                if (message.sourceRepl != null && Object.hasOwnProperty.call(message, "sourceRepl"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.sourceRepl);
                return writer;
            };
    
            /**
             * Encodes the specified Repl message, length delimited. Does not implicitly {@link api.Repl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Repl
             * @static
             * @param {api.Repl} message Repl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Repl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Repl message from the specified reader or buffer.
             * @function decode
             * @memberof api.Repl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Repl} Repl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Repl.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Repl();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.language = reader.string();
                        break;
                    case 3:
                        message.bucket = reader.string();
                        break;
                    case 4:
                        message.slug = reader.string();
                        break;
                    case 5:
                        message.user = reader.string();
                        break;
                    case 6:
                        message.sourceRepl = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Repl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Repl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Repl} Repl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Repl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Repl message.
             * @function verify
             * @memberof api.Repl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Repl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.language != null && message.hasOwnProperty("language"))
                    if (!$util.isString(message.language))
                        return "language: string expected";
                if (message.bucket != null && message.hasOwnProperty("bucket"))
                    if (!$util.isString(message.bucket))
                        return "bucket: string expected";
                if (message.slug != null && message.hasOwnProperty("slug"))
                    if (!$util.isString(message.slug))
                        return "slug: string expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!$util.isString(message.user))
                        return "user: string expected";
                if (message.sourceRepl != null && message.hasOwnProperty("sourceRepl"))
                    if (!$util.isString(message.sourceRepl))
                        return "sourceRepl: string expected";
                return null;
            };
    
            /**
             * Creates a Repl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Repl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Repl} Repl
             */
            Repl.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Repl)
                    return object;
                var message = new $root.api.Repl();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.language != null)
                    message.language = String(object.language);
                if (object.bucket != null)
                    message.bucket = String(object.bucket);
                if (object.slug != null)
                    message.slug = String(object.slug);
                if (object.user != null)
                    message.user = String(object.user);
                if (object.sourceRepl != null)
                    message.sourceRepl = String(object.sourceRepl);
                return message;
            };
    
            /**
             * Creates a plain object from a Repl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Repl
             * @static
             * @param {api.Repl} message Repl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Repl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.language = "";
                    object.bucket = "";
                    object.slug = "";
                    object.user = "";
                    object.sourceRepl = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.language != null && message.hasOwnProperty("language"))
                    object.language = message.language;
                if (message.bucket != null && message.hasOwnProperty("bucket"))
                    object.bucket = message.bucket;
                if (message.slug != null && message.hasOwnProperty("slug"))
                    object.slug = message.slug;
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = message.user;
                if (message.sourceRepl != null && message.hasOwnProperty("sourceRepl"))
                    object.sourceRepl = message.sourceRepl;
                return object;
            };
    
            /**
             * Converts this Repl to JSON.
             * @function toJSON
             * @memberof api.Repl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Repl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Repl;
        })();
    
        api.ResourceLimits = (function() {
    
            /**
             * Properties of a ResourceLimits.
             * @memberof api
             * @interface IResourceLimits
             * @property {boolean|null} [net] ResourceLimits net
             * @property {number|null} [memory] ResourceLimits memory
             * @property {number|null} [threads] ResourceLimits threads
             * @property {number|null} [shares] ResourceLimits shares
             * @property {number|null} [disk] ResourceLimits disk
             * @property {api.ResourceLimits.Cachability|null} [cache] ResourceLimits cache
             */
    
            /**
             * Constructs a new ResourceLimits.
             * @memberof api
             * @classdesc Represents a ResourceLimits.
             * @constructor
             * @param {api.IResourceLimits=} [properties] Properties to set
             */
            function ResourceLimits(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ResourceLimits net.
             * @member {boolean} net
             * @memberof api.ResourceLimits
             * @instance
             */
            ResourceLimits.prototype.net = false;
    
            /**
             * ResourceLimits memory.
             * @member {number} memory
             * @memberof api.ResourceLimits
             * @instance
             */
            ResourceLimits.prototype.memory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ResourceLimits threads.
             * @member {number} threads
             * @memberof api.ResourceLimits
             * @instance
             */
            ResourceLimits.prototype.threads = 0;
    
            /**
             * ResourceLimits shares.
             * @member {number} shares
             * @memberof api.ResourceLimits
             * @instance
             */
            ResourceLimits.prototype.shares = 0;
    
            /**
             * ResourceLimits disk.
             * @member {number} disk
             * @memberof api.ResourceLimits
             * @instance
             */
            ResourceLimits.prototype.disk = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ResourceLimits cache.
             * @member {api.ResourceLimits.Cachability} cache
             * @memberof api.ResourceLimits
             * @instance
             */
            ResourceLimits.prototype.cache = 0;
    
            /**
             * Creates a new ResourceLimits instance using the specified properties.
             * @function create
             * @memberof api.ResourceLimits
             * @static
             * @param {api.IResourceLimits=} [properties] Properties to set
             * @returns {api.ResourceLimits} ResourceLimits instance
             */
            ResourceLimits.create = function create(properties) {
                return ResourceLimits.fromObject(properties);
            };
    
            /**
             * Encodes the specified ResourceLimits message. Does not implicitly {@link api.ResourceLimits.verify|verify} messages.
             * @function encode
             * @memberof api.ResourceLimits
             * @static
             * @param {api.ResourceLimits} message ResourceLimits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResourceLimits.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.net != null && Object.hasOwnProperty.call(message, "net"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.net);
                if (message.memory != null && Object.hasOwnProperty.call(message, "memory"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.memory);
                if (message.threads != null && Object.hasOwnProperty.call(message, "threads"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.threads);
                if (message.shares != null && Object.hasOwnProperty.call(message, "shares"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.shares);
                if (message.disk != null && Object.hasOwnProperty.call(message, "disk"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.disk);
                if (message.cache != null && Object.hasOwnProperty.call(message, "cache"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cache);
                return writer;
            };
    
            /**
             * Encodes the specified ResourceLimits message, length delimited. Does not implicitly {@link api.ResourceLimits.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ResourceLimits
             * @static
             * @param {api.ResourceLimits} message ResourceLimits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResourceLimits.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ResourceLimits message from the specified reader or buffer.
             * @function decode
             * @memberof api.ResourceLimits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ResourceLimits} ResourceLimits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResourceLimits.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ResourceLimits();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.net = reader.bool();
                        break;
                    case 2:
                        message.memory = reader.int64();
                        break;
                    case 3:
                        message.threads = reader.double();
                        break;
                    case 4:
                        message.shares = reader.double();
                        break;
                    case 5:
                        message.disk = reader.int64();
                        break;
                    case 6:
                        message.cache = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ResourceLimits message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ResourceLimits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ResourceLimits} ResourceLimits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResourceLimits.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ResourceLimits message.
             * @function verify
             * @memberof api.ResourceLimits
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResourceLimits.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.net != null && message.hasOwnProperty("net"))
                    if (typeof message.net !== "boolean")
                        return "net: boolean expected";
                if (message.memory != null && message.hasOwnProperty("memory"))
                    if (!$util.isInteger(message.memory) && !(message.memory && $util.isInteger(message.memory.low) && $util.isInteger(message.memory.high)))
                        return "memory: integer|Long expected";
                if (message.threads != null && message.hasOwnProperty("threads"))
                    if (typeof message.threads !== "number")
                        return "threads: number expected";
                if (message.shares != null && message.hasOwnProperty("shares"))
                    if (typeof message.shares !== "number")
                        return "shares: number expected";
                if (message.disk != null && message.hasOwnProperty("disk"))
                    if (!$util.isInteger(message.disk) && !(message.disk && $util.isInteger(message.disk.low) && $util.isInteger(message.disk.high)))
                        return "disk: integer|Long expected";
                if (message.cache != null && message.hasOwnProperty("cache"))
                    switch (message.cache) {
                    default:
                        return "cache: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a ResourceLimits message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ResourceLimits
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ResourceLimits} ResourceLimits
             */
            ResourceLimits.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ResourceLimits)
                    return object;
                var message = new $root.api.ResourceLimits();
                if (object.net != null)
                    message.net = Boolean(object.net);
                if (object.memory != null)
                    if ($util.Long)
                        (message.memory = $util.Long.fromValue(object.memory)).unsigned = false;
                    else if (typeof object.memory === "string")
                        message.memory = parseInt(object.memory, 10);
                    else if (typeof object.memory === "number")
                        message.memory = object.memory;
                    else if (typeof object.memory === "object")
                        message.memory = new $util.LongBits(object.memory.low >>> 0, object.memory.high >>> 0).toNumber();
                if (object.threads != null)
                    message.threads = Number(object.threads);
                if (object.shares != null)
                    message.shares = Number(object.shares);
                if (object.disk != null)
                    if ($util.Long)
                        (message.disk = $util.Long.fromValue(object.disk)).unsigned = false;
                    else if (typeof object.disk === "string")
                        message.disk = parseInt(object.disk, 10);
                    else if (typeof object.disk === "number")
                        message.disk = object.disk;
                    else if (typeof object.disk === "object")
                        message.disk = new $util.LongBits(object.disk.low >>> 0, object.disk.high >>> 0).toNumber();
                switch (object.cache) {
                case "NONE":
                case 0:
                    message.cache = 0;
                    break;
                case "USER":
                case 1:
                    message.cache = 1;
                    break;
                case "REPL":
                case 2:
                    message.cache = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ResourceLimits message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ResourceLimits
             * @static
             * @param {api.ResourceLimits} message ResourceLimits
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResourceLimits.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.net = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.memory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memory = options.longs === String ? "0" : 0;
                    object.threads = 0;
                    object.shares = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.disk = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.disk = options.longs === String ? "0" : 0;
                    object.cache = options.enums === String ? "NONE" : 0;
                }
                if (message.net != null && message.hasOwnProperty("net"))
                    object.net = message.net;
                if (message.memory != null && message.hasOwnProperty("memory"))
                    if (typeof message.memory === "number")
                        object.memory = options.longs === String ? String(message.memory) : message.memory;
                    else
                        object.memory = options.longs === String ? $util.Long.prototype.toString.call(message.memory) : options.longs === Number ? new $util.LongBits(message.memory.low >>> 0, message.memory.high >>> 0).toNumber() : message.memory;
                if (message.threads != null && message.hasOwnProperty("threads"))
                    object.threads = options.json && !isFinite(message.threads) ? String(message.threads) : message.threads;
                if (message.shares != null && message.hasOwnProperty("shares"))
                    object.shares = options.json && !isFinite(message.shares) ? String(message.shares) : message.shares;
                if (message.disk != null && message.hasOwnProperty("disk"))
                    if (typeof message.disk === "number")
                        object.disk = options.longs === String ? String(message.disk) : message.disk;
                    else
                        object.disk = options.longs === String ? $util.Long.prototype.toString.call(message.disk) : options.longs === Number ? new $util.LongBits(message.disk.low >>> 0, message.disk.high >>> 0).toNumber() : message.disk;
                if (message.cache != null && message.hasOwnProperty("cache"))
                    object.cache = options.enums === String ? $root.api.ResourceLimits.Cachability[message.cache] : message.cache;
                return object;
            };
    
            /**
             * Converts this ResourceLimits to JSON.
             * @function toJSON
             * @memberof api.ResourceLimits
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResourceLimits.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Cachability enum.
             * @name api.ResourceLimits.Cachability
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} USER=1 USER value
             * @property {number} REPL=2 REPL value
             */
            ResourceLimits.Cachability = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "USER"] = 1;
                values[valuesById[2] = "REPL"] = 2;
                return values;
            })();
    
            return ResourceLimits;
        })();
    
        api.Permissions = (function() {
    
            /**
             * Properties of a Permissions.
             * @memberof api
             * @interface IPermissions
             * @property {boolean|null} [toggleAlwaysOn] Permissions toggleAlwaysOn
             */
    
            /**
             * Constructs a new Permissions.
             * @memberof api
             * @classdesc Represents a Permissions.
             * @constructor
             * @param {api.IPermissions=} [properties] Properties to set
             */
            function Permissions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Permissions toggleAlwaysOn.
             * @member {boolean} toggleAlwaysOn
             * @memberof api.Permissions
             * @instance
             */
            Permissions.prototype.toggleAlwaysOn = false;
    
            /**
             * Creates a new Permissions instance using the specified properties.
             * @function create
             * @memberof api.Permissions
             * @static
             * @param {api.IPermissions=} [properties] Properties to set
             * @returns {api.Permissions} Permissions instance
             */
            Permissions.create = function create(properties) {
                return Permissions.fromObject(properties);
            };
    
            /**
             * Encodes the specified Permissions message. Does not implicitly {@link api.Permissions.verify|verify} messages.
             * @function encode
             * @memberof api.Permissions
             * @static
             * @param {api.Permissions} message Permissions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permissions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.toggleAlwaysOn != null && Object.hasOwnProperty.call(message, "toggleAlwaysOn"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.toggleAlwaysOn);
                return writer;
            };
    
            /**
             * Encodes the specified Permissions message, length delimited. Does not implicitly {@link api.Permissions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.Permissions
             * @static
             * @param {api.Permissions} message Permissions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permissions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Permissions message from the specified reader or buffer.
             * @function decode
             * @memberof api.Permissions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.Permissions} Permissions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permissions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.Permissions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.toggleAlwaysOn = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Permissions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.Permissions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.Permissions} Permissions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permissions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Permissions message.
             * @function verify
             * @memberof api.Permissions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Permissions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.toggleAlwaysOn != null && message.hasOwnProperty("toggleAlwaysOn"))
                    if (typeof message.toggleAlwaysOn !== "boolean")
                        return "toggleAlwaysOn: boolean expected";
                return null;
            };
    
            /**
             * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.Permissions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.Permissions} Permissions
             */
            Permissions.fromObject = function fromObject(object) {
                if (object instanceof $root.api.Permissions)
                    return object;
                var message = new $root.api.Permissions();
                if (object.toggleAlwaysOn != null)
                    message.toggleAlwaysOn = Boolean(object.toggleAlwaysOn);
                return message;
            };
    
            /**
             * Creates a plain object from a Permissions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.Permissions
             * @static
             * @param {api.Permissions} message Permissions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Permissions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.toggleAlwaysOn = false;
                if (message.toggleAlwaysOn != null && message.hasOwnProperty("toggleAlwaysOn"))
                    object.toggleAlwaysOn = message.toggleAlwaysOn;
                return object;
            };
    
            /**
             * Converts this Permissions to JSON.
             * @function toJSON
             * @memberof api.Permissions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Permissions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Permissions;
        })();
    
        api.ReplToken = (function() {
    
            /**
             * Properties of a ReplToken.
             * @memberof api
             * @interface IReplToken
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [iat] ReplToken iat
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [exp] ReplToken exp
             * @property {string|null} [salt] ReplToken salt
             * @property {string|null} [cluster] ReplToken cluster
             * @property {api.ReplToken.Persistence|null} [persistence] ReplToken persistence
             * @property {api.Repl|api.IRepl|null} [repl] ReplToken repl
             * @property {api.ReplToken.ReplID|api.ReplToken.IReplID|null} [id] ReplToken id
             * @property {api.ReplToken.ClassroomMetadata|api.ReplToken.IClassroomMetadata|null} [classroom] ReplToken classroom
             * @property {api.ResourceLimits|api.IResourceLimits|null} [resourceLimits] ReplToken resourceLimits
             * @property {api.ReplToken.WireFormat|null} [format] ReplToken format
             * @property {api.ReplToken.Presenced|api.ReplToken.IPresenced|null} [presenced] ReplToken presenced
             * @property {Array.<string>|null} [flags] ReplToken flags
             * @property {api.Permissions|api.IPermissions|null} [permissions] ReplToken permissions
             */
    
            /**
             * Constructs a new ReplToken.
             * @memberof api
             * @classdesc Represents a ReplToken.
             * @constructor
             * @param {api.IReplToken=} [properties] Properties to set
             */
            function ReplToken(properties) {
                this.flags = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReplToken iat.
             * @member {google.protobuf.Timestamp|null|undefined} iat
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.iat = null;
    
            /**
             * ReplToken exp.
             * @member {google.protobuf.Timestamp|null|undefined} exp
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.exp = null;
    
            /**
             * ReplToken salt.
             * @member {string} salt
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.salt = "";
    
            /**
             * ReplToken cluster.
             * @member {string} cluster
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.cluster = "";
    
            /**
             * ReplToken persistence.
             * @member {api.ReplToken.Persistence} persistence
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.persistence = 0;
    
            /**
             * ReplToken repl.
             * @member {api.Repl|null|undefined} repl
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.repl = null;
    
            /**
             * ReplToken id.
             * @member {api.ReplToken.ReplID|null|undefined} id
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.id = null;
    
            /**
             * ReplToken classroom.
             * @member {api.ReplToken.ClassroomMetadata|null|undefined} classroom
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.classroom = null;
    
            /**
             * ReplToken resourceLimits.
             * @member {api.ResourceLimits|null|undefined} resourceLimits
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.resourceLimits = null;
    
            /**
             * ReplToken format.
             * @member {api.ReplToken.WireFormat} format
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.format = 0;
    
            /**
             * ReplToken presenced.
             * @member {api.ReplToken.Presenced|null|undefined} presenced
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.presenced = null;
    
            /**
             * ReplToken flags.
             * @member {Array.<string>} flags
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.flags = $util.emptyArray;
    
            /**
             * ReplToken permissions.
             * @member {api.Permissions|null|undefined} permissions
             * @memberof api.ReplToken
             * @instance
             */
            ReplToken.prototype.permissions = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * ReplToken metadata.
             * @member {"repl"|"id"|"classroom"|undefined} metadata
             * @memberof api.ReplToken
             * @instance
             */
            Object.defineProperty(ReplToken.prototype, "metadata", {
                get: $util.oneOfGetter($oneOfFields = ["repl", "id", "classroom"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new ReplToken instance using the specified properties.
             * @function create
             * @memberof api.ReplToken
             * @static
             * @param {api.IReplToken=} [properties] Properties to set
             * @returns {api.ReplToken} ReplToken instance
             */
            ReplToken.create = function create(properties) {
                return ReplToken.fromObject(properties);
            };
    
            /**
             * Encodes the specified ReplToken message. Does not implicitly {@link api.ReplToken.verify|verify} messages.
             * @function encode
             * @memberof api.ReplToken
             * @static
             * @param {api.ReplToken} message ReplToken message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplToken.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.iat != null && Object.hasOwnProperty.call(message, "iat"))
                    $root.google.protobuf.Timestamp.encode(message.iat, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                    $root.google.protobuf.Timestamp.encode(message.exp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.salt);
                if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.cluster);
                if (message.persistence != null && Object.hasOwnProperty.call(message, "persistence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.persistence);
                if (message.repl != null && Object.hasOwnProperty.call(message, "repl"))
                    $root.api.Repl.encode(message.repl, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    $root.api.ReplToken.ReplID.encode(message.id, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.classroom != null && Object.hasOwnProperty.call(message, "classroom"))
                    $root.api.ReplToken.ClassroomMetadata.encode(message.classroom, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.resourceLimits != null && Object.hasOwnProperty.call(message, "resourceLimits"))
                    $root.api.ResourceLimits.encode(message.resourceLimits, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.format);
                if (message.presenced != null && Object.hasOwnProperty.call(message, "presenced"))
                    $root.api.ReplToken.Presenced.encode(message.presenced, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.flags != null && message.flags.length)
                    for (var i = 0; i < message.flags.length; ++i)
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.flags[i]);
                if (message.permissions != null && Object.hasOwnProperty.call(message, "permissions"))
                    $root.api.Permissions.encode(message.permissions, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ReplToken message, length delimited. Does not implicitly {@link api.ReplToken.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ReplToken
             * @static
             * @param {api.ReplToken} message ReplToken message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplToken.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ReplToken message from the specified reader or buffer.
             * @function decode
             * @memberof api.ReplToken
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ReplToken} ReplToken
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplToken.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ReplToken();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.iat = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.exp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.salt = reader.string();
                        break;
                    case 4:
                        message.cluster = reader.string();
                        break;
                    case 6:
                        message.persistence = reader.int32();
                        break;
                    case 7:
                        message.repl = $root.api.Repl.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.id = $root.api.ReplToken.ReplID.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.classroom = $root.api.ReplToken.ClassroomMetadata.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.resourceLimits = $root.api.ResourceLimits.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.format = reader.int32();
                        break;
                    case 13:
                        message.presenced = $root.api.ReplToken.Presenced.decode(reader, reader.uint32());
                        break;
                    case 14:
                        if (!(message.flags && message.flags.length))
                            message.flags = [];
                        message.flags.push(reader.string());
                        break;
                    case 15:
                        message.permissions = $root.api.Permissions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ReplToken message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ReplToken
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ReplToken} ReplToken
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplToken.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ReplToken message.
             * @function verify
             * @memberof api.ReplToken
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplToken.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.iat != null && message.hasOwnProperty("iat")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.iat);
                    if (error)
                        return "iat." + error;
                }
                if (message.exp != null && message.hasOwnProperty("exp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.exp);
                    if (error)
                        return "exp." + error;
                }
                if (message.salt != null && message.hasOwnProperty("salt"))
                    if (!$util.isString(message.salt))
                        return "salt: string expected";
                if (message.cluster != null && message.hasOwnProperty("cluster"))
                    if (!$util.isString(message.cluster))
                        return "cluster: string expected";
                if (message.persistence != null && message.hasOwnProperty("persistence"))
                    switch (message.persistence) {
                    default:
                        return "persistence: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.repl != null && message.hasOwnProperty("repl")) {
                    properties.metadata = 1;
                    {
                        var error = $root.api.Repl.verify(message.repl);
                        if (error)
                            return "repl." + error;
                    }
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    if (properties.metadata === 1)
                        return "metadata: multiple values";
                    properties.metadata = 1;
                    {
                        var error = $root.api.ReplToken.ReplID.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                }
                if (message.classroom != null && message.hasOwnProperty("classroom")) {
                    if (properties.metadata === 1)
                        return "metadata: multiple values";
                    properties.metadata = 1;
                    {
                        var error = $root.api.ReplToken.ClassroomMetadata.verify(message.classroom);
                        if (error)
                            return "classroom." + error;
                    }
                }
                if (message.resourceLimits != null && message.hasOwnProperty("resourceLimits")) {
                    var error = $root.api.ResourceLimits.verify(message.resourceLimits);
                    if (error)
                        return "resourceLimits." + error;
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    switch (message.format) {
                    default:
                        return "format: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.presenced != null && message.hasOwnProperty("presenced")) {
                    var error = $root.api.ReplToken.Presenced.verify(message.presenced);
                    if (error)
                        return "presenced." + error;
                }
                if (message.flags != null && message.hasOwnProperty("flags")) {
                    if (!Array.isArray(message.flags))
                        return "flags: array expected";
                    for (var i = 0; i < message.flags.length; ++i)
                        if (!$util.isString(message.flags[i]))
                            return "flags: string[] expected";
                }
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    var error = $root.api.Permissions.verify(message.permissions);
                    if (error)
                        return "permissions." + error;
                }
                return null;
            };
    
            /**
             * Creates a ReplToken message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ReplToken
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ReplToken} ReplToken
             */
            ReplToken.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ReplToken)
                    return object;
                var message = new $root.api.ReplToken();
                if (object.iat != null) {
                    if (typeof object.iat !== "object")
                        throw TypeError(".api.ReplToken.iat: object expected");
                    message.iat = $root.google.protobuf.Timestamp.fromObject(object.iat);
                }
                if (object.exp != null) {
                    if (typeof object.exp !== "object")
                        throw TypeError(".api.ReplToken.exp: object expected");
                    message.exp = $root.google.protobuf.Timestamp.fromObject(object.exp);
                }
                if (object.salt != null)
                    message.salt = String(object.salt);
                if (object.cluster != null)
                    message.cluster = String(object.cluster);
                switch (object.persistence) {
                case "PERSISTENT":
                case 0:
                    message.persistence = 0;
                    break;
                case "EPHEMERAL":
                case 1:
                    message.persistence = 1;
                    break;
                case "NONE":
                case 2:
                    message.persistence = 2;
                    break;
                }
                if (object.repl != null) {
                    if (typeof object.repl !== "object")
                        throw TypeError(".api.ReplToken.repl: object expected");
                    message.repl = $root.api.Repl.fromObject(object.repl);
                }
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".api.ReplToken.id: object expected");
                    message.id = $root.api.ReplToken.ReplID.fromObject(object.id);
                }
                if (object.classroom != null) {
                    if (typeof object.classroom !== "object")
                        throw TypeError(".api.ReplToken.classroom: object expected");
                    message.classroom = $root.api.ReplToken.ClassroomMetadata.fromObject(object.classroom);
                }
                if (object.resourceLimits != null) {
                    if (typeof object.resourceLimits !== "object")
                        throw TypeError(".api.ReplToken.resourceLimits: object expected");
                    message.resourceLimits = $root.api.ResourceLimits.fromObject(object.resourceLimits);
                }
                switch (object.format) {
                case "PROTOBUF":
                case 0:
                    message.format = 0;
                    break;
                case "JSON":
                case 1:
                    message.format = 1;
                    break;
                }
                if (object.presenced != null) {
                    if (typeof object.presenced !== "object")
                        throw TypeError(".api.ReplToken.presenced: object expected");
                    message.presenced = $root.api.ReplToken.Presenced.fromObject(object.presenced);
                }
                if (object.flags) {
                    if (!Array.isArray(object.flags))
                        throw TypeError(".api.ReplToken.flags: array expected");
                    message.flags = [];
                    for (var i = 0; i < object.flags.length; ++i)
                        message.flags[i] = String(object.flags[i]);
                }
                if (object.permissions != null) {
                    if (typeof object.permissions !== "object")
                        throw TypeError(".api.ReplToken.permissions: object expected");
                    message.permissions = $root.api.Permissions.fromObject(object.permissions);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ReplToken message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ReplToken
             * @static
             * @param {api.ReplToken} message ReplToken
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplToken.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.flags = [];
                if (options.defaults) {
                    object.iat = null;
                    object.exp = null;
                    object.salt = "";
                    object.cluster = "";
                    object.persistence = options.enums === String ? "PERSISTENT" : 0;
                    object.resourceLimits = null;
                    object.format = options.enums === String ? "PROTOBUF" : 0;
                    object.presenced = null;
                    object.permissions = null;
                }
                if (message.iat != null && message.hasOwnProperty("iat"))
                    object.iat = $root.google.protobuf.Timestamp.toObject(message.iat, options);
                if (message.exp != null && message.hasOwnProperty("exp"))
                    object.exp = $root.google.protobuf.Timestamp.toObject(message.exp, options);
                if (message.salt != null && message.hasOwnProperty("salt"))
                    object.salt = message.salt;
                if (message.cluster != null && message.hasOwnProperty("cluster"))
                    object.cluster = message.cluster;
                if (message.persistence != null && message.hasOwnProperty("persistence"))
                    object.persistence = options.enums === String ? $root.api.ReplToken.Persistence[message.persistence] : message.persistence;
                if (message.repl != null && message.hasOwnProperty("repl")) {
                    object.repl = $root.api.Repl.toObject(message.repl, options);
                    if (options.oneofs)
                        object.metadata = "repl";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = $root.api.ReplToken.ReplID.toObject(message.id, options);
                    if (options.oneofs)
                        object.metadata = "id";
                }
                if (message.classroom != null && message.hasOwnProperty("classroom")) {
                    object.classroom = $root.api.ReplToken.ClassroomMetadata.toObject(message.classroom, options);
                    if (options.oneofs)
                        object.metadata = "classroom";
                }
                if (message.resourceLimits != null && message.hasOwnProperty("resourceLimits"))
                    object.resourceLimits = $root.api.ResourceLimits.toObject(message.resourceLimits, options);
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = options.enums === String ? $root.api.ReplToken.WireFormat[message.format] : message.format;
                if (message.presenced != null && message.hasOwnProperty("presenced"))
                    object.presenced = $root.api.ReplToken.Presenced.toObject(message.presenced, options);
                if (message.flags && message.flags.length) {
                    object.flags = [];
                    for (var j = 0; j < message.flags.length; ++j)
                        object.flags[j] = message.flags[j];
                }
                if (message.permissions != null && message.hasOwnProperty("permissions"))
                    object.permissions = $root.api.Permissions.toObject(message.permissions, options);
                return object;
            };
    
            /**
             * Converts this ReplToken to JSON.
             * @function toJSON
             * @memberof api.ReplToken
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplToken.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Persistence enum.
             * @name api.ReplToken.Persistence
             * @enum {number}
             * @property {number} PERSISTENT=0 PERSISTENT value
             * @property {number} EPHEMERAL=1 EPHEMERAL value
             * @property {number} NONE=2 NONE value
             */
            ReplToken.Persistence = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PERSISTENT"] = 0;
                values[valuesById[1] = "EPHEMERAL"] = 1;
                values[valuesById[2] = "NONE"] = 2;
                return values;
            })();
    
            ReplToken.ClassroomMetadata = (function() {
    
                /**
                 * Properties of a ClassroomMetadata.
                 * @memberof api.ReplToken
                 * @interface IClassroomMetadata
                 * @property {string|null} [id] ClassroomMetadata id
                 * @property {string|null} [language] ClassroomMetadata language
                 */
    
                /**
                 * Constructs a new ClassroomMetadata.
                 * @memberof api.ReplToken
                 * @classdesc Represents a ClassroomMetadata.
                 * @constructor
                 * @param {api.ReplToken.IClassroomMetadata=} [properties] Properties to set
                 */
                function ClassroomMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ClassroomMetadata id.
                 * @member {string} id
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @instance
                 */
                ClassroomMetadata.prototype.id = "";
    
                /**
                 * ClassroomMetadata language.
                 * @member {string} language
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @instance
                 */
                ClassroomMetadata.prototype.language = "";
    
                /**
                 * Creates a new ClassroomMetadata instance using the specified properties.
                 * @function create
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {api.ReplToken.IClassroomMetadata=} [properties] Properties to set
                 * @returns {api.ReplToken.ClassroomMetadata} ClassroomMetadata instance
                 */
                ClassroomMetadata.create = function create(properties) {
                    return ClassroomMetadata.fromObject(properties);
                };
    
                /**
                 * Encodes the specified ClassroomMetadata message. Does not implicitly {@link api.ReplToken.ClassroomMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {api.ReplToken.ClassroomMetadata} message ClassroomMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClassroomMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.language);
                    return writer;
                };
    
                /**
                 * Encodes the specified ClassroomMetadata message, length delimited. Does not implicitly {@link api.ReplToken.ClassroomMetadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {api.ReplToken.ClassroomMetadata} message ClassroomMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClassroomMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ClassroomMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {api.ReplToken.ClassroomMetadata} ClassroomMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClassroomMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ReplToken.ClassroomMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.language = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ClassroomMetadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {api.ReplToken.ClassroomMetadata} ClassroomMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClassroomMetadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ClassroomMetadata message.
                 * @function verify
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClassroomMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.language != null && message.hasOwnProperty("language"))
                        if (!$util.isString(message.language))
                            return "language: string expected";
                    return null;
                };
    
                /**
                 * Creates a ClassroomMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {api.ReplToken.ClassroomMetadata} ClassroomMetadata
                 */
                ClassroomMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.api.ReplToken.ClassroomMetadata)
                        return object;
                    var message = new $root.api.ReplToken.ClassroomMetadata();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.language != null)
                        message.language = String(object.language);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ClassroomMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @static
                 * @param {api.ReplToken.ClassroomMetadata} message ClassroomMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClassroomMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.language = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.language != null && message.hasOwnProperty("language"))
                        object.language = message.language;
                    return object;
                };
    
                /**
                 * Converts this ClassroomMetadata to JSON.
                 * @function toJSON
                 * @memberof api.ReplToken.ClassroomMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClassroomMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ClassroomMetadata;
            })();
    
            ReplToken.ReplID = (function() {
    
                /**
                 * Properties of a ReplID.
                 * @memberof api.ReplToken
                 * @interface IReplID
                 * @property {string|null} [id] ReplID id
                 * @property {string|null} [sourceRepl] ReplID sourceRepl
                 */
    
                /**
                 * Constructs a new ReplID.
                 * @memberof api.ReplToken
                 * @classdesc Represents a ReplID.
                 * @constructor
                 * @param {api.ReplToken.IReplID=} [properties] Properties to set
                 */
                function ReplID(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ReplID id.
                 * @member {string} id
                 * @memberof api.ReplToken.ReplID
                 * @instance
                 */
                ReplID.prototype.id = "";
    
                /**
                 * ReplID sourceRepl.
                 * @member {string} sourceRepl
                 * @memberof api.ReplToken.ReplID
                 * @instance
                 */
                ReplID.prototype.sourceRepl = "";
    
                /**
                 * Creates a new ReplID instance using the specified properties.
                 * @function create
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {api.ReplToken.IReplID=} [properties] Properties to set
                 * @returns {api.ReplToken.ReplID} ReplID instance
                 */
                ReplID.create = function create(properties) {
                    return ReplID.fromObject(properties);
                };
    
                /**
                 * Encodes the specified ReplID message. Does not implicitly {@link api.ReplToken.ReplID.verify|verify} messages.
                 * @function encode
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {api.ReplToken.ReplID} message ReplID message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReplID.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.sourceRepl != null && Object.hasOwnProperty.call(message, "sourceRepl"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceRepl);
                    return writer;
                };
    
                /**
                 * Encodes the specified ReplID message, length delimited. Does not implicitly {@link api.ReplToken.ReplID.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {api.ReplToken.ReplID} message ReplID message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReplID.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ReplID message from the specified reader or buffer.
                 * @function decode
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {api.ReplToken.ReplID} ReplID
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReplID.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ReplToken.ReplID();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.sourceRepl = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ReplID message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {api.ReplToken.ReplID} ReplID
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReplID.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ReplID message.
                 * @function verify
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReplID.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.sourceRepl != null && message.hasOwnProperty("sourceRepl"))
                        if (!$util.isString(message.sourceRepl))
                            return "sourceRepl: string expected";
                    return null;
                };
    
                /**
                 * Creates a ReplID message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {api.ReplToken.ReplID} ReplID
                 */
                ReplID.fromObject = function fromObject(object) {
                    if (object instanceof $root.api.ReplToken.ReplID)
                        return object;
                    var message = new $root.api.ReplToken.ReplID();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.sourceRepl != null)
                        message.sourceRepl = String(object.sourceRepl);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ReplID message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof api.ReplToken.ReplID
                 * @static
                 * @param {api.ReplToken.ReplID} message ReplID
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReplID.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.sourceRepl = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.sourceRepl != null && message.hasOwnProperty("sourceRepl"))
                        object.sourceRepl = message.sourceRepl;
                    return object;
                };
    
                /**
                 * Converts this ReplID to JSON.
                 * @function toJSON
                 * @memberof api.ReplToken.ReplID
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReplID.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ReplID;
            })();
    
            /**
             * WireFormat enum.
             * @name api.ReplToken.WireFormat
             * @enum {number}
             * @property {number} PROTOBUF=0 PROTOBUF value
             * @property {number} JSON=1 JSON value
             */
            ReplToken.WireFormat = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PROTOBUF"] = 0;
                values[valuesById[1] = "JSON"] = 1;
                return values;
            })();
    
            ReplToken.Presenced = (function() {
    
                /**
                 * Properties of a Presenced.
                 * @memberof api.ReplToken
                 * @interface IPresenced
                 * @property {number|null} [bearerID] Presenced bearerID
                 * @property {string|null} [bearerName] Presenced bearerName
                 */
    
                /**
                 * Constructs a new Presenced.
                 * @memberof api.ReplToken
                 * @classdesc Represents a Presenced.
                 * @constructor
                 * @param {api.ReplToken.IPresenced=} [properties] Properties to set
                 */
                function Presenced(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Presenced bearerID.
                 * @member {number} bearerID
                 * @memberof api.ReplToken.Presenced
                 * @instance
                 */
                Presenced.prototype.bearerID = 0;
    
                /**
                 * Presenced bearerName.
                 * @member {string} bearerName
                 * @memberof api.ReplToken.Presenced
                 * @instance
                 */
                Presenced.prototype.bearerName = "";
    
                /**
                 * Creates a new Presenced instance using the specified properties.
                 * @function create
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {api.ReplToken.IPresenced=} [properties] Properties to set
                 * @returns {api.ReplToken.Presenced} Presenced instance
                 */
                Presenced.create = function create(properties) {
                    return Presenced.fromObject(properties);
                };
    
                /**
                 * Encodes the specified Presenced message. Does not implicitly {@link api.ReplToken.Presenced.verify|verify} messages.
                 * @function encode
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {api.ReplToken.Presenced} message Presenced message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Presenced.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bearerID != null && Object.hasOwnProperty.call(message, "bearerID"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.bearerID);
                    if (message.bearerName != null && Object.hasOwnProperty.call(message, "bearerName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.bearerName);
                    return writer;
                };
    
                /**
                 * Encodes the specified Presenced message, length delimited. Does not implicitly {@link api.ReplToken.Presenced.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {api.ReplToken.Presenced} message Presenced message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Presenced.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Presenced message from the specified reader or buffer.
                 * @function decode
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {api.ReplToken.Presenced} Presenced
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Presenced.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ReplToken.Presenced();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bearerID = reader.uint32();
                            break;
                        case 2:
                            message.bearerName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Presenced message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {api.ReplToken.Presenced} Presenced
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Presenced.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Presenced message.
                 * @function verify
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Presenced.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bearerID != null && message.hasOwnProperty("bearerID"))
                        if (!$util.isInteger(message.bearerID))
                            return "bearerID: integer expected";
                    if (message.bearerName != null && message.hasOwnProperty("bearerName"))
                        if (!$util.isString(message.bearerName))
                            return "bearerName: string expected";
                    return null;
                };
    
                /**
                 * Creates a Presenced message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {api.ReplToken.Presenced} Presenced
                 */
                Presenced.fromObject = function fromObject(object) {
                    if (object instanceof $root.api.ReplToken.Presenced)
                        return object;
                    var message = new $root.api.ReplToken.Presenced();
                    if (object.bearerID != null)
                        message.bearerID = object.bearerID >>> 0;
                    if (object.bearerName != null)
                        message.bearerName = String(object.bearerName);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Presenced message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof api.ReplToken.Presenced
                 * @static
                 * @param {api.ReplToken.Presenced} message Presenced
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Presenced.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.bearerID = 0;
                        object.bearerName = "";
                    }
                    if (message.bearerID != null && message.hasOwnProperty("bearerID"))
                        object.bearerID = message.bearerID;
                    if (message.bearerName != null && message.hasOwnProperty("bearerName"))
                        object.bearerName = message.bearerName;
                    return object;
                };
    
                /**
                 * Converts this Presenced to JSON.
                 * @function toJSON
                 * @memberof api.ReplToken.Presenced
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Presenced.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Presenced;
            })();
    
            return ReplToken;
        })();
    
        api.TLSCertificate = (function() {
    
            /**
             * Properties of a TLSCertificate.
             * @memberof api
             * @interface ITLSCertificate
             * @property {string|null} [domain] TLSCertificate domain
             * @property {Uint8Array|null} [cert] TLSCertificate cert
             */
    
            /**
             * Constructs a new TLSCertificate.
             * @memberof api
             * @classdesc Represents a TLSCertificate.
             * @constructor
             * @param {api.ITLSCertificate=} [properties] Properties to set
             */
            function TLSCertificate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TLSCertificate domain.
             * @member {string} domain
             * @memberof api.TLSCertificate
             * @instance
             */
            TLSCertificate.prototype.domain = "";
    
            /**
             * TLSCertificate cert.
             * @member {Uint8Array} cert
             * @memberof api.TLSCertificate
             * @instance
             */
            TLSCertificate.prototype.cert = $util.newBuffer([]);
    
            /**
             * Creates a new TLSCertificate instance using the specified properties.
             * @function create
             * @memberof api.TLSCertificate
             * @static
             * @param {api.ITLSCertificate=} [properties] Properties to set
             * @returns {api.TLSCertificate} TLSCertificate instance
             */
            TLSCertificate.create = function create(properties) {
                return TLSCertificate.fromObject(properties);
            };
    
            /**
             * Encodes the specified TLSCertificate message. Does not implicitly {@link api.TLSCertificate.verify|verify} messages.
             * @function encode
             * @memberof api.TLSCertificate
             * @static
             * @param {api.TLSCertificate} message TLSCertificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TLSCertificate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                if (message.cert != null && Object.hasOwnProperty.call(message, "cert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.cert);
                return writer;
            };
    
            /**
             * Encodes the specified TLSCertificate message, length delimited. Does not implicitly {@link api.TLSCertificate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.TLSCertificate
             * @static
             * @param {api.TLSCertificate} message TLSCertificate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TLSCertificate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TLSCertificate message from the specified reader or buffer.
             * @function decode
             * @memberof api.TLSCertificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.TLSCertificate} TLSCertificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TLSCertificate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.TLSCertificate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.domain = reader.string();
                        break;
                    case 2:
                        message.cert = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TLSCertificate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.TLSCertificate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.TLSCertificate} TLSCertificate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TLSCertificate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TLSCertificate message.
             * @function verify
             * @memberof api.TLSCertificate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TLSCertificate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.domain != null && message.hasOwnProperty("domain"))
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                if (message.cert != null && message.hasOwnProperty("cert"))
                    if (!(message.cert && typeof message.cert.length === "number" || $util.isString(message.cert)))
                        return "cert: buffer expected";
                return null;
            };
    
            /**
             * Creates a TLSCertificate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.TLSCertificate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.TLSCertificate} TLSCertificate
             */
            TLSCertificate.fromObject = function fromObject(object) {
                if (object instanceof $root.api.TLSCertificate)
                    return object;
                var message = new $root.api.TLSCertificate();
                if (object.domain != null)
                    message.domain = String(object.domain);
                if (object.cert != null)
                    if (typeof object.cert === "string")
                        $util.base64.decode(object.cert, message.cert = $util.newBuffer($util.base64.length(object.cert)), 0);
                    else if (object.cert.length)
                        message.cert = object.cert;
                return message;
            };
    
            /**
             * Creates a plain object from a TLSCertificate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.TLSCertificate
             * @static
             * @param {api.TLSCertificate} message TLSCertificate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TLSCertificate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.domain = "";
                    if (options.bytes === String)
                        object.cert = "";
                    else {
                        object.cert = [];
                        if (options.bytes !== Array)
                            object.cert = $util.newBuffer(object.cert);
                    }
                }
                if (message.domain != null && message.hasOwnProperty("domain"))
                    object.domain = message.domain;
                if (message.cert != null && message.hasOwnProperty("cert"))
                    object.cert = options.bytes === String ? $util.base64.encode(message.cert, 0, message.cert.length) : options.bytes === Array ? Array.prototype.slice.call(message.cert) : message.cert;
                return object;
            };
    
            /**
             * Converts this TLSCertificate to JSON.
             * @function toJSON
             * @memberof api.TLSCertificate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TLSCertificate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TLSCertificate;
        })();
    
        api.ReplTransfer = (function() {
    
            /**
             * Properties of a ReplTransfer.
             * @memberof api
             * @interface IReplTransfer
             * @property {api.Repl|api.IRepl|null} [repl] ReplTransfer repl
             * @property {api.ResourceLimits|api.IResourceLimits|null} [replLimits] ReplTransfer replLimits
             * @property {api.ResourceLimits|api.IResourceLimits|null} [userLimits] ReplTransfer userLimits
             * @property {Array.<string>|null} [customDomains] ReplTransfer customDomains
             * @property {Array.<api.TLSCertificate|api.ITLSCertificate>|null} [certificates] ReplTransfer certificates
             */
    
            /**
             * Constructs a new ReplTransfer.
             * @memberof api
             * @classdesc Represents a ReplTransfer.
             * @constructor
             * @param {api.IReplTransfer=} [properties] Properties to set
             */
            function ReplTransfer(properties) {
                this.customDomains = [];
                this.certificates = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReplTransfer repl.
             * @member {api.Repl|null|undefined} repl
             * @memberof api.ReplTransfer
             * @instance
             */
            ReplTransfer.prototype.repl = null;
    
            /**
             * ReplTransfer replLimits.
             * @member {api.ResourceLimits|null|undefined} replLimits
             * @memberof api.ReplTransfer
             * @instance
             */
            ReplTransfer.prototype.replLimits = null;
    
            /**
             * ReplTransfer userLimits.
             * @member {api.ResourceLimits|null|undefined} userLimits
             * @memberof api.ReplTransfer
             * @instance
             */
            ReplTransfer.prototype.userLimits = null;
    
            /**
             * ReplTransfer customDomains.
             * @member {Array.<string>} customDomains
             * @memberof api.ReplTransfer
             * @instance
             */
            ReplTransfer.prototype.customDomains = $util.emptyArray;
    
            /**
             * ReplTransfer certificates.
             * @member {Array.<api.TLSCertificate>} certificates
             * @memberof api.ReplTransfer
             * @instance
             */
            ReplTransfer.prototype.certificates = $util.emptyArray;
    
            /**
             * Creates a new ReplTransfer instance using the specified properties.
             * @function create
             * @memberof api.ReplTransfer
             * @static
             * @param {api.IReplTransfer=} [properties] Properties to set
             * @returns {api.ReplTransfer} ReplTransfer instance
             */
            ReplTransfer.create = function create(properties) {
                return ReplTransfer.fromObject(properties);
            };
    
            /**
             * Encodes the specified ReplTransfer message. Does not implicitly {@link api.ReplTransfer.verify|verify} messages.
             * @function encode
             * @memberof api.ReplTransfer
             * @static
             * @param {api.ReplTransfer} message ReplTransfer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplTransfer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.repl != null && Object.hasOwnProperty.call(message, "repl"))
                    $root.api.Repl.encode(message.repl, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.replLimits != null && Object.hasOwnProperty.call(message, "replLimits"))
                    $root.api.ResourceLimits.encode(message.replLimits, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.userLimits != null && Object.hasOwnProperty.call(message, "userLimits"))
                    $root.api.ResourceLimits.encode(message.userLimits, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.customDomains != null && message.customDomains.length)
                    for (var i = 0; i < message.customDomains.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.customDomains[i]);
                if (message.certificates != null && message.certificates.length)
                    for (var i = 0; i < message.certificates.length; ++i)
                        $root.api.TLSCertificate.encode(message.certificates[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ReplTransfer message, length delimited. Does not implicitly {@link api.ReplTransfer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ReplTransfer
             * @static
             * @param {api.ReplTransfer} message ReplTransfer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplTransfer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ReplTransfer message from the specified reader or buffer.
             * @function decode
             * @memberof api.ReplTransfer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ReplTransfer} ReplTransfer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplTransfer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ReplTransfer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.repl = $root.api.Repl.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.replLimits = $root.api.ResourceLimits.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.userLimits = $root.api.ResourceLimits.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.customDomains && message.customDomains.length))
                            message.customDomains = [];
                        message.customDomains.push(reader.string());
                        break;
                    case 5:
                        if (!(message.certificates && message.certificates.length))
                            message.certificates = [];
                        message.certificates.push($root.api.TLSCertificate.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ReplTransfer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ReplTransfer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ReplTransfer} ReplTransfer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplTransfer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ReplTransfer message.
             * @function verify
             * @memberof api.ReplTransfer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplTransfer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.repl != null && message.hasOwnProperty("repl")) {
                    var error = $root.api.Repl.verify(message.repl);
                    if (error)
                        return "repl." + error;
                }
                if (message.replLimits != null && message.hasOwnProperty("replLimits")) {
                    var error = $root.api.ResourceLimits.verify(message.replLimits);
                    if (error)
                        return "replLimits." + error;
                }
                if (message.userLimits != null && message.hasOwnProperty("userLimits")) {
                    var error = $root.api.ResourceLimits.verify(message.userLimits);
                    if (error)
                        return "userLimits." + error;
                }
                if (message.customDomains != null && message.hasOwnProperty("customDomains")) {
                    if (!Array.isArray(message.customDomains))
                        return "customDomains: array expected";
                    for (var i = 0; i < message.customDomains.length; ++i)
                        if (!$util.isString(message.customDomains[i]))
                            return "customDomains: string[] expected";
                }
                if (message.certificates != null && message.hasOwnProperty("certificates")) {
                    if (!Array.isArray(message.certificates))
                        return "certificates: array expected";
                    for (var i = 0; i < message.certificates.length; ++i) {
                        var error = $root.api.TLSCertificate.verify(message.certificates[i]);
                        if (error)
                            return "certificates." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ReplTransfer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ReplTransfer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ReplTransfer} ReplTransfer
             */
            ReplTransfer.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ReplTransfer)
                    return object;
                var message = new $root.api.ReplTransfer();
                if (object.repl != null) {
                    if (typeof object.repl !== "object")
                        throw TypeError(".api.ReplTransfer.repl: object expected");
                    message.repl = $root.api.Repl.fromObject(object.repl);
                }
                if (object.replLimits != null) {
                    if (typeof object.replLimits !== "object")
                        throw TypeError(".api.ReplTransfer.replLimits: object expected");
                    message.replLimits = $root.api.ResourceLimits.fromObject(object.replLimits);
                }
                if (object.userLimits != null) {
                    if (typeof object.userLimits !== "object")
                        throw TypeError(".api.ReplTransfer.userLimits: object expected");
                    message.userLimits = $root.api.ResourceLimits.fromObject(object.userLimits);
                }
                if (object.customDomains) {
                    if (!Array.isArray(object.customDomains))
                        throw TypeError(".api.ReplTransfer.customDomains: array expected");
                    message.customDomains = [];
                    for (var i = 0; i < object.customDomains.length; ++i)
                        message.customDomains[i] = String(object.customDomains[i]);
                }
                if (object.certificates) {
                    if (!Array.isArray(object.certificates))
                        throw TypeError(".api.ReplTransfer.certificates: array expected");
                    message.certificates = [];
                    for (var i = 0; i < object.certificates.length; ++i) {
                        if (typeof object.certificates[i] !== "object")
                            throw TypeError(".api.ReplTransfer.certificates: object expected");
                        message.certificates[i] = $root.api.TLSCertificate.fromObject(object.certificates[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ReplTransfer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ReplTransfer
             * @static
             * @param {api.ReplTransfer} message ReplTransfer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplTransfer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.customDomains = [];
                    object.certificates = [];
                }
                if (options.defaults) {
                    object.repl = null;
                    object.replLimits = null;
                    object.userLimits = null;
                }
                if (message.repl != null && message.hasOwnProperty("repl"))
                    object.repl = $root.api.Repl.toObject(message.repl, options);
                if (message.replLimits != null && message.hasOwnProperty("replLimits"))
                    object.replLimits = $root.api.ResourceLimits.toObject(message.replLimits, options);
                if (message.userLimits != null && message.hasOwnProperty("userLimits"))
                    object.userLimits = $root.api.ResourceLimits.toObject(message.userLimits, options);
                if (message.customDomains && message.customDomains.length) {
                    object.customDomains = [];
                    for (var j = 0; j < message.customDomains.length; ++j)
                        object.customDomains[j] = message.customDomains[j];
                }
                if (message.certificates && message.certificates.length) {
                    object.certificates = [];
                    for (var j = 0; j < message.certificates.length; ++j)
                        object.certificates[j] = $root.api.TLSCertificate.toObject(message.certificates[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ReplTransfer to JSON.
             * @function toJSON
             * @memberof api.ReplTransfer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplTransfer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ReplTransfer;
        })();
    
        api.AllowReplRequest = (function() {
    
            /**
             * Properties of an AllowReplRequest.
             * @memberof api
             * @interface IAllowReplRequest
             * @property {api.ReplTransfer|api.IReplTransfer|null} [replTransfer] AllowReplRequest replTransfer
             */
    
            /**
             * Constructs a new AllowReplRequest.
             * @memberof api
             * @classdesc Represents an AllowReplRequest.
             * @constructor
             * @param {api.IAllowReplRequest=} [properties] Properties to set
             */
            function AllowReplRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AllowReplRequest replTransfer.
             * @member {api.ReplTransfer|null|undefined} replTransfer
             * @memberof api.AllowReplRequest
             * @instance
             */
            AllowReplRequest.prototype.replTransfer = null;
    
            /**
             * Creates a new AllowReplRequest instance using the specified properties.
             * @function create
             * @memberof api.AllowReplRequest
             * @static
             * @param {api.IAllowReplRequest=} [properties] Properties to set
             * @returns {api.AllowReplRequest} AllowReplRequest instance
             */
            AllowReplRequest.create = function create(properties) {
                return AllowReplRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified AllowReplRequest message. Does not implicitly {@link api.AllowReplRequest.verify|verify} messages.
             * @function encode
             * @memberof api.AllowReplRequest
             * @static
             * @param {api.AllowReplRequest} message AllowReplRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllowReplRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replTransfer != null && Object.hasOwnProperty.call(message, "replTransfer"))
                    $root.api.ReplTransfer.encode(message.replTransfer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified AllowReplRequest message, length delimited. Does not implicitly {@link api.AllowReplRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.AllowReplRequest
             * @static
             * @param {api.AllowReplRequest} message AllowReplRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllowReplRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AllowReplRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.AllowReplRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.AllowReplRequest} AllowReplRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllowReplRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.AllowReplRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replTransfer = $root.api.ReplTransfer.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AllowReplRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.AllowReplRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.AllowReplRequest} AllowReplRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllowReplRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AllowReplRequest message.
             * @function verify
             * @memberof api.AllowReplRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AllowReplRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replTransfer != null && message.hasOwnProperty("replTransfer")) {
                    var error = $root.api.ReplTransfer.verify(message.replTransfer);
                    if (error)
                        return "replTransfer." + error;
                }
                return null;
            };
    
            /**
             * Creates an AllowReplRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.AllowReplRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.AllowReplRequest} AllowReplRequest
             */
            AllowReplRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.AllowReplRequest)
                    return object;
                var message = new $root.api.AllowReplRequest();
                if (object.replTransfer != null) {
                    if (typeof object.replTransfer !== "object")
                        throw TypeError(".api.AllowReplRequest.replTransfer: object expected");
                    message.replTransfer = $root.api.ReplTransfer.fromObject(object.replTransfer);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an AllowReplRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.AllowReplRequest
             * @static
             * @param {api.AllowReplRequest} message AllowReplRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AllowReplRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replTransfer = null;
                if (message.replTransfer != null && message.hasOwnProperty("replTransfer"))
                    object.replTransfer = $root.api.ReplTransfer.toObject(message.replTransfer, options);
                return object;
            };
    
            /**
             * Converts this AllowReplRequest to JSON.
             * @function toJSON
             * @memberof api.AllowReplRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AllowReplRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AllowReplRequest;
        })();
    
        api.ClusterMetadata = (function() {
    
            /**
             * Properties of a ClusterMetadata.
             * @memberof api
             * @interface IClusterMetadata
             * @property {string|null} [id] ClusterMetadata id
             * @property {string|null} [conmanURL] ClusterMetadata conmanURL
             * @property {string|null} [gurl] ClusterMetadata gurl
             * @property {string|null} [proxyHost] ClusterMetadata proxyHost
             * @property {string|null} [proxy] ClusterMetadata proxy
             * @property {string|null} [proxyIP] ClusterMetadata proxyIP
             */
    
            /**
             * Constructs a new ClusterMetadata.
             * @memberof api
             * @classdesc Represents a ClusterMetadata.
             * @constructor
             * @param {api.IClusterMetadata=} [properties] Properties to set
             */
            function ClusterMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ClusterMetadata id.
             * @member {string} id
             * @memberof api.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.id = "";
    
            /**
             * ClusterMetadata conmanURL.
             * @member {string} conmanURL
             * @memberof api.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.conmanURL = "";
    
            /**
             * ClusterMetadata gurl.
             * @member {string} gurl
             * @memberof api.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.gurl = "";
    
            /**
             * ClusterMetadata proxyHost.
             * @member {string} proxyHost
             * @memberof api.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.proxyHost = "";
    
            /**
             * ClusterMetadata proxy.
             * @member {string} proxy
             * @memberof api.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.proxy = "";
    
            /**
             * ClusterMetadata proxyIP.
             * @member {string} proxyIP
             * @memberof api.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.proxyIP = "";
    
            /**
             * Creates a new ClusterMetadata instance using the specified properties.
             * @function create
             * @memberof api.ClusterMetadata
             * @static
             * @param {api.IClusterMetadata=} [properties] Properties to set
             * @returns {api.ClusterMetadata} ClusterMetadata instance
             */
            ClusterMetadata.create = function create(properties) {
                return ClusterMetadata.fromObject(properties);
            };
    
            /**
             * Encodes the specified ClusterMetadata message. Does not implicitly {@link api.ClusterMetadata.verify|verify} messages.
             * @function encode
             * @memberof api.ClusterMetadata
             * @static
             * @param {api.ClusterMetadata} message ClusterMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.conmanURL != null && Object.hasOwnProperty.call(message, "conmanURL"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.conmanURL);
                if (message.gurl != null && Object.hasOwnProperty.call(message, "gurl"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.gurl);
                if (message.proxyHost != null && Object.hasOwnProperty.call(message, "proxyHost"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.proxyHost);
                if (message.proxy != null && Object.hasOwnProperty.call(message, "proxy"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.proxy);
                if (message.proxyIP != null && Object.hasOwnProperty.call(message, "proxyIP"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.proxyIP);
                return writer;
            };
    
            /**
             * Encodes the specified ClusterMetadata message, length delimited. Does not implicitly {@link api.ClusterMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.ClusterMetadata
             * @static
             * @param {api.ClusterMetadata} message ClusterMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ClusterMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof api.ClusterMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.ClusterMetadata} ClusterMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ClusterMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.conmanURL = reader.string();
                        break;
                    case 3:
                        message.gurl = reader.string();
                        break;
                    case 4:
                        message.proxyHost = reader.string();
                        break;
                    case 5:
                        message.proxy = reader.string();
                        break;
                    case 6:
                        message.proxyIP = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ClusterMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.ClusterMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.ClusterMetadata} ClusterMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ClusterMetadata message.
             * @function verify
             * @memberof api.ClusterMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClusterMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.conmanURL != null && message.hasOwnProperty("conmanURL"))
                    if (!$util.isString(message.conmanURL))
                        return "conmanURL: string expected";
                if (message.gurl != null && message.hasOwnProperty("gurl"))
                    if (!$util.isString(message.gurl))
                        return "gurl: string expected";
                if (message.proxyHost != null && message.hasOwnProperty("proxyHost"))
                    if (!$util.isString(message.proxyHost))
                        return "proxyHost: string expected";
                if (message.proxy != null && message.hasOwnProperty("proxy"))
                    if (!$util.isString(message.proxy))
                        return "proxy: string expected";
                if (message.proxyIP != null && message.hasOwnProperty("proxyIP"))
                    if (!$util.isString(message.proxyIP))
                        return "proxyIP: string expected";
                return null;
            };
    
            /**
             * Creates a ClusterMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.ClusterMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.ClusterMetadata} ClusterMetadata
             */
            ClusterMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.api.ClusterMetadata)
                    return object;
                var message = new $root.api.ClusterMetadata();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.conmanURL != null)
                    message.conmanURL = String(object.conmanURL);
                if (object.gurl != null)
                    message.gurl = String(object.gurl);
                if (object.proxyHost != null)
                    message.proxyHost = String(object.proxyHost);
                if (object.proxy != null)
                    message.proxy = String(object.proxy);
                if (object.proxyIP != null)
                    message.proxyIP = String(object.proxyIP);
                return message;
            };
    
            /**
             * Creates a plain object from a ClusterMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.ClusterMetadata
             * @static
             * @param {api.ClusterMetadata} message ClusterMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClusterMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.conmanURL = "";
                    object.gurl = "";
                    object.proxyHost = "";
                    object.proxy = "";
                    object.proxyIP = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.conmanURL != null && message.hasOwnProperty("conmanURL"))
                    object.conmanURL = message.conmanURL;
                if (message.gurl != null && message.hasOwnProperty("gurl"))
                    object.gurl = message.gurl;
                if (message.proxyHost != null && message.hasOwnProperty("proxyHost"))
                    object.proxyHost = message.proxyHost;
                if (message.proxy != null && message.hasOwnProperty("proxy"))
                    object.proxy = message.proxy;
                if (message.proxyIP != null && message.hasOwnProperty("proxyIP"))
                    object.proxyIP = message.proxyIP;
                return object;
            };
    
            /**
             * Converts this ClusterMetadata to JSON.
             * @function toJSON
             * @memberof api.ClusterMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClusterMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ClusterMetadata;
        })();
    
        api.EvictReplRequest = (function() {
    
            /**
             * Properties of an EvictReplRequest.
             * @memberof api
             * @interface IEvictReplRequest
             * @property {api.ClusterMetadata|api.IClusterMetadata|null} [clusterMetadata] EvictReplRequest clusterMetadata
             * @property {string|null} [token] EvictReplRequest token
             * @property {string|null} [user] EvictReplRequest user
             * @property {string|null} [slug] EvictReplRequest slug
             */
    
            /**
             * Constructs a new EvictReplRequest.
             * @memberof api
             * @classdesc Represents an EvictReplRequest.
             * @constructor
             * @param {api.IEvictReplRequest=} [properties] Properties to set
             */
            function EvictReplRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * EvictReplRequest clusterMetadata.
             * @member {api.ClusterMetadata|null|undefined} clusterMetadata
             * @memberof api.EvictReplRequest
             * @instance
             */
            EvictReplRequest.prototype.clusterMetadata = null;
    
            /**
             * EvictReplRequest token.
             * @member {string} token
             * @memberof api.EvictReplRequest
             * @instance
             */
            EvictReplRequest.prototype.token = "";
    
            /**
             * EvictReplRequest user.
             * @member {string} user
             * @memberof api.EvictReplRequest
             * @instance
             */
            EvictReplRequest.prototype.user = "";
    
            /**
             * EvictReplRequest slug.
             * @member {string} slug
             * @memberof api.EvictReplRequest
             * @instance
             */
            EvictReplRequest.prototype.slug = "";
    
            /**
             * Creates a new EvictReplRequest instance using the specified properties.
             * @function create
             * @memberof api.EvictReplRequest
             * @static
             * @param {api.IEvictReplRequest=} [properties] Properties to set
             * @returns {api.EvictReplRequest} EvictReplRequest instance
             */
            EvictReplRequest.create = function create(properties) {
                return EvictReplRequest.fromObject(properties);
            };
    
            /**
             * Encodes the specified EvictReplRequest message. Does not implicitly {@link api.EvictReplRequest.verify|verify} messages.
             * @function encode
             * @memberof api.EvictReplRequest
             * @static
             * @param {api.EvictReplRequest} message EvictReplRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvictReplRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clusterMetadata != null && Object.hasOwnProperty.call(message, "clusterMetadata"))
                    $root.api.ClusterMetadata.encode(message.clusterMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.user);
                if (message.slug != null && Object.hasOwnProperty.call(message, "slug"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.slug);
                return writer;
            };
    
            /**
             * Encodes the specified EvictReplRequest message, length delimited. Does not implicitly {@link api.EvictReplRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.EvictReplRequest
             * @static
             * @param {api.EvictReplRequest} message EvictReplRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvictReplRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an EvictReplRequest message from the specified reader or buffer.
             * @function decode
             * @memberof api.EvictReplRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.EvictReplRequest} EvictReplRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvictReplRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.EvictReplRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clusterMetadata = $root.api.ClusterMetadata.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.token = reader.string();
                        break;
                    case 3:
                        message.user = reader.string();
                        break;
                    case 4:
                        message.slug = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an EvictReplRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.EvictReplRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.EvictReplRequest} EvictReplRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvictReplRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an EvictReplRequest message.
             * @function verify
             * @memberof api.EvictReplRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EvictReplRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.clusterMetadata != null && message.hasOwnProperty("clusterMetadata")) {
                    var error = $root.api.ClusterMetadata.verify(message.clusterMetadata);
                    if (error)
                        return "clusterMetadata." + error;
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!$util.isString(message.user))
                        return "user: string expected";
                if (message.slug != null && message.hasOwnProperty("slug"))
                    if (!$util.isString(message.slug))
                        return "slug: string expected";
                return null;
            };
    
            /**
             * Creates an EvictReplRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.EvictReplRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.EvictReplRequest} EvictReplRequest
             */
            EvictReplRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.api.EvictReplRequest)
                    return object;
                var message = new $root.api.EvictReplRequest();
                if (object.clusterMetadata != null) {
                    if (typeof object.clusterMetadata !== "object")
                        throw TypeError(".api.EvictReplRequest.clusterMetadata: object expected");
                    message.clusterMetadata = $root.api.ClusterMetadata.fromObject(object.clusterMetadata);
                }
                if (object.token != null)
                    message.token = String(object.token);
                if (object.user != null)
                    message.user = String(object.user);
                if (object.slug != null)
                    message.slug = String(object.slug);
                return message;
            };
    
            /**
             * Creates a plain object from an EvictReplRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.EvictReplRequest
             * @static
             * @param {api.EvictReplRequest} message EvictReplRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EvictReplRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.clusterMetadata = null;
                    object.token = "";
                    object.user = "";
                    object.slug = "";
                }
                if (message.clusterMetadata != null && message.hasOwnProperty("clusterMetadata"))
                    object.clusterMetadata = $root.api.ClusterMetadata.toObject(message.clusterMetadata, options);
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = message.user;
                if (message.slug != null && message.hasOwnProperty("slug"))
                    object.slug = message.slug;
                return object;
            };
    
            /**
             * Converts this EvictReplRequest to JSON.
             * @function toJSON
             * @memberof api.EvictReplRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EvictReplRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return EvictReplRequest;
        })();
    
        api.EvictReplResponse = (function() {
    
            /**
             * Properties of an EvictReplResponse.
             * @memberof api
             * @interface IEvictReplResponse
             * @property {api.ReplTransfer|api.IReplTransfer|null} [replTransfer] EvictReplResponse replTransfer
             */
    
            /**
             * Constructs a new EvictReplResponse.
             * @memberof api
             * @classdesc Represents an EvictReplResponse.
             * @constructor
             * @param {api.IEvictReplResponse=} [properties] Properties to set
             */
            function EvictReplResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * EvictReplResponse replTransfer.
             * @member {api.ReplTransfer|null|undefined} replTransfer
             * @memberof api.EvictReplResponse
             * @instance
             */
            EvictReplResponse.prototype.replTransfer = null;
    
            /**
             * Creates a new EvictReplResponse instance using the specified properties.
             * @function create
             * @memberof api.EvictReplResponse
             * @static
             * @param {api.IEvictReplResponse=} [properties] Properties to set
             * @returns {api.EvictReplResponse} EvictReplResponse instance
             */
            EvictReplResponse.create = function create(properties) {
                return EvictReplResponse.fromObject(properties);
            };
    
            /**
             * Encodes the specified EvictReplResponse message. Does not implicitly {@link api.EvictReplResponse.verify|verify} messages.
             * @function encode
             * @memberof api.EvictReplResponse
             * @static
             * @param {api.EvictReplResponse} message EvictReplResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvictReplResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replTransfer != null && Object.hasOwnProperty.call(message, "replTransfer"))
                    $root.api.ReplTransfer.encode(message.replTransfer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified EvictReplResponse message, length delimited. Does not implicitly {@link api.EvictReplResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.EvictReplResponse
             * @static
             * @param {api.EvictReplResponse} message EvictReplResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EvictReplResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an EvictReplResponse message from the specified reader or buffer.
             * @function decode
             * @memberof api.EvictReplResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.EvictReplResponse} EvictReplResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvictReplResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.EvictReplResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replTransfer = $root.api.ReplTransfer.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an EvictReplResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.EvictReplResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.EvictReplResponse} EvictReplResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EvictReplResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an EvictReplResponse message.
             * @function verify
             * @memberof api.EvictReplResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EvictReplResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replTransfer != null && message.hasOwnProperty("replTransfer")) {
                    var error = $root.api.ReplTransfer.verify(message.replTransfer);
                    if (error)
                        return "replTransfer." + error;
                }
                return null;
            };
    
            /**
             * Creates an EvictReplResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.EvictReplResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.EvictReplResponse} EvictReplResponse
             */
            EvictReplResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.api.EvictReplResponse)
                    return object;
                var message = new $root.api.EvictReplResponse();
                if (object.replTransfer != null) {
                    if (typeof object.replTransfer !== "object")
                        throw TypeError(".api.EvictReplResponse.replTransfer: object expected");
                    message.replTransfer = $root.api.ReplTransfer.fromObject(object.replTransfer);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an EvictReplResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.EvictReplResponse
             * @static
             * @param {api.EvictReplResponse} message EvictReplResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EvictReplResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replTransfer = null;
                if (message.replTransfer != null && message.hasOwnProperty("replTransfer"))
                    object.replTransfer = $root.api.ReplTransfer.toObject(message.replTransfer, options);
                return object;
            };
    
            /**
             * Converts this EvictReplResponse to JSON.
             * @function toJSON
             * @memberof api.EvictReplResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EvictReplResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return EvictReplResponse;
        })();
    
        /**
         * TokenVersion enum.
         * @name api.TokenVersion
         * @enum {number}
         * @property {number} BARE_REPL_TOKEN=0 BARE_REPL_TOKEN value
         * @property {number} TYPE_AWARE_TOKEN=1 TYPE_AWARE_TOKEN value
         */
        api.TokenVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BARE_REPL_TOKEN"] = 0;
            values[valuesById[1] = "TYPE_AWARE_TOKEN"] = 1;
            return values;
        })();
    
        api.GovalSigningAuthority = (function() {
    
            /**
             * Properties of a GovalSigningAuthority.
             * @memberof api
             * @interface IGovalSigningAuthority
             * @property {string|null} [keyId] GovalSigningAuthority keyId
             * @property {string|null} [signedCert] GovalSigningAuthority signedCert
             * @property {api.TokenVersion|null} [version] GovalSigningAuthority version
             */
    
            /**
             * Constructs a new GovalSigningAuthority.
             * @memberof api
             * @classdesc Represents a GovalSigningAuthority.
             * @constructor
             * @param {api.IGovalSigningAuthority=} [properties] Properties to set
             */
            function GovalSigningAuthority(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GovalSigningAuthority keyId.
             * @member {string} keyId
             * @memberof api.GovalSigningAuthority
             * @instance
             */
            GovalSigningAuthority.prototype.keyId = "";
    
            /**
             * GovalSigningAuthority signedCert.
             * @member {string} signedCert
             * @memberof api.GovalSigningAuthority
             * @instance
             */
            GovalSigningAuthority.prototype.signedCert = "";
    
            /**
             * GovalSigningAuthority version.
             * @member {api.TokenVersion} version
             * @memberof api.GovalSigningAuthority
             * @instance
             */
            GovalSigningAuthority.prototype.version = 0;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * GovalSigningAuthority cert.
             * @member {"keyId"|"signedCert"|undefined} cert
             * @memberof api.GovalSigningAuthority
             * @instance
             */
            Object.defineProperty(GovalSigningAuthority.prototype, "cert", {
                get: $util.oneOfGetter($oneOfFields = ["keyId", "signedCert"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new GovalSigningAuthority instance using the specified properties.
             * @function create
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {api.IGovalSigningAuthority=} [properties] Properties to set
             * @returns {api.GovalSigningAuthority} GovalSigningAuthority instance
             */
            GovalSigningAuthority.create = function create(properties) {
                return GovalSigningAuthority.fromObject(properties);
            };
    
            /**
             * Encodes the specified GovalSigningAuthority message. Does not implicitly {@link api.GovalSigningAuthority.verify|verify} messages.
             * @function encode
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {api.GovalSigningAuthority} message GovalSigningAuthority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GovalSigningAuthority.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyId != null && Object.hasOwnProperty.call(message, "keyId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyId);
                if (message.signedCert != null && Object.hasOwnProperty.call(message, "signedCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.signedCert);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
                return writer;
            };
    
            /**
             * Encodes the specified GovalSigningAuthority message, length delimited. Does not implicitly {@link api.GovalSigningAuthority.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {api.GovalSigningAuthority} message GovalSigningAuthority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GovalSigningAuthority.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GovalSigningAuthority message from the specified reader or buffer.
             * @function decode
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.GovalSigningAuthority} GovalSigningAuthority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GovalSigningAuthority.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GovalSigningAuthority();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyId = reader.string();
                        break;
                    case 2:
                        message.signedCert = reader.string();
                        break;
                    case 3:
                        message.version = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GovalSigningAuthority message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.GovalSigningAuthority} GovalSigningAuthority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GovalSigningAuthority.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GovalSigningAuthority message.
             * @function verify
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GovalSigningAuthority.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.keyId != null && message.hasOwnProperty("keyId")) {
                    properties.cert = 1;
                    if (!$util.isString(message.keyId))
                        return "keyId: string expected";
                }
                if (message.signedCert != null && message.hasOwnProperty("signedCert")) {
                    if (properties.cert === 1)
                        return "cert: multiple values";
                    properties.cert = 1;
                    if (!$util.isString(message.signedCert))
                        return "signedCert: string expected";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    switch (message.version) {
                    default:
                        return "version: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a GovalSigningAuthority message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.GovalSigningAuthority} GovalSigningAuthority
             */
            GovalSigningAuthority.fromObject = function fromObject(object) {
                if (object instanceof $root.api.GovalSigningAuthority)
                    return object;
                var message = new $root.api.GovalSigningAuthority();
                if (object.keyId != null)
                    message.keyId = String(object.keyId);
                if (object.signedCert != null)
                    message.signedCert = String(object.signedCert);
                switch (object.version) {
                case "BARE_REPL_TOKEN":
                case 0:
                    message.version = 0;
                    break;
                case "TYPE_AWARE_TOKEN":
                case 1:
                    message.version = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a GovalSigningAuthority message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.GovalSigningAuthority
             * @static
             * @param {api.GovalSigningAuthority} message GovalSigningAuthority
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GovalSigningAuthority.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.version = options.enums === String ? "BARE_REPL_TOKEN" : 0;
                if (message.keyId != null && message.hasOwnProperty("keyId")) {
                    object.keyId = message.keyId;
                    if (options.oneofs)
                        object.cert = "keyId";
                }
                if (message.signedCert != null && message.hasOwnProperty("signedCert")) {
                    object.signedCert = message.signedCert;
                    if (options.oneofs)
                        object.cert = "signedCert";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = options.enums === String ? $root.api.TokenVersion[message.version] : message.version;
                return object;
            };
    
            /**
             * Converts this GovalSigningAuthority to JSON.
             * @function toJSON
             * @memberof api.GovalSigningAuthority
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GovalSigningAuthority.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GovalSigningAuthority;
        })();
    
        /**
         * FlagClaim enum.
         * @name api.FlagClaim
         * @enum {number}
         * @property {number} MINT_GOVAL_TOKEN=0 MINT_GOVAL_TOKEN value
         * @property {number} SIGN_INTERMEDIATE_CERT=1 SIGN_INTERMEDIATE_CERT value
         */
        api.FlagClaim = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MINT_GOVAL_TOKEN"] = 0;
            values[valuesById[1] = "SIGN_INTERMEDIATE_CERT"] = 1;
            return values;
        })();
    
        api.CertificateClaim = (function() {
    
            /**
             * Properties of a CertificateClaim.
             * @memberof api
             * @interface ICertificateClaim
             * @property {string|null} [replid] CertificateClaim replid
             * @property {string|null} [user] CertificateClaim user
             * @property {api.FlagClaim|null} [flag] CertificateClaim flag
             */
    
            /**
             * Constructs a new CertificateClaim.
             * @memberof api
             * @classdesc Represents a CertificateClaim.
             * @constructor
             * @param {api.ICertificateClaim=} [properties] Properties to set
             */
            function CertificateClaim(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CertificateClaim replid.
             * @member {string} replid
             * @memberof api.CertificateClaim
             * @instance
             */
            CertificateClaim.prototype.replid = "";
    
            /**
             * CertificateClaim user.
             * @member {string} user
             * @memberof api.CertificateClaim
             * @instance
             */
            CertificateClaim.prototype.user = "";
    
            /**
             * CertificateClaim flag.
             * @member {api.FlagClaim} flag
             * @memberof api.CertificateClaim
             * @instance
             */
            CertificateClaim.prototype.flag = 0;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CertificateClaim claim.
             * @member {"replid"|"user"|"flag"|undefined} claim
             * @memberof api.CertificateClaim
             * @instance
             */
            Object.defineProperty(CertificateClaim.prototype, "claim", {
                get: $util.oneOfGetter($oneOfFields = ["replid", "user", "flag"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CertificateClaim instance using the specified properties.
             * @function create
             * @memberof api.CertificateClaim
             * @static
             * @param {api.ICertificateClaim=} [properties] Properties to set
             * @returns {api.CertificateClaim} CertificateClaim instance
             */
            CertificateClaim.create = function create(properties) {
                return CertificateClaim.fromObject(properties);
            };
    
            /**
             * Encodes the specified CertificateClaim message. Does not implicitly {@link api.CertificateClaim.verify|verify} messages.
             * @function encode
             * @memberof api.CertificateClaim
             * @static
             * @param {api.CertificateClaim} message CertificateClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CertificateClaim.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replid != null && Object.hasOwnProperty.call(message, "replid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.replid);
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.user);
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.flag);
                return writer;
            };
    
            /**
             * Encodes the specified CertificateClaim message, length delimited. Does not implicitly {@link api.CertificateClaim.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.CertificateClaim
             * @static
             * @param {api.CertificateClaim} message CertificateClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CertificateClaim.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CertificateClaim message from the specified reader or buffer.
             * @function decode
             * @memberof api.CertificateClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.CertificateClaim} CertificateClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CertificateClaim.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CertificateClaim();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replid = reader.string();
                        break;
                    case 2:
                        message.user = reader.string();
                        break;
                    case 3:
                        message.flag = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CertificateClaim message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.CertificateClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.CertificateClaim} CertificateClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CertificateClaim.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CertificateClaim message.
             * @function verify
             * @memberof api.CertificateClaim
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CertificateClaim.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.replid != null && message.hasOwnProperty("replid")) {
                    properties.claim = 1;
                    if (!$util.isString(message.replid))
                        return "replid: string expected";
                }
                if (message.user != null && message.hasOwnProperty("user")) {
                    if (properties.claim === 1)
                        return "claim: multiple values";
                    properties.claim = 1;
                    if (!$util.isString(message.user))
                        return "user: string expected";
                }
                if (message.flag != null && message.hasOwnProperty("flag")) {
                    if (properties.claim === 1)
                        return "claim: multiple values";
                    properties.claim = 1;
                    switch (message.flag) {
                    default:
                        return "flag: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CertificateClaim message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.CertificateClaim
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.CertificateClaim} CertificateClaim
             */
            CertificateClaim.fromObject = function fromObject(object) {
                if (object instanceof $root.api.CertificateClaim)
                    return object;
                var message = new $root.api.CertificateClaim();
                if (object.replid != null)
                    message.replid = String(object.replid);
                if (object.user != null)
                    message.user = String(object.user);
                switch (object.flag) {
                case "MINT_GOVAL_TOKEN":
                case 0:
                    message.flag = 0;
                    break;
                case "SIGN_INTERMEDIATE_CERT":
                case 1:
                    message.flag = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CertificateClaim message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.CertificateClaim
             * @static
             * @param {api.CertificateClaim} message CertificateClaim
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CertificateClaim.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.replid != null && message.hasOwnProperty("replid")) {
                    object.replid = message.replid;
                    if (options.oneofs)
                        object.claim = "replid";
                }
                if (message.user != null && message.hasOwnProperty("user")) {
                    object.user = message.user;
                    if (options.oneofs)
                        object.claim = "user";
                }
                if (message.flag != null && message.hasOwnProperty("flag")) {
                    object.flag = options.enums === String ? $root.api.FlagClaim[message.flag] : message.flag;
                    if (options.oneofs)
                        object.claim = "flag";
                }
                return object;
            };
    
            /**
             * Converts this CertificateClaim to JSON.
             * @function toJSON
             * @memberof api.CertificateClaim
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CertificateClaim.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CertificateClaim;
        })();
    
        api.GovalCert = (function() {
    
            /**
             * Properties of a GovalCert.
             * @memberof api
             * @interface IGovalCert
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [iat] GovalCert iat
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [exp] GovalCert exp
             * @property {Array.<api.CertificateClaim|api.ICertificateClaim>|null} [claims] GovalCert claims
             * @property {string|null} [publicKey] GovalCert publicKey
             */
    
            /**
             * Constructs a new GovalCert.
             * @memberof api
             * @classdesc Represents a GovalCert.
             * @constructor
             * @param {api.IGovalCert=} [properties] Properties to set
             */
            function GovalCert(properties) {
                this.claims = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GovalCert iat.
             * @member {google.protobuf.Timestamp|null|undefined} iat
             * @memberof api.GovalCert
             * @instance
             */
            GovalCert.prototype.iat = null;
    
            /**
             * GovalCert exp.
             * @member {google.protobuf.Timestamp|null|undefined} exp
             * @memberof api.GovalCert
             * @instance
             */
            GovalCert.prototype.exp = null;
    
            /**
             * GovalCert claims.
             * @member {Array.<api.CertificateClaim>} claims
             * @memberof api.GovalCert
             * @instance
             */
            GovalCert.prototype.claims = $util.emptyArray;
    
            /**
             * GovalCert publicKey.
             * @member {string} publicKey
             * @memberof api.GovalCert
             * @instance
             */
            GovalCert.prototype.publicKey = "";
    
            /**
             * Creates a new GovalCert instance using the specified properties.
             * @function create
             * @memberof api.GovalCert
             * @static
             * @param {api.IGovalCert=} [properties] Properties to set
             * @returns {api.GovalCert} GovalCert instance
             */
            GovalCert.create = function create(properties) {
                return GovalCert.fromObject(properties);
            };
    
            /**
             * Encodes the specified GovalCert message. Does not implicitly {@link api.GovalCert.verify|verify} messages.
             * @function encode
             * @memberof api.GovalCert
             * @static
             * @param {api.GovalCert} message GovalCert message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GovalCert.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.iat != null && Object.hasOwnProperty.call(message, "iat"))
                    $root.google.protobuf.Timestamp.encode(message.iat, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                    $root.google.protobuf.Timestamp.encode(message.exp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.claims != null && message.claims.length)
                    for (var i = 0; i < message.claims.length; ++i)
                        $root.api.CertificateClaim.encode(message.claims[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.publicKey);
                return writer;
            };
    
            /**
             * Encodes the specified GovalCert message, length delimited. Does not implicitly {@link api.GovalCert.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.GovalCert
             * @static
             * @param {api.GovalCert} message GovalCert message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GovalCert.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GovalCert message from the specified reader or buffer.
             * @function decode
             * @memberof api.GovalCert
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.GovalCert} GovalCert
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GovalCert.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GovalCert();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.iat = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.exp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.claims && message.claims.length))
                            message.claims = [];
                        message.claims.push($root.api.CertificateClaim.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.publicKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GovalCert message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.GovalCert
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.GovalCert} GovalCert
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GovalCert.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GovalCert message.
             * @function verify
             * @memberof api.GovalCert
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GovalCert.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.iat != null && message.hasOwnProperty("iat")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.iat);
                    if (error)
                        return "iat." + error;
                }
                if (message.exp != null && message.hasOwnProperty("exp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.exp);
                    if (error)
                        return "exp." + error;
                }
                if (message.claims != null && message.hasOwnProperty("claims")) {
                    if (!Array.isArray(message.claims))
                        return "claims: array expected";
                    for (var i = 0; i < message.claims.length; ++i) {
                        var error = $root.api.CertificateClaim.verify(message.claims[i]);
                        if (error)
                            return "claims." + error;
                    }
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    if (!$util.isString(message.publicKey))
                        return "publicKey: string expected";
                return null;
            };
    
            /**
             * Creates a GovalCert message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.GovalCert
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.GovalCert} GovalCert
             */
            GovalCert.fromObject = function fromObject(object) {
                if (object instanceof $root.api.GovalCert)
                    return object;
                var message = new $root.api.GovalCert();
                if (object.iat != null) {
                    if (typeof object.iat !== "object")
                        throw TypeError(".api.GovalCert.iat: object expected");
                    message.iat = $root.google.protobuf.Timestamp.fromObject(object.iat);
                }
                if (object.exp != null) {
                    if (typeof object.exp !== "object")
                        throw TypeError(".api.GovalCert.exp: object expected");
                    message.exp = $root.google.protobuf.Timestamp.fromObject(object.exp);
                }
                if (object.claims) {
                    if (!Array.isArray(object.claims))
                        throw TypeError(".api.GovalCert.claims: array expected");
                    message.claims = [];
                    for (var i = 0; i < object.claims.length; ++i) {
                        if (typeof object.claims[i] !== "object")
                            throw TypeError(".api.GovalCert.claims: object expected");
                        message.claims[i] = $root.api.CertificateClaim.fromObject(object.claims[i]);
                    }
                }
                if (object.publicKey != null)
                    message.publicKey = String(object.publicKey);
                return message;
            };
    
            /**
             * Creates a plain object from a GovalCert message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.GovalCert
             * @static
             * @param {api.GovalCert} message GovalCert
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GovalCert.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.claims = [];
                if (options.defaults) {
                    object.iat = null;
                    object.exp = null;
                    object.publicKey = "";
                }
                if (message.iat != null && message.hasOwnProperty("iat"))
                    object.iat = $root.google.protobuf.Timestamp.toObject(message.iat, options);
                if (message.exp != null && message.hasOwnProperty("exp"))
                    object.exp = $root.google.protobuf.Timestamp.toObject(message.exp, options);
                if (message.claims && message.claims.length) {
                    object.claims = [];
                    for (var j = 0; j < message.claims.length; ++j)
                        object.claims[j] = $root.api.CertificateClaim.toObject(message.claims[j], options);
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    object.publicKey = message.publicKey;
                return object;
            };
    
            /**
             * Converts this GovalCert to JSON.
             * @function toJSON
             * @memberof api.GovalCert
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GovalCert.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GovalCert;
        })();
    
        api.GovalToken = (function() {
    
            /**
             * Properties of a GovalToken.
             * @memberof api
             * @interface IGovalToken
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [iat] GovalToken iat
             * @property {google.protobuf.Timestamp|google.protobuf.ITimestamp|null} [exp] GovalToken exp
             * @property {string|null} [replid] GovalToken replid
             * @property {api.ReplToken|api.IReplToken|null} [replToken] GovalToken replToken
             */
    
            /**
             * Constructs a new GovalToken.
             * @memberof api
             * @classdesc Represents a GovalToken.
             * @constructor
             * @param {api.IGovalToken=} [properties] Properties to set
             */
            function GovalToken(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GovalToken iat.
             * @member {google.protobuf.Timestamp|null|undefined} iat
             * @memberof api.GovalToken
             * @instance
             */
            GovalToken.prototype.iat = null;
    
            /**
             * GovalToken exp.
             * @member {google.protobuf.Timestamp|null|undefined} exp
             * @memberof api.GovalToken
             * @instance
             */
            GovalToken.prototype.exp = null;
    
            /**
             * GovalToken replid.
             * @member {string} replid
             * @memberof api.GovalToken
             * @instance
             */
            GovalToken.prototype.replid = "";
    
            /**
             * GovalToken replToken.
             * @member {api.ReplToken|null|undefined} replToken
             * @memberof api.GovalToken
             * @instance
             */
            GovalToken.prototype.replToken = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * GovalToken Token.
             * @member {"replToken"|undefined} Token
             * @memberof api.GovalToken
             * @instance
             */
            Object.defineProperty(GovalToken.prototype, "Token", {
                get: $util.oneOfGetter($oneOfFields = ["replToken"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new GovalToken instance using the specified properties.
             * @function create
             * @memberof api.GovalToken
             * @static
             * @param {api.IGovalToken=} [properties] Properties to set
             * @returns {api.GovalToken} GovalToken instance
             */
            GovalToken.create = function create(properties) {
                return GovalToken.fromObject(properties);
            };
    
            /**
             * Encodes the specified GovalToken message. Does not implicitly {@link api.GovalToken.verify|verify} messages.
             * @function encode
             * @memberof api.GovalToken
             * @static
             * @param {api.GovalToken} message GovalToken message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GovalToken.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.iat != null && Object.hasOwnProperty.call(message, "iat"))
                    $root.google.protobuf.Timestamp.encode(message.iat, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                    $root.google.protobuf.Timestamp.encode(message.exp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.replid != null && Object.hasOwnProperty.call(message, "replid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.replid);
                if (message.replToken != null && Object.hasOwnProperty.call(message, "replToken"))
                    $root.api.ReplToken.encode(message.replToken, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified GovalToken message, length delimited. Does not implicitly {@link api.GovalToken.verify|verify} messages.
             * @function encodeDelimited
             * @memberof api.GovalToken
             * @static
             * @param {api.GovalToken} message GovalToken message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GovalToken.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GovalToken message from the specified reader or buffer.
             * @function decode
             * @memberof api.GovalToken
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {api.GovalToken} GovalToken
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GovalToken.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GovalToken();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.iat = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.exp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.replid = reader.string();
                        break;
                    case 4:
                        message.replToken = $root.api.ReplToken.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GovalToken message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof api.GovalToken
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {api.GovalToken} GovalToken
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GovalToken.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GovalToken message.
             * @function verify
             * @memberof api.GovalToken
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GovalToken.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.iat != null && message.hasOwnProperty("iat")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.iat);
                    if (error)
                        return "iat." + error;
                }
                if (message.exp != null && message.hasOwnProperty("exp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.exp);
                    if (error)
                        return "exp." + error;
                }
                if (message.replid != null && message.hasOwnProperty("replid"))
                    if (!$util.isString(message.replid))
                        return "replid: string expected";
                if (message.replToken != null && message.hasOwnProperty("replToken")) {
                    properties.Token = 1;
                    {
                        var error = $root.api.ReplToken.verify(message.replToken);
                        if (error)
                            return "replToken." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a GovalToken message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof api.GovalToken
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {api.GovalToken} GovalToken
             */
            GovalToken.fromObject = function fromObject(object) {
                if (object instanceof $root.api.GovalToken)
                    return object;
                var message = new $root.api.GovalToken();
                if (object.iat != null) {
                    if (typeof object.iat !== "object")
                        throw TypeError(".api.GovalToken.iat: object expected");
                    message.iat = $root.google.protobuf.Timestamp.fromObject(object.iat);
                }
                if (object.exp != null) {
                    if (typeof object.exp !== "object")
                        throw TypeError(".api.GovalToken.exp: object expected");
                    message.exp = $root.google.protobuf.Timestamp.fromObject(object.exp);
                }
                if (object.replid != null)
                    message.replid = String(object.replid);
                if (object.replToken != null) {
                    if (typeof object.replToken !== "object")
                        throw TypeError(".api.GovalToken.replToken: object expected");
                    message.replToken = $root.api.ReplToken.fromObject(object.replToken);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a GovalToken message. Also converts values to other types if specified.
             * @function toObject
             * @memberof api.GovalToken
             * @static
             * @param {api.GovalToken} message GovalToken
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GovalToken.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.iat = null;
                    object.exp = null;
                    object.replid = "";
                }
                if (message.iat != null && message.hasOwnProperty("iat"))
                    object.iat = $root.google.protobuf.Timestamp.toObject(message.iat, options);
                if (message.exp != null && message.hasOwnProperty("exp"))
                    object.exp = $root.google.protobuf.Timestamp.toObject(message.exp, options);
                if (message.replid != null && message.hasOwnProperty("replid"))
                    object.replid = message.replid;
                if (message.replToken != null && message.hasOwnProperty("replToken")) {
                    object.replToken = $root.api.ReplToken.toObject(message.replToken, options);
                    if (options.oneofs)
                        object.Token = "replToken";
                }
                return object;
            };
    
            /**
             * Converts this GovalToken to JSON.
             * @function toJSON
             * @memberof api.GovalToken
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GovalToken.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GovalToken;
        })();
    
        return api;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.Timestamp = (function() {
    
                /**
                 * Properties of a Timestamp.
                 * @memberof google.protobuf
                 * @interface ITimestamp
                 * @property {number|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */
    
                /**
                 * Constructs a new Timestamp.
                 * @memberof google.protobuf
                 * @classdesc Represents a Timestamp.
                 * @constructor
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Timestamp seconds.
                 * @member {number} seconds
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;
    
                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 * @returns {google.protobuf.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return Timestamp.fromObject(properties);
                };
    
                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.Timestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.Timestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Timestamp)
                        return object;
                    var message = new $root.google.protobuf.Timestamp();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.Timestamp} message Timestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };
    
                /**
                 * Converts this Timestamp to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Timestamp;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
